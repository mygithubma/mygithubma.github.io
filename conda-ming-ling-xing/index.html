<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="路漫漫其修远兮，吾将上下而求索。">
<meta name="theme-color" content="#495057">
<title>conda命令行 | Gridea</title>
<link rel="shortcut icon" href="/favicon.ico?v=1762011157695">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="conda命令行" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Gridea</span>
            </a>  
          
        </div>
        
          <p class="subtitle">寄蜉蝣于天地 渺沧海之一粟。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://lzmhc.top:8081/" target="_blank">
                  <i class="fa fa-globe"></i> 天空之城
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">枫</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">87</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://mygithubma.github.io/conda-ming-ling-xing/"> conda命令行 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2025-03-23 20:29:44">2025-03-23</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >1<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >174<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p>conda --version 查看conda的版本<br>
conda config --show  查看conda的环境配置<br>
#设置清华镜像<br>
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br>
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/<br>
#设置bioconda<br>
conda config --add channels bioconda<br>
conda config --add channels conda-forge<br>
#设置搜索时显示通道地址<br>
conda config --set show_channel_urls yes<br>
conda env list 查看conda的环境<br>
conda activate env 激活环境<br>
conda deactivate  退出环境<br>
conda remove --name env_name --all 删除指定环境<br>
conda remove --name env_name package_name删除环境中的指定包<br>
conda create -n env_name python=3.9 创建环境<br>
conda info 查看当前环境</p>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      枫
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://mygithubma.github.io/conda-ming-ling-xing/" title="conda命令行">https://mygithubma.github.io/conda-ming-ling-xing/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="各行业的PCB设计规范" href="https://mygithubma.github.io/ge-xing-ye-de-pcb-she-ji-gui-fan/">各行业的PCB设计规范</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="各行业的PCB设计规范" href="https://mygithubma.github.io/ge-xing-ye-de-pcb-she-ji-gui-fan/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Xteminal命令行" href="https://mygithubma.github.io/xteminal-ming-ling-xing/">Xteminal命令行</a>
        <a class="nav-mobile-next" title="Xteminal命令行" href="https://mygithubma.github.io/xteminal-ming-ling-xing/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\custom-bgImg.jpg" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-kuai-jie-jian-ding-yi-she-zhi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1761990764697.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先备份&lt;br&gt;
用文本打开&lt;br&gt;
修改快捷键主要两个命令：funckey和alias&lt;br&gt;
alias ~N new 是ctrl+N新建文件（alias定义快捷键有加 ~ 号。那就是要 ctrl+定义的按键才有效)&lt;br&gt;
alias N new 是输入单个N ，然后回车才有效。&lt;br&gt;
funckey n new 按n键即可实现(不用回车)&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761991428000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761991559679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
重启软件发现功能旁边显示定义的快捷键按键&lt;/p&gt;
">Cadence-快捷键定义设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-gui-ze-guan-li-qi-guan-bi-wang-luo-jiao-hu/"" data-c="
          &lt;p&gt;在规则管理器中默认会交互，在PCB中选择网络时规则管理器会自动跳转&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761931567438.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761931631411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
取消勾选&lt;/p&gt;
">Cadence-规则管理器关闭网络交互</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ddr/"" data-c="
          &lt;h1 id=&#34;区分&#34;&gt;区分：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;---DDR1：大片+圆口。&lt;/li&gt;
&lt;li&gt;---DDR2：小片+圆口。&lt;/li&gt;
&lt;li&gt;---DDR3：小片+方口。  1.5 V&lt;/li&gt;
&lt;li&gt;---DDR4：小片+方口、从有贴纸的方向看：DDR3的缺口在左边、DDR4的缺口在右边、DDR4将内存金手指设计为中间稍突出、边缘收矮。  1.2V&lt;/li&gt;
&lt;li&gt;---DDR5：1.1V&lt;/li&gt;
&lt;li&gt;从频率区分：&lt;/li&gt;
&lt;li&gt;---频率在400MHz以下 DDR1&lt;/li&gt;
&lt;li&gt;---频率在400到800MHz以内  DDR2&lt;/li&gt;
&lt;li&gt;---频率大于1000MHz  DDR3&lt;/li&gt;
&lt;li&gt;从PC区分：&lt;/li&gt;
&lt;li&gt;---PC：一代&lt;/li&gt;
&lt;li&gt;---PC2：二代&lt;/li&gt;
&lt;li&gt;---PC3：三代&lt;/li&gt;
&lt;li&gt;Kingston:金士顿&lt;/li&gt;
&lt;li&gt;---标签：KVR400K64C3A/512&lt;/li&gt;
&lt;li&gt;------频率为400MHz，容量为512M，DDR1&lt;/li&gt;
&lt;li&gt;------一代内存条有266MHz、333MHz、400MHz。&lt;/li&gt;
&lt;li&gt;---标签：KVR800D2N6/1G-SP&lt;/li&gt;
&lt;li&gt;------频率为800MHz，容量为1G，DDR2&lt;/li&gt;
&lt;li&gt;------二代内存条有533MHz、667MHz、800MHz。&lt;/li&gt;
&lt;li&gt;---标签：KVR1333D3N9/2G&lt;/li&gt;
&lt;li&gt;------频率为1333MHz，容量为2G，DDR3&lt;/li&gt;
&lt;li&gt;------三代内存条有1333MHz、1600MHz、2133MHz。&lt;/li&gt;
&lt;li&gt;---DDR4:2133MHz、2400MHz、2666MHz，2933MHz、最高可达3200MHz&lt;/li&gt;
&lt;li&gt;---DDR5:4800MHz、6000MHz、6400MHz、6600MHz、6800MHz、7200MHz、7600MHz、7800MHz、8400MHz。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;读内存条信息&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760535995272.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存条大小为8GB&lt;/li&gt;
&lt;li&gt;1R就是1个rank，x8就是一个颗粒提供8bit，1个rank64bit，64bit除于8bit就是8个颗粒，所以1r x8就是8颗粒的条&lt;/li&gt;
&lt;li&gt;PC4 DDR4&lt;/li&gt;
&lt;li&gt;2666MHz&lt;/li&gt;
&lt;li&gt;CPU数据总线的位宽，一般是64bit，这个位宽就称之为物理Bank。那么内存1RX4则表示1个64bit，X4则表示memory每颗内存颗粒的位数，&lt;br&gt;
从这里我们就可以很容易知道memory内存颗粒的个数为：64/4=16颗。&lt;br&gt;
如果是2rx8的话内存颗粒就是：64x2/8=16颗。&lt;br&gt;
如果是2rx4的话内存颗粒就是：64x2/4=8颗。&lt;br&gt;
如果是1rx8的话内存颗粒就是：64/4x2=8颗。&lt;br&gt;
知道了内存颗粒编码主要数位的含义，拿到一个内存条后就非常容易计算出它的容量。例如一条三星ddr内存，使用16片samsungk4h280838b-tcb0颗粒封装。&lt;br&gt;
颗粒编号第4、5位“28”代表该颗粒是128mbits，第6、7位“08”代表该颗粒是8位数据带宽，这样我们可以计算出该内存条的容量是128mbits(兆数位)×16片/8bits=256mb(兆字节)。&lt;br&gt;
注：“bit”为“数位”，“b”即字节“byte”，一个字节为8位则计算时除以8。关于内存容量的计算，文中所举的例子中有两种情况：一种是非ecc内存，每8片8位数据宽度的颗粒就可以组成一条内存；另一种ecc内存，在每64位数据之后，还增加了8位的ecc校验码。&lt;br&gt;
通过校验码，可以检测出内存数据中的两位错误，纠正一位错误。所以在实际计算容量的过程中，不计算校验位，具有ecc功能的18片颗粒的内存条实际容量按16乘。在购买时也可以据此判定18片或者9片内存颗粒贴片的内存条是ecc内存。&lt;br&gt;
原文链接：https://blog.csdn.net/weixin_33454551/article/details/112923766&lt;/li&gt;
&lt;li&gt;K4A4G085WD&lt;/li&gt;
&lt;li&gt;DDR颗粒&lt;br&gt;
先来讲讲逻辑BANK。芯片的内部，内存的数据是以位(bit)为单位写入一张大的矩阵中，每个单元格我们称为CELL，只要指定一个行(Row)，再指定一个列(Column)，就可以准确地定位到某个CELL，这就是内存芯片寻址的基本原理。这样的一个阵列我们就叫它内存的逻辑BANK(Logical BANK)。&lt;br&gt;
由于工艺上的原因，这个阵列不可能做得太大，所以一般内存颗粒中都是将内存容量分成几个阵列来制造，也就是说在内存颗粒中存在多个逻辑BANK，随着芯片容量的不断增加，逻辑BANK数量也在不断增加，目前从32MB到1GB的芯片基本都是4个,只有早期的16Mbit和32Mbit的芯片采用的还是2个逻辑BANK的设计，譬如三星的两种16MB芯片：K4S161622D （512K x 16Bit x 2 BANK）和K4S160822DT（1M x 8Bit x 2 BANK）。芯片组本身设计时在一个时钟周期内只允许对一个逻辑BANK进行操作，而不是芯片组对内存芯片内所有逻辑BANK同时操作。逻辑BANK的地址线是通用的，只要再有一个逻辑BANK编号加以区别就可以了（BANK0到BANK3）。一个逻辑BANK有8M个单元格（CELL），一些厂商（比如现代/三星）就把每个逻辑BANK的单元格数称为数据深度（Data Depth），每个单元格由8bit组成，那么一个逻辑BANK的总容量就是64Mbit（8M×8bit），4个逻辑BANK就是256Mbit，因此这颗芯片的总容量就是256Mbit（32MB）。&lt;br&gt;
原文链接：https://blog.csdn.net/jiajinkui1988/article/details/101904740&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760536989563.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778586679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4G：容量为4GBit，除以8等于512MB，&lt;br&gt;
08表示x8,8位数据带宽，64/8=8,8颗&lt;br&gt;
16Banks：16个逻辑Banks，每个单元格8bit，8 x bank数:16 x 芯片位宽:8 x bankgroup:4=4Gbit&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ddr1&#34;&gt;DDR1：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HY57V561620&lt;/li&gt;
&lt;li&gt;原理图封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742911439377.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;PCB封装（SOP+BGA)&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742912253572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742913904104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ddr2&#34;&gt;DDR2：&lt;/h1&gt;
&lt;p&gt;-H5PS1G63EFR&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742991202494.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-原理图封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742992601224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-PCB封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742993667401.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;ddr3&#34;&gt;DDR3：&lt;/h1&gt;
&lt;p&gt;-H5TC8G63CMR&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742993934485.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742993989950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-PCB封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742994322193.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;ddr4&#34;&gt;DDR4:&lt;/h1&gt;
&lt;p&gt;-K4A4G165WE-BCRC&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742994780978.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742994820096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-PCB封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742995085719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
################################################################&lt;/p&gt;
&lt;h1 id=&#34;ddr1和ddr2设计要点&#34;&gt;DDR1和DDR2设计要点：&lt;/h1&gt;
&lt;p&gt;1、所有信号连线过孔数为2，线宽一样，走线方向一致，平行走线不得交叉，弯线平滑处理，不得有直角、锐角；3W原则：线距要为线宽的2倍。&lt;br&gt;
2、等长差分线要先布好，例如时钟线。&lt;br&gt;
---地址线：CK、CK#、CK+、CK-&lt;br&gt;
---数据线：DQS&lt;br&gt;
3、以时钟线长度为基准，等长布其它信号线。&lt;br&gt;
忽略电源、地网络。&lt;br&gt;
4、DDR2可以分为三类：&lt;br&gt;
------差分时钟信号：CLK_N;CLK_P&lt;br&gt;
------数据线DQ0-DQ15,数据掩码信号DQM0,DQM1,数据选通信号DQS*_N,DQS*_P&lt;br&gt;
------地址线/控制线：除数据、时钟外的其他信号，如A0A12,WE,CS,BA02,CKE&lt;br&gt;
------Class规则设置：&lt;br&gt;
---------1、DATA_L_BUS：DQ0-DQ7、DQM0（数据掩码）、DQS0_N、DQS0_P（数据锁存）&lt;br&gt;
---------2、DATA_H_BUS：DQ8-DQ15、DQM1(数据掩码)、DQS1_N、DQS1_P（数据锁存）&lt;br&gt;
---------3、ADDR_BUS：除数据线外的其他信号&lt;br&gt;
---------4、CLK_DIFF：CLK_N,CLK_P&lt;br&gt;
------等长设计：&lt;br&gt;
---------1、所有信号线参考差分时钟的长度作等长&lt;br&gt;
---------2、DATA_L_BUS共11根走在同层，与差分时钟的长度误差在25mil&lt;br&gt;
---------3、DATA_H_BUS共11根走在同层，与差分时钟的长度误差在25mil&lt;br&gt;
---------4、ADDR_BUS:与差分时钟的长度误差200-300mil&lt;br&gt;
------其他要求：&lt;br&gt;
---------1、特性阻抗：单端50欧，差分100欧&lt;br&gt;
---------2、保证完整参考平面&lt;br&gt;
---------3、VREF电容要靠近相关的电源管脚，线宽尽量在40mil以上&lt;br&gt;
---------4、信号线不能跨分割&lt;br&gt;
---------5、DDR2走线区域不允许有其他信号穿过&lt;br&gt;
---------6、去耦电容要靠近相关IC的电源管脚&lt;br&gt;
---------7、尽量采用多层板&lt;br&gt;
5、DDR3、DDR4设计要点：&lt;br&gt;
------DDR信号线分组：&lt;br&gt;
将DDR布线的信号进行分组，可以分为时钟线、地址线、命令控制线、数据线四部分。&lt;br&gt;
(1)、时钟线的布线规则：为高速差分信号线，按照差分布线规则进行布线，而且需要在接收端进行阻抗匹配。&lt;br&gt;
(2)、地址线与命令控制线布线规则：地址和命令信号线要进行端接匹配，通过匹配电阻接端接电源VTT。&lt;br&gt;
(3)、数据线布线规则：数据线由于采用了ODT技术，因此不需要外部进行端接匹配。另外需要注意的是：对于时钟线、地址线、命令控制线和数据线，对等长布线要求较高，除了每一组信号线内部要求等长布线以外，还要保持时钟线、地址线和数据线等组间信号线尽量保持等长。尽量保持同组信号线保持在同层，避免跨层布线。对于差分信号线，为了避免信号间的串扰，要使用3W原则进行布线。除此之外，为了使DDR电路具备完整的参考地平面和电源平面，因此在DDR保护区内不得出现与DDR无关的信号且信号走线的参考平面不能中断。DDR的PCB单端走线阻抗一般控制为50欧，差分走线阻抗一般控制为100欧。对于多块DDR芯片的布局布线，根据菊花链的拓扑结构进行布置即可。&lt;br&gt;
------DDR时序同步：&lt;br&gt;
作为源同步系统的DDR电路设计来说，时序控制至关重要，共有三组时序设计要求如下：&lt;br&gt;
(1)、DQ和DQS的等长关系：所有数据线DQ参考DQS的差分线等长，DQS差分线误差控制在5mil，所有数据线误差控制在DQS目标长度的15mil。&lt;br&gt;
(2)、时钟CLK和地址线、命令控制线的等长关系：所有地址和命令控制线参考差分时钟线CLK等长，所有地址和命令控制线误差控制在时钟CLK目标长度的50mil。&lt;br&gt;
(3)、时钟CLK和DQS线的等长关系：对于DDR2来说，时钟CLK和DQS线的时序关系是松散的时序关系，它们之间的时序参数为，一般控制在100mil即可，但是在DDR3中，时钟CLK和DQS线的时序没有严格要求。&lt;br&gt;
------DDR终端匹配：&lt;br&gt;
ODT为内部核心终结引脚，从DDR2开始内存内部集成了终结电阻器，把原来在主板上的终结电路移植到了内存芯片内部。当内存芯片处于写数据状态时，此时内存颗粒是接收端，需要端接匹配电阻，因此需要打开ODT功能；同理当内存芯片处于读数据状态时，此时内存颗粒是发送端，不需要端接电阻，因此需要关闭ODT功能。正是有了ODT功能，DDR内存在PCB布线的时候数据线不需要进行端接匹配处理，因为内存芯片内部集成了端接电阻。&lt;br&gt;
------DDR电源：&lt;br&gt;
DDR一般需要3种电源，分别为：VDDQ、VREF、VTT。其中VTT和VREF的电平是一样的，为VDDQ电平的一半。VREF消耗的电流很小，可以通过分压电阻网络从VDDQ分压得到；而VTT是端接电源，电流会比较大，能达到百毫安级别，如果使用分压电阻功耗消耗过大，因此需要单独的DDR电源调节器芯片来生成VTT。VTT端接电源线的过流能力需要考虑周到，尽量加粗VTT的电源线以增强其载流能力。&lt;br&gt;
------等长的目的就是为了等时，绕等长时需要注意以下几点：&lt;br&gt;
1.确认芯片是否有Pin-delay,绕线时要确保Pin-delay开关已经打开；&lt;br&gt;
2.同组信号走在同层，保证不会因换层影响实际的等时；同样的换层结构，换层前后的等长要匹配，即时等长；不同层的传播延时需要考虑，如走在表层与走在内层，其传播速度是不一样的，所以在走线的时候需要考虑，表层走线尽量短，让其差别尽量小（这也是为什么Intel的很多GUIDE上面要求，表层的走线长度不超过250MIL等要求的原因）；&lt;br&gt;
3.蛇形绕线时单线按3W，差分按5W绕线（W为线宽）。且保证各BUS信号组内间距按3H， 不同组组间间距为5H （H为到主参考平面间距），DQS和CLK 距离其他信号间距做到5H以上。&lt;/p&gt;
&lt;h1 id=&#34;ddr4引脚&#34;&gt;&lt;strong&gt;DDR4引脚&lt;/strong&gt;&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760777012118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;电源：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778328615.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;控制信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778633477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;时钟信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778687584.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;地址信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778722292.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;数据信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778752543.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
参考博客：https://blog.csdn.net/huibei_wuhan/article/details/119945655&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760779115574.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可知K4A4G085WD有16个Banks，分为4个Bank Group，A[0:16]17根地址线，2个BA，2个BG，2个BG可选择四个Bank Group，每个Bank Group又分为4个Bank，2个BA可选择四个Bank，分配了四个地址线BA0\BA1\BG0\BG1，还有17根地址线，选择其中1根表示传输地址是否为行地址。按照参考博客，1个BANK可分为67108854个=64M个地址编号，每个地址空间，使用8个数据线，一次存储8bit数据。&lt;br&gt;
所以1个BANK可以分为65536行，每行1024列，每个存储单元16bit。&lt;br&gt;
每行可以存储1024x8bit=8192B=1KB，每行的存储容量成为Page Size。&lt;br&gt;
单个BANK共65536行，所以每个BANK存储容量为65536x1KB=64MB。&lt;br&gt;
一个BANK GROUP有四个BANK，一个BANK GROUP可存储256MB。&lt;br&gt;
每个DDR4颗粒有4个BANK GROUP，每颗存储容量为1GB。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;layout-guide&#34;&gt;Layout Guide：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;数据线最大长度不要超过2500mil，组内长度误差控制在+-5mil以内，DQS和时钟线无长度误差要求&lt;/li&gt;
&lt;li&gt;地址线误差控制在+-20mil&lt;/li&gt;
&lt;li&gt;DQS、时钟查分对误差控制在+-3mil，设计阻抗时，使本对内间距不超过2倍线宽（4-5mil）&lt;/li&gt;
&lt;li&gt;DQS是数据的同步信号，走线时要和DQ放到一起&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9片DDR4颗粒，每片8位数据带宽，1R为64位，共8片组成一条内存，外加一片ECC，共9片组成一条内存&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760783081608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760783984997.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信号分组：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760784543341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760784926688.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760784990703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
地址信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760785189344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
数据信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760785527511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
电源&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760786061673.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
差分信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760786747637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760787046499.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布局&lt;br&gt;
采用Fly-by的拓扑结构，不可使用T型，拓扑过孔到管脚的长度尽量短，长度在150mil左右&lt;br&gt;
先走出DQS_P和DQS_N差分&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">DDR</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ddr-sodimm/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1761459764033.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761459827708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761459860835.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761744907000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图为18片DDR4，其中2片为实现ECC检查功能，组成260Pin内存条&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电源参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761744951372.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;电源滤波电容值&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745013592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;VPP-GND&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745070901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;VDD-GND&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745111349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;VDD-VREFCA&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745197972.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;ZQ下拉电阻&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745233556.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;VPP-GND&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745299214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;据线DQ阻抗匹配电阻&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745332696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
滤波电容尽量靠近管脚放置，走线应先通过电容再连接到颗粒&lt;/li&gt;
&lt;li&gt;VTT上拉电阻应尽量靠近最后一个DRAM，每一个上拉电阻至少要有一个VDD去耦电容器&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745379151.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;所有信号组采用Fly-by拓扑&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745411558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;信号线分组&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745488886.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;POWER&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745521153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;地址线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745569700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;数据线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745629118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745656294.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745693482.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;差分&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745719787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Physical规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745749215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Space规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745778234.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;创建等长&#34;&gt;创建等长&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;先创建PPr&lt;br&gt;
ECC的数据线CB、DMI、DQ数据信号、DQS差分信号，先创建Xnet，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745851065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745870295.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745890244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745973224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761746016306.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建MGrp，每一组信号由8位数据线、DMI数据掩码、DQS差分走线组成&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761746326401.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761746403285.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所有数据线DQ参考DQS的差分线等长，DQS差分线误差控制在5mil，所有数据线误差控制在DQS目标长度的15mil。&lt;br&gt;
地址线走菊花链，分段设置等长&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913224848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913309783.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913394160.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置260PIN到U4、U4-U2、U2-U3、U3-U5、U5-U18、U18-U6、U6-U8、U8-U9、U9-U7的等长组&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913678863.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
等长组包括：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913726581.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913790486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同理底层9颗DRAM也是一样&lt;br&gt;
ALERT_N要从第一个到最后一个再回到金手指&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913870322.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;DQ走线&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761919357456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DQS差分组内等长误差控制在5mil左右，即0.127mm，DQ数据线误差控制在DQS长度的15mil，即0.381mm&lt;br&gt;
其中Actual+Margin=Delta&lt;br&gt;
把每一组数据线等长组设置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761920371500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761920416769.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761920454061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走出每一组，选择其中最长的作为目标长度&lt;/li&gt;
&lt;li&gt;第一组DDR数据线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761926848952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同组走同层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761926896133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761932515713.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同层等长&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761932566846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;ADDR走线&lt;/strong&gt;&lt;br&gt;
所有地址和命令控制线参考差分时钟线CLK等长，所有地址和命令控制线误差控制在时钟CLK目标长度的50mil&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762008625173.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走完两组数据线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762008679910.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">DDR-SODIMM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-die-ceng-zhi-shi/"" data-c="
          &lt;h1 id=&#34;叠层菜单&#34;&gt;叠层菜单&lt;/h1&gt;
&lt;p&gt;叠层在SETUP-&amp;gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761314771231.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761448363815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761448429383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Layer&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Surface&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Conductor&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般电气层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Dielectric&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;绝缘层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Plane&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;平面层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Thickness&lt;br&gt;
厚度&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449005039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Physical&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449053320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Physical&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Material&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;叠层材质&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Negative Artwork&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;No fillet&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无圆角&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Unused Pin Suppression&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;去掉没有使用的焊盘外盘，无盘孔，做封装焊盘时需勾选&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Unused Via Suppression&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;去掉没有使用的过孔外盘，无盘孔，做封装焊盘时需勾选&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Embedded&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449377031.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
允许元件嵌入板子内层，国内没有做的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Signal Integrity&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449571958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Signal Integrity&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Conductivity&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;层的电导率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Dielectric Constant&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;介电常数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Width&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;层的布线线宽定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Impedance&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置叠层上的走线阻抗，线宽会自动计算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Loss Tangent&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;介电损耗值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Shield&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将当前层改成屏蔽层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Freq. Dep. File&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;频率相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Etch Factor&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;层角度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Diff Coupling Type&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定差分线耦合类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Diff Space&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;差分线线距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Diff Z0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;差分线阻抗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SI Ignore&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;忽略SI，SI分析时不考虑这一层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">Cadence-叠层知识</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-orcad-tian-jia-chi-ye-lian-jie-fu-mei-you-zuo-yong/"" data-c="
          &lt;p&gt;在绘制原理图的时候，想采用Bus总线连接，却发现有些能直接用，今天怎么连都没有连上，查找网络永远只有一个，下班回家发现加了Bus入口依旧一样，苦思终于发现原因在于DQ[63:00]中把DQ00检测为DQ0，而我的Net是DQ00，自然而然采用Bus总线会连不上了😓😓😓&lt;br&gt;
把前缀的0去掉就好了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761138057235.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761138664791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761138694500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不是一个了&lt;/p&gt;
">Cadence-ORCAD添加离页连接符没有作用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/github-la-qu-wen-jian/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760973780230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Github-拉取文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/github-shang-chuan-xiang-mu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新建仓库&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760965761831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定用户&lt;br&gt;
git config --global user.name &amp;quot;mygithubma&amp;quot;&lt;br&gt;
git config --global user.email &amp;quot;1207748726@qq.com&amp;quot;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966177349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加文件到仓库&lt;br&gt;
git add .    添加所有文件&lt;br&gt;
git add DDR4_SODIMM_SPEC.pdf  添加单个文件至仓库&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966315038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加注释&lt;br&gt;
git commit -m &amp;quot;XXX&amp;quot;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966369974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程连接&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966420275.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push&lt;br&gt;
git push origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966894349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966923453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-报错error: remote origin already exists.&lt;br&gt;
删除名为origin的远程仓库&lt;br&gt;
git remote rm origin&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966742155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966818794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除已经add到缓存区的某个文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760967406867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里我之前已经将PDF里面的文件添加到远程仓库了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760967478801.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
git reset XXX  可以将添加到缓存区的文件恢复出来&lt;br&gt;
git reset可以返回已经添加的所有文件，撤销git add .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前分支&lt;br&gt;
git branch&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760969788163.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换分支&lt;br&gt;
git checkout master1&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760969838840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前状态&lt;br&gt;
git status&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760969890873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970335471.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pull时报错fatal: couldn&#39;t find remote ref master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970723173.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
github仓库默认分支为main，git init默认为master&lt;br&gt;
git fetch&lt;br&gt;
git branch -r  查看远程分支&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970824897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
远程分支为main，本地分支为master&lt;br&gt;
git branch -m master main  重新命名本地分支&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970900013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git add .空白文件夹无法添加&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760971314461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git push报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760972742841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
git push origin main --force&lt;br&gt;
大功告成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Github-上传项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-wu-pan-kong-she-ji/"" data-c="
          &lt;p&gt;如果BGA间距非常小，可以采用无盘孔设计&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448656504.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在叠层设置勾选，发现报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448791051.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设勾选&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448960753.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
效果&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448974690.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在第二层没有连线的via会不显示外框&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760449073883.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个间距受规则控制（一般用8mil以上，建议最小大于6.5mil）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760449148441.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-无盘孔设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-guang-hui-she-zhi-bao-cun-xia-ci-zhi-jie-diao-yong/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447749291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加光绘所需要的class后，选中全部&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447806279.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447856805.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下次出文件时，可以直接调用&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447889321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-光绘设置保存，下次直接调用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-kai-cao/"" data-c="
          &lt;p&gt;开槽前必须拦截所有层的铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363844526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363937818.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760364085195.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760364108970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-开槽</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-hui-fu-shan-chu-de-wei-hao/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760362724069.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760362752350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
切换回General Edit模式，更新symbols&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760362818471.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种方法会更新所有该封装的器件&lt;br&gt;
第二种方法&lt;br&gt;
切换回布局模式Placement edit&lt;br&gt;
选中器件右击&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363042593.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363078993.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种方法只会更新选中的器件&lt;/p&gt;
">Cadence-恢复删除的位号</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-6-ceng-fpga-he-xin-ban-chu-gerber/"" data-c="
          &lt;h1 id=&#34;etch层&#34;&gt;ETCH层&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TOP&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760443699077.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
CUTOUT：若有开槽添加&lt;br&gt;
OUTLINE：旧版本Allegro的板框层&lt;br&gt;
DESIGN_OUTLINE：新版本Allegro板框层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BOTTOM&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760443800515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L2_GND&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760443962846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L3_SIG&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444023620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L4_VCC&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444066087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L5_GND&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444138410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;silkscreen&#34;&gt;SILKSCREEN&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444497454.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;soldermask&#34;&gt;SOLDERMASK&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444716915.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;pastemask&#34;&gt;PASTEMASK&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445343137.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;生成钻孔表&#34;&gt;生成钻孔表&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445443941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
钻孔较少时，随便输入一个不重复的符号，给定个大小即可&lt;br&gt;
若有很多钻孔且重复了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445532526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445784789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其他默认&lt;br&gt;
钻孔表&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760446013748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760446147219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加完后在光绘叠层里面添加&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447492010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改未定义的线宽&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448149993.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
绘制光绘文件出的框&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448288186.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448345982.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
确认铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448404868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检查&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452439869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452206833.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
生成钻孔文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452578442.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
出槽孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452652600.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
板子没有槽孔因此没有.rou文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452707840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;出项目生产文件&#34;&gt;出项目生产文件&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新建文件夹&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451335074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加装配class，焊接加工文件&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451393970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导出顶层装配图&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451606901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451636866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
底层装配图需先镜像PCB&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451788382.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451928348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451976002.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还需添加坐标文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453958131.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Ctrl+A全选，复制粘贴到Excel表格里面&lt;br&gt;
可以进行筛选在顶层还是底层（做封装时把原点设置在器件中心）这种方法是器件以每个封装的原点为中心的坐标&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454118643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
另一种方法&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454340468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若封装的原点未在中心，可以选择Body center，缺点这样是txt文本格式，但是板厂会处理&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454481622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;导出DXF&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453191580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453286035.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工艺文件&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453512410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;钢网文件&lt;/strong&gt;&lt;br&gt;
从导出的GERBER里面复制出这两层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453794047.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;导出bom&#34;&gt;导出BOM&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454711619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Header:   Item\tQuantity\tReference\tPart\tPCB Footprint&lt;br&gt;
Combined property string:   {Item}\t{Quantity}\t{Reference}\t{Value}\t{PCB Footprint}&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454950149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760455071825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
整理&lt;/p&gt;
">Cadence-6层FPGA核心板系统性出Gerber、生产文件、BOM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-jing-zhen-bao-di-wa-kong-tong-pi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760361325767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760361525169.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-晶振包地、挖空铜皮</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-bga-feng-zhuang-zheng-mian-bu-jian-yi-pu-tong/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355438491.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
BGA封装正面顶层不建议铺铜，焊接时容易导致受热不均&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355626474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
切换到顶层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355700253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355900746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356095440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
或者采用&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356175934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意:&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356351801.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
采用菜单里面的shape虽然也能挖空铜皮，但是会报出很多DRC错误&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356430613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走线距routekeepout区域报错，相当于把走线也拦截了&lt;br&gt;
这种情况下，选中这个区域，右键属性里面添加&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356601474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错没了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356730787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而用另一种添加的会自动添加允许走线过孔的属性&lt;/p&gt;
">Cadence-BGA封装正面不建议铺铜</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-unassigned-shapes/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760279557844.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Z-COPY多次铺铜铺到同一层，删除重新铺&lt;/p&gt;
">Cadence-unassigned shapes</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-status-bao-cuo-out-of-date-shape/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270113896.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
有个黄色报警&lt;br&gt;
该报警为有一块铜皮没删干净或一块铜皮被另一块铜皮包围&lt;br&gt;
点击黄色小方块，会弹出窗口，点击其中的坐标会自动跳转到报错的地方&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270375466.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
也可以通过这里&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270708757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270486055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改一下铜皮显示效果，更容易看到报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270547850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270908726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开颜色设置，勾选对应层的bound层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760271096776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到这里多出一块没有删除干净的&lt;br&gt;
但是选择shape发现无法选中这一块&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760271589837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过菜单栏选中，Edit一下，放大点铜皮区域。然后就可以选择shape进行删除重新铺铜了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760272252096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-Status报错Out of date  shape</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-tong-pi-nei-suo/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760268861877.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
铺铜皮时通过ROUTE KEEPIN层Z-COPY&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760268958574.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错&lt;br&gt;
将铜皮内缩&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760269025339.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
切换为铜皮编辑模式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760269104252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760269161277.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-铜皮内缩</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-duo-gen-zou-xian-jian-ju-zi-dong-dui-qi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760012918868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
多根走线让其间距自动对齐&lt;br&gt;
复制两个过孔放在两边&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760013007115.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760013046381.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先点击菜单栏，然后点击两个过孔&lt;/p&gt;
">Cadence-多根走线间距自动对齐</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-bga-zou-xian-ju-zhong-chu-xian-bao-hu-dai/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760012614456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
BGA出线在两个焊盘之间，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760012772684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-BGA走线居中出线、保护带</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-yin-cang-mou-ge-wang-luo-de-fei-xian-bu-xian-shi/"" data-c="
          &lt;p&gt;隐藏某个网络的飞线，不管怎样都不显示出来&lt;/p&gt;
&lt;h1 id=&#34;1-分配属性&#34;&gt;1 分配属性&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910850705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分配一个属性给Net&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910918440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
需要显示时删除这个分配的属性&lt;/p&gt;
&lt;h1 id=&#34;2-规则设置&#34;&gt;2 规则设置&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759911042739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Cadence-隐藏某个网络的飞线不显示</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-fei-xian-lian-jie-fang-shi-geng-gai/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910535183.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认最近的飞线连接方式显示为这样&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910600214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
改变该选项&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910664150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-飞线连接方式更改</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-si-yin-wei-zhi-tong-yi-diao-zheng/"" data-c="
          &lt;p&gt;布线完成后统一修改REF位置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759834858837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开PCB文件时勾选&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759834925621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选后才会有此选项&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835007098.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835037881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Limit layers后显示如图&lt;br&gt;
保持此界面不退出&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835126520.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在PCB界面设置如图，选中整个板子&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835171432.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
会发现所有丝印都恢复到器件中心，Dx Dy偏移也可以设置&lt;/p&gt;
">Cadence-丝印位置统一调整</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-guang-hui-ceng-de-she-zhi/"" data-c="
          &lt;h1 id=&#34;1-添加光绘层叠的内容&#34;&gt;1、添加光绘层叠的内容&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;线路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BOARD GEOMETRY/OUTLINE：板框&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/DESIGN_OUTLINE：新版本的板框&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/CUTOUT：板内挖槽孔&lt;/li&gt;
&lt;li&gt;ETCH/TOP：走线&lt;/li&gt;
&lt;li&gt;PIN/TOP：焊盘&lt;/li&gt;
&lt;li&gt;VIA CLASS/TOP：过孔&lt;br&gt;
&lt;em&gt;其他层按TOP设置&lt;/em&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416389969.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416427107.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;丝印&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/OUTLINE：板框&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/SILKSCREEN_TOP：顶层丝印&lt;/li&gt;
&lt;li&gt;PACKAGE GEOMETRY/SILKSCREEN_TOP：顶层丝印&lt;/li&gt;
&lt;li&gt;REF DES/SILKSCREEN_TOP：顶层位号丝印&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416498240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416527932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;阻焊（绿油层）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
">Cadence-光绘层的设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-mang-mai-kong-de-she-zhi-fang-fa/"" data-c="
          &lt;p&gt;对于板子比较密集的情况会用到盲埋孔&lt;br&gt;
盲埋孔只需要做两种孔：激光孔、通孔&lt;br&gt;
盲孔：表层到表层的下一层（不打穿的孔），属于激光钻孔，采用4-10过孔（钻孔4mil，焊盘10mil）&lt;br&gt;
埋孔：8-16过孔（钻孔8mil，焊盘16mil）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759413682894.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759414665041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BBVia Padstack：命名盲埋孔&lt;/li&gt;
&lt;li&gt;Padstack to copy：选择过孔封装&lt;/li&gt;
&lt;li&gt;Start Layer：起始层&lt;/li&gt;
&lt;li&gt;End Layer：结束层&lt;/li&gt;
&lt;li&gt;Add BBvia：新增盲埋孔&lt;br&gt;
在规则设置VIA中添加新增的盲埋孔&lt;br&gt;
BB VIA命名：VIA1_2  VIA5_6  VIA2_5&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759414931141.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走线时Options处须为盲埋孔起始层和结束层，否则会找不到添加的盲埋孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759415017741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759415039771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加的盲埋孔会显示起始层 和结束层，Visibility处Via选择其它层会看不到盲埋孔&lt;/li&gt;
&lt;/ul&gt;
">Cadence-盲埋孔的设置方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-shu-chu-zheng-fan-qi-jian-fen-chi-qing-dan/"" data-c="
          &lt;p&gt;输出正反器件BOM&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759412854586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Tools-&amp;gt;Quick Reports-&amp;gt;Component Reports&lt;br&gt;
点击报告内页，Ctrl+A全选，Ctrl+C复制全部，粘贴到Excel表格中，筛选出SYM_MIRROR为NO是表层的元器件，YES是底层元器件&lt;/p&gt;
">Cadence-输出正反器件分离清单</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-xian-shi-yu-yin-cang-tong-pi/"" data-c="
          &lt;p&gt;铜皮显示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759412579961.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no_etch_shape_display：不显示铜皮&lt;/li&gt;
&lt;li&gt;no_shape_fill：不填充铜皮&lt;/li&gt;
&lt;li&gt;no_shape_fill_dyn_ood：铜皮完全填充&lt;/li&gt;
&lt;li&gt;old_shape_fill_style：旧的铜皮效果&lt;/li&gt;
&lt;/ul&gt;
">Cadence-显示与隐藏铜皮</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-she-zhi-dan-du-guan-jiao-de-tong-pi-lian-jie-fang-shi/"" data-c="
          &lt;p&gt;铺铜时设置某个管脚与铜皮的连接方式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410696326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Edit-&amp;gt;Properties-&amp;gt;Find面板选择Pins&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410778577.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410809653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759411778832.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759411857582.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
改为对角线连接和8路连接&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759411930890.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Orthogonal：十字连接&lt;/li&gt;
&lt;li&gt;Diagonal：对角线连接&lt;/li&gt;
&lt;li&gt;Full_contact：全连接&lt;/li&gt;
&lt;li&gt;8_way：8路连接&lt;/li&gt;
&lt;li&gt;None：无&lt;/li&gt;
&lt;/ul&gt;
">Cadence-设置单独管脚的铜皮连接方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-xi-tong-fei-mo-ren-subclass-tian-jia-yu-shan-chu/"" data-c="
          &lt;h1 id=&#34;添加子层&#34;&gt;&lt;strong&gt;添加子层&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410275421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410329001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入DXFF，点击ok&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410380922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到在Board Geometry下多出Dxff层&lt;/p&gt;
&lt;h1 id=&#34;删除子层&#34;&gt;&lt;strong&gt;删除子层&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;删除子层时要先删除子层上的所有，否则会报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410499883.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
删除后在Options下看不到Dxff层了&lt;/p&gt;
">Cadence-系统非默认Subclass添加与删除</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-jian-bian-xian-tian-jia/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759408520259.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在箭头处添加渐变&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759408570130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759408903125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选箭头处，否则会报错，如果报错，检查是否勾选&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759409061553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Add Tapered trace后点击要添加的Cline处&lt;br&gt;
删除渐变线如上菜单中选择Delete&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759409884741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选Run后会整板添加&lt;/p&gt;
">Cadence-渐变线添加</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zi-dong-dao-chu-yan-se-she-zhi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759407188586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759407231990.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
.prm文件为颜色设置文件，在新的pcb文件中导入Parameters文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Design Setting：设计参数&lt;/li&gt;
&lt;li&gt;Artwork：光绘叠层&lt;/li&gt;
&lt;li&gt;Color Layer：层的颜色&lt;/li&gt;
&lt;li&gt;Color Palette：调色板的颜色&lt;/li&gt;
&lt;li&gt;Color Net：网络颜色&lt;/li&gt;
&lt;li&gt;Text Size：文本大小&lt;/li&gt;
&lt;li&gt;Application or Command Parameters：应用程序或命令参数&lt;/li&gt;
&lt;/ul&gt;
">Cadence-自动导出颜色设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zi-dong-bao-cun/"" data-c="
          &lt;p&gt;&lt;strong&gt;1、Allegro自动保存&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759407046333.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-自动保存</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zou-xian-kuan-du-ji-yi-gong-neng/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759058674065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
allegro走线时改变options中的line width后会保留下次走线时的宽度，不想保留，按照规则设置的宽度走线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759058788032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759058837555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选acon_no_width_override_retain&lt;br&gt;
后续走线会按照规则默认设置的宽度&lt;/p&gt;
">Cadence-走线宽度记忆功能</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-bga-feng-zhuang-guo-kong-shan-chu/"" data-c="
          &lt;p&gt;Route-&amp;gt;create fanout&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758552719453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择top-&amp;gt;bottom&lt;br&gt;
选择过孔类型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758552825736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择扇出方向&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758552982501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Find选中Pin给单个焊盘扇出，选中器件给整个器件进行扇出&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553043159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若是要删除扇出的过孔和走线，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553284680.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
会发现无法删除&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553319486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553349437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
已删除的Pin会高亮，点击之后就可以进行删除&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553405757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-BGA封装过孔扇出</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-qu-yu-gui-ze/"" data-c="
          &lt;p&gt;在BGA封装器件下走线，间距采用区域规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758200897903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758200929579.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758200974593.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择区域规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758201041229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置间距&lt;/p&gt;
">Cadence-区域规则</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-jing-tai-tong-pi-bi-rang-guo-kong/"" data-c="
          &lt;p&gt;在铺静态铜皮后，添加过孔会报短路的错误&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941123163.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941248564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
铜皮避让&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941309728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941348192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941400313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941425022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若显示异常&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941496567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941527290.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-静态铜皮避让过孔</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-she-xing-zou-xian/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751671155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751707430.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751779673.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751822371.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757752401954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
规则设置打开等长和差分显示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757753327585.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757753389768.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757753434269.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757754494110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757754659842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Total Etch Length: 这个net 上面已经绕线的长度。&lt;/li&gt;
&lt;li&gt;Total Path Length: 这个net 上面已经绕线的长度加上尚未完成部分的Manhattan&lt;br&gt;
长度。&lt;/li&gt;
&lt;li&gt;Total Manhattan Length:走直角绕线的长度 (水平绕线加上垂直绕线长度)&lt;/li&gt;
&lt;/ul&gt;
">Cadence-蛇形走线</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-she-zhi-zou-xian-de-gui-ze/"" data-c="
          &lt;h1 id=&#34;创建差分对&#34;&gt;创建差分对&lt;/h1&gt;
&lt;p&gt;在规则管理中，Electrical-&amp;gt;Net-&amp;gt;Differential Pair中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343686996.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343703237.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343719869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343738712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建class&#34;&gt;创建Class&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343765933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343783387.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建ngrp&#34;&gt;创建NGrp&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343818226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343827608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343923690.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343932650.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建xnet&#34;&gt;创建Xnet&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343971671.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击OK-&amp;gt;YES&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757344165055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建C642两端的Net为XNet&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757344266187.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757344194193.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757342874349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在Ref中填写C642，按一下Tab键，选中器件，点击Create Model&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343071109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击ok&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343115125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击ok&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343373951.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343408927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建等长&#34;&gt;创建等长&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757678848146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757679752320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757679861035.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建PPr&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757680569671.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757680829170.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-设置走线规则</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-li-mian-fang-zhi-yuan-li-tu-li-mian-mei-you-de-feng-zhuang/"" data-c="
          &lt;p&gt;1、在菜单Setup-&amp;gt;User Preference&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757258592837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使能这个&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261199288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261228880.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择合适的symbols，打钩&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261251605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261336669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-PCB里面放置原理图里面没有的封装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-geng-xin-yi-fang-zhi-qi-jian-de-pcb-feng-zhuang/"" data-c="
          &lt;p&gt;如图，将箭头所指的pcb封装替换为另一种，选中封装查看为C0805，将其更新为另一种小的C0805封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756990991840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在Setup-&amp;gt;User Preference中PATH下，将新封装所在路径调到前面&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756991168048.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756991217500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意，已锁定的器件需勾选额外的&lt;br&gt;
点击Refresh&lt;/p&gt;
">Cadence-更新已放置器件的PCB封装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-fu-yong-mo-kuai/"" data-c="
          &lt;p&gt;首先布局好其中一个模块，将另一个模块的所有器件都集中到一起，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561259343.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
框选布局好的器件，右击&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561318810.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
右键Done，然后再单击一下，弹出界面‘&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561451312.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择未布局的器件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561512042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561619923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Unmatched的需要手动对应，取消选择Device name，依次选择器件在右侧对应好，单击OK&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756564455160.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756564540144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加了复用模块属性的器件无法自由移动，若要移动&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261784309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，该器件无法移动，首先切换至placement edit模式，在super filter下选择Module&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261848027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261917848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
框选要移动的器件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757262216592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757262369332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样即可移动&lt;/p&gt;
">Cadence-复用模块</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zhi-zuo-flash-symbol/"" data-c="
          &lt;p&gt;打开PCB Editor，File-&amp;gt;New&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756385402942.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ADD-&amp;gt;Flash&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756385959644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置内径、外径、连接宽度&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386167393.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386251688.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
制作焊盘&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386795657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386852192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-制作Flash symbol</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zhi-zuo-bu-gui-ze-han-pan/"" data-c="
          &lt;p&gt;打开PCB Editor，选择File-&amp;gt;New&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756382395564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756382474062.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
依次输入坐标&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756382895061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
继续新建一个symbol，外扩5mil用于制作Soldermask层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756383839924.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开PAD STACK&lt;br&gt;
File-&amp;gt;New&lt;br&gt;
BEGIN LAYER设置如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756384149352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MASK LAYER设置如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756384267076.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Save&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756384492304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-制作不规则焊盘</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-orcad-xin-jian-titleblock/"" data-c="
          &lt;p&gt;在olb库下新建symbol&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756305249842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设计自己的TitleBlock&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756305612341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756306161361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以在这里点击添加属性&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756306235551.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
place选择Title Block，Add Library，放置即可&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756306273590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-Orcad新建TitleBlock</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-feng-zhuang-dao-step-mo-xing/"" data-c="
          &lt;h1 id=&#34;1-添加默认黑盒子模型&#34;&gt;1、添加默认黑盒子模型&lt;/h1&gt;
&lt;p&gt;Cadence在制作封装时可以添加3D模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125171167.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在使用Allegro制作pcb封装时会添加PLACE_BOUND_TOP来生成默认的模型，该模型可以通过设置来改变其高度&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125266958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125314567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
观察一下此时的模型效果图&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125405444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若添加了PLACE_BOUND_TOP但是没有显示，可能是没打开&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125478635.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125534923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里其他几项也可以根据理解知道是什么意思&lt;/p&gt;
&lt;p&gt;2、添加真实STEP模型&lt;br&gt;
推荐一个可以下载模型的网站：&lt;br&gt;
https://componentsearchengine.com/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125842991.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不仅可以下载STEP模型，还可以下载Cadence、AD等软件的pcb封装等等&lt;br&gt;
找到step后缀的文件，可以使用SW打开看看&lt;br&gt;
首先要在软件中设置steppath&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126039379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126101293.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在这里设置好step所在路径&lt;br&gt;
在setup下选择&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126156888.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击path可查看当前设置的step路径，发现和前面设置的为同一个路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126245039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为封装选择对应的step模型，右侧窗口可预览&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;view ：观察视角，有十种观察视角可以进行选择&lt;/li&gt;
&lt;li&gt;Transparent ：可选择None、Symbol、STEP、Both，显示设置&lt;/li&gt;
&lt;li&gt;Overlay，选中表示默认黑盒子和导入的step封装同时显示，取消选中预览窗口会分成两部分分别显示&lt;/li&gt;
&lt;li&gt;Hide board ：隐藏板子&lt;/li&gt;
&lt;li&gt;STEP color ：选中表示STEP颜色设置为黑色&lt;/li&gt;
&lt;li&gt;Primary/Secondary STEP Model ：两种STEP模型，即同一个PCB封装可以分配两种模型，使用时可以进行选择来分别显示&lt;/li&gt;
&lt;li&gt;Map STEP Model ：模型坐标及旋转角度&lt;/li&gt;
&lt;li&gt;Arrow key increment ：前后左右调整&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置好后点击save&lt;br&gt;
点击3D预览，若发现依旧是默认的黑盒子模型，别急，只是显示效果还没调整，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126964838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在上图中选择only the step model，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756127029595.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样即为pcb封装添加了3D模型&lt;/p&gt;
">Cadence-PCB封装导STEP模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-dao-ru-zi-ding-yi-tu-pian-si-yin-logo/"" data-c="
          &lt;p&gt;工具介绍：RATA Raster (BMP) To Allegro (IPF)&lt;br&gt;
可将位图BMP转换为IPF格式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756040568974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击左下角Select BMP file导入黑白图片&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756041563158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Pick color选择阴阳模式，选择白色图中黑色线条不加丝印，白色部分加丝印，选择黑色，黑色部分为丝印&lt;br&gt;
点击Make out plt输出，在bmp文件同名文件夹下，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756041722400.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756041802631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种显示方式为那个工具选择黑色，选择白色即为反色&lt;br&gt;
Scale为大小&lt;br&gt;
https://gitee.com/ma-zhenchun/allegro-logo-tool&lt;/p&gt;
">Cadence-导入自定义图片丝印logo</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-dao-chu-gerber/"" data-c="
          &lt;h1 id=&#34;1-检查drc&#34;&gt;1、检查DRC&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020172972.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Display，选择Status，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020237511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检查相关DRC错误，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020299227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可通过Tools工具下的Quick Reports找到DRC报错位置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020388258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-更改gerber导出路径&#34;&gt;2、更改Gerber导出路径&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020699404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在菜单栏Setup-&amp;gt;User Preferences下找到File_management目录，设定ads_sdart为gerber，在导出gerber的时候会自动在pcb文件目录下创建名为gerber的文件夹&lt;/p&gt;
&lt;h1 id=&#34;3-生成钻孔表&#34;&gt;3、生成钻孔表&lt;/h1&gt;
&lt;p&gt;给不同尺寸的孔分配不同的符号symbols&lt;br&gt;
选择Manufacture-&amp;gt;NC-&amp;gt;Drill Customization&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033592436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033875301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择Manufacture-&amp;gt;NC-&amp;gt;Drill Legend&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020498262.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756021109940.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认设置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756021361994.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
钻孔表位于Manufacturing下的Nclegend-1-2层&lt;/p&gt;
&lt;h1 id=&#34;4-光绘文件的输出&#34;&gt;4、光绘文件的输出&lt;/h1&gt;
&lt;p&gt;菜单选择Manufacture-&amp;gt;Artwork&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756021501976.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;Film Control选项&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756022788018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Film name ：目前底片的名称&lt;/li&gt;
&lt;li&gt;Rotation ：旋转角度，一般默认0&lt;/li&gt;
&lt;li&gt;Offset ：底片的偏移量，一般默认为0&lt;/li&gt;
&lt;li&gt;Undefined line width：未定义宽度的走线，常规设置为6mil&lt;/li&gt;
&lt;li&gt;Shape bounding box ：默认为100，表示当“Plot mode”为“Negative”时，由Shape的边缘处往外需要画100mil的黑色区域&lt;/li&gt;
&lt;li&gt;Plot mode ：表示采用正片还是负片&lt;/li&gt;
&lt;li&gt;Film mirrored ：底片是否镜像&lt;/li&gt;
&lt;li&gt;Full contact thermal-reliefs ： 当底片设置为负片时，相同网络的铜皮和pin、via之间进行全连接，而不是花连接&lt;/li&gt;
&lt;li&gt;Supress unconnected pads ： 若勾选，表示无盘化设计。假设一个多层板，一通孔在其中某两层未连接任何走线铜皮，那么可以在这两层将焊盘去掉&lt;/li&gt;
&lt;li&gt;Draw missing pad apertures ： 若勾选，表示当一个pad没有相应的&amp;quot;Flash D-Code&amp;quot;时，系统采用较小宽度的Line D-Code填充此pad&lt;/li&gt;
&lt;li&gt;Use aperture rotation ：Gerber数据能使用镜头列表中的镜头来旋转定义的信息&lt;/li&gt;
&lt;li&gt;Supress shape fill ：选择此项表示shape的外形不画出，使用者必须自行加入分割线作为shape的外形，，只有为负片时此项才可以进行设置&lt;/li&gt;
&lt;li&gt;Vector based pad behavior ：默认选择勾选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;General Parameters&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756022829230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Device type ： 底片生成格式&lt;/li&gt;
&lt;li&gt;Coordinate type ：选择 Gerber 6x00 或 Gerber 4x00 时才可以设置&lt;/li&gt;
&lt;li&gt;Absolute ：表示采用绝对坐标&lt;/li&gt;
&lt;li&gt;Incremental ：相对坐标&lt;/li&gt;
&lt;li&gt;Output units ：输出文件单位&lt;/li&gt;
&lt;li&gt;Error action ：输出过程中发生错误的处理方法，默认&lt;/li&gt;
&lt;li&gt;Abort film ：表示终止生成当前底片，继续生成下一张底片&lt;/li&gt;
&lt;li&gt;Abort all ：终止生成所有底片&lt;/li&gt;
&lt;li&gt;Format ：表示输出坐标的精度&lt;/li&gt;
&lt;li&gt;Integer places ：整数部分&lt;/li&gt;
&lt;li&gt;Decimal places ：小数部分&lt;/li&gt;
&lt;li&gt;Output options ：输出选项，选择 Gerber 6x00 或 Gerber 4x00 时才可以设置&lt;/li&gt;
&lt;li&gt;Optimize data ：表示资料需要最佳化的输出&lt;/li&gt;
&lt;li&gt;Use &#39;G&#39; codes ：指定Gerber数据的G码，Gerber使用G码来描述预定处理，Gerber4x00需要G码，Gerber6x00不需要G码&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;添加目录&#34;&gt;添加目录&lt;/h1&gt;
&lt;p&gt;选中TOP或者BOTTOM鼠标右击选择Add&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756027926515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Add的subclass会包含所有的层，我们可以复制已有的TOP或者BOTTOM然后双击重命名&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756028969462.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加如下subclass：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029357036.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加subclass后，在下拉箭头里面随机选中一个class然后右击add&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029718340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029786114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打钩即可&lt;br&gt;
为每一个subclass下添加对应的class&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029840680.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029872992.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030068240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030344072.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030382114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030432398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加完subclass和class后，单击每一个film，如图设置：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030615906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030732192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
铜皮的连接方式要与上图的设置一致&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030899530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
返回Film Control界面，点击select all，然后点击Create Artwork，在.brd的文件下会生成gerber文件夹，点击进去就可以看到.art的文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031036340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;生成钻孔文件&#34;&gt;生成钻孔文件&lt;/h1&gt;
&lt;p&gt;菜单-&amp;gt;Manufacture-&amp;gt;NC-&amp;gt;Nc Parameters&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031518402.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选最后一项&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031600561.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在gerber文件夹下多出nc_param.txt，该文件下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031773512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
菜单-&amp;gt;Manufacture-&amp;gt;NC-&amp;gt;Nc Drill&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756032807127.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756032865329.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击drill&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756032943394.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Drill生成的只是规则的圆形钻孔文件&lt;br&gt;
菜单-&amp;gt;Manufacture-&amp;gt;NC-&amp;gt;Nc Route&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033019199.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033040594.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击route&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033141943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注：PASTE_TOP和PASTE_BOTTOM为制作钢网的文件，无需发给制版厂&lt;/p&gt;
&lt;h1 id=&#34;报错photoplot-outline-rectangle-not-found&#34;&gt;报错Photoplot outline rectangle not found&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759850965216.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导出gerber文件弹出报错&lt;br&gt;
新版本软件需要绘制一个区域&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759851024000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759851108812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-导出Gerber</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-dao-ru-wang-biao/"" data-c="
          &lt;p&gt;1、Setup-&amp;gt;User Preference&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755529663380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置padpath、psmpath&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dra:可编辑的pcb封装文件&lt;/li&gt;
&lt;li&gt;psm:被调用的pcb封装文件，不可编辑&lt;/li&gt;
&lt;li&gt;pad：焊盘文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、导入网表&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755529820661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755529897419.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、点击import&lt;/p&gt;
">Cadence-PCB导入网表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-dao-ru-dxf/"" data-c="
          &lt;p&gt;File-&amp;gt;import-&amp;gt;dxf&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755526731449.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755526740013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上设置后导入&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755526925462.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样导入的图形只是在自己新建的DXFclass下，并不能当做真正的板框，选中外侧框，将其改变层到OUTLINE中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755527303951.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
底层丝印忘记导了，重新导出底层丝印&lt;/p&gt;
">Cadence-PCB导入DXF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-dao-chu-dxf/"" data-c="
          &lt;p&gt;1、查看需要导出的线条属性&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525400539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525432649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525458616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525485506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2、导出DXF&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525526916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525622436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525710267.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、查看DXF&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525924005.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到板框和元器件丝印框成功导出，其它层同理也可以进行选择性导出。&lt;/p&gt;
">Cadence-PCB导出DXF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-yuan-li-tu-drc-bao-cuo-tong-yi-ge-feng-zhuang-xia-cun-zai-duo-ge-xiang-tong-ming-cheng-de-gndvcc-guan-jiao-dao-zhi/"" data-c="
          &lt;p&gt;制作原理图封装时，GND/VCC电源管脚类型设置为Power&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525140112.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意：Cadence在设置管脚为电源Power类型后，会在全局网络Net下创建该名称的一个Net，因此，若NC管脚不进行电气连接，不能设置为Power来避免同一个原理图封装存在多个名称相同的管脚错误，否则会创建出一个名称为NC的Net，正确做法是创建NCX，设置为Passive属性的管脚。&lt;/p&gt;
">Cadence-原理图DRC报错同一个封装下存在多个相同名称的GND、VCC管脚导致</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-dao-chu-wang-biao-netlist-bao-cuo-zhao-bu-dao-footprint/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1755524744618.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
没有设置pcb封装路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755524807354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开orcad默认该路径下存在一个Capture.ini的文件，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755524903876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图所示添加路径。&lt;/p&gt;
">Cadence-导出网表Netlist报错找不到footprint</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/3d-mo-xing/"" data-c="
          &lt;p&gt;https://www.3dcontentcentral.com.cn/&lt;br&gt;
https://grabcad.com/library&lt;br&gt;
https://componentsearchengine.com/&lt;br&gt;
https://www.snapeda.com/home/&lt;br&gt;
https://componentsearchengine.com/&lt;br&gt;
https://www.ultralibrarian.com/&lt;br&gt;
https://www.datasheet5.com/&lt;/p&gt;
">3D模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/esd/"" data-c="
          &lt;p&gt;PACDN006MR&lt;/p&gt;
">ESD</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dian-ping/"" data-c="
          &lt;p&gt;LVPECL&lt;/p&gt;
">电平</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/linux-ming-ling-xing/"" data-c="
          &lt;ul&gt;
&lt;li&gt;lsblk 列出磁盘列表&lt;/li&gt;
&lt;li&gt;blkid 列出设备的UUID&lt;/li&gt;
&lt;li&gt;parted /dev/mmcblk0 print 列出dev/mmcblk0磁盘的相关信息&lt;/li&gt;
&lt;li&gt;磁盘分区：MBR格式-fdisk  GPT格式-gdisk&lt;/li&gt;
&lt;li&gt;partprobe 分区后更新Linux内核的分区表信息&lt;/li&gt;
&lt;li&gt;mkfs.xfs 格式化磁盘，创建xfs文件系统&lt;/li&gt;
&lt;li&gt;mkfs.ext4 格式化磁盘，创建ext4文件系统&lt;/li&gt;
&lt;li&gt;xfs_repair /dev/vda4  检验/修复文件系统&lt;/li&gt;
&lt;li&gt;fsck.ext4 处理ext4文件系统&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
">Linux命令行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/pcie-dai-kuan-su-lu/"" data-c="
          &lt;h1 id=&#34;pcie&#34;&gt;PCIE:&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;PCIE接口速率&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1754307801157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PCIe是PCI Express的缩写，已经发展和定义了六代，每一代常用Gen来表示。两个PCIe装置之间的连接称为连结（Link）, 每个连结可以有多条通道（Lane），常见的通道数量为x1，x4，x8以及x16, 若某个PCIe连结为Gen2x4，则表示第二代、&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;PCIE版本&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;行代码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;传输速率&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x8&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8b/10b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2.5GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;250MB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8b/10b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;500MB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128b/130b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;984.6MB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.938GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7.877GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15.754GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128b/130b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.969GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7.877GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15.754GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;31.508GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128b/130b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32/25GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.9 or 3.08GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15.8 or 12.3GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;31.5 or 24.6GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;63 or 49.2GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;传输速率GT/s&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传输速率为每秒传输量GT/s，而不是每秒位数Gbps。传输量包括额外的位，传输8b的数据需要占用10b的位数。&lt;br&gt;
GT/s：每秒传输的次数。&lt;br&gt;
Gbps：每秒传输的位数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带宽&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1754309505971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">PCIE带宽、速率</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/git-shang-chuan-bao-cuo-fatal-unable-to-access-httpsgithubcommygithubmagridea_imagesgit-failed-to-connect-to-githubcom-port-443-after-21093-ms-could-not-connect-to-server/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753795029009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由于网络连接问题或代理设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global --unset http.proxy 
git config --global --unset https.proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753795886628.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;git config  --global http.proxy 127.0.0.1:7897
git config  --global https.proxy 127.0.0.1:7897
&lt;/code&gt;&lt;/pre&gt;
">Git上传报错fatal: unable to access 'https://github.com/mygithubma/gridea_images.git/': Failed to connect to github.com port 443 after 21093 ms: Could not connect to server</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-chuan-kou/"" data-c="
          &lt;h1 id=&#34;通信方式&#34;&gt;通信方式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;并行通信&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;串行通信&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异步串行通信&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753709982892.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;同步串行通信&lt;br&gt;
&lt;strong&gt;串行通信制式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;单工&lt;/li&gt;
&lt;li&gt;半双工&lt;/li&gt;
&lt;li&gt;全双工&lt;br&gt;
&lt;strong&gt;串行通信的错误校验&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;奇偶校验：在发送数据时，数据位尾随的1位为奇偶校验位。奇校验时，数据中的1的个数和校验位1的个数之和应为奇数；偶校验时，数据中的1的个数和校验位1的个数之和应为偶数。&lt;/li&gt;
&lt;li&gt;代码和校验&lt;/li&gt;
&lt;li&gt;循环冗余校验&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;rs232-ttl&#34;&gt;RS232-TTL&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753709505964.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;波特率&lt;/strong&gt;&lt;br&gt;
每秒传输二进制代码的位数，1波特=1位/秒，单位为bps。&lt;br&gt;
如每秒传输240个字符，每个字符有10位，波特率为2400bps。&lt;br&gt;
&lt;strong&gt;波特率计算：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;波特率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fosc/12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(2^SMOD/32)*(T1溢出率)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(2^SMOD/64)*fosc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(2^SMOD/32)*(T1溢出率)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;#电源管理寄存器PCON&lt;br&gt;
字节地址为87H，不能位寻址。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMOD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMOD0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;LVDF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;P0F&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GF1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GF0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IDL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;SMOD：串行口波特率&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SMOD=0：串行口方式1,2,3，波特率正常。&lt;/li&gt;
&lt;li&gt;SMOD=1：串行口方式1,2,3，波特率加倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;T1溢出率：T1定时器溢出的频率&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752904618128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752904651883.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;串行口结构&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753717191436.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;串行口控制寄存器scon&#34;&gt;串行口控制寄存器SCON&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SM0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SM1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SM2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;REN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TB8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RB8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TI&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RI&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;SM0 、SM1：工作方式选择位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行口有四种工作方式，由SM0 、SM1设定&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;SM0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;SM1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方式说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;同步移位寄存器方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10位异步收发器（8位数据），波特率可变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11位异步收发器（9位数据），波特率固定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11位异步收发器（9位数据），波特率可变&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;SM2：多机通信控制位&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;REN：允许串行接收位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REN=1：允许串行口接收数据。&lt;/li&gt;
&lt;li&gt;REN=0：禁止串行口接收数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TB8：方式2,3中发送数据的第9位。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;RB8：方式2,3中接收数据的第9位。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;TI：发送中断标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在方式0时，当串行发送第8位数据结束时，或在串行发送停止位的开始时，由内部硬件置1，向CPU发送中断申请。在中断服务程序中，必须用软件将其清0，取消此中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RI：接收中断标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在方式0时，当串行接收第8位数据结束时，或在串行接收停止位的中间时，由内部硬件置1，向CPU发送中断申请。在中断服务程序中，必须用软件将其清0，取消此中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;串口设置&#34;&gt;串口设置：&lt;/h1&gt;
&lt;p&gt;1、确定定时器T1的工作方式（编程TMOD寄存器）&lt;br&gt;
2、计算T1的初值，装载TH1,TL1&lt;br&gt;
3、启动T1（编程TCON中的TR1位）&lt;br&gt;
4、确定串行口工作方式（编程SCON寄存器）&lt;br&gt;
5、串行口工作在中断方式下时，要进行中断设置（编程IE,IP寄存器）&lt;br&gt;
&lt;strong&gt;设置虚拟仿真串口如下：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797404278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797456590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开虚拟串口软件Configure Virtual Serial Port Driver：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797503656.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加COM1、COM2，打开XCOM软件：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797597451.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
运行仿真：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797633810.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;

#define uchar unsigned char
#define uint unsigned int
uchar flag,a,i;
uchar code table[]=&amp;quot;I get &amp;quot;;

void init()
{
	TMOD=0x20;  //0010 0000 定时器T1工作方式2:8位初值自动重装的定时器/计数器
	TH1=0xfd;  //253,波特率为9600，SMOD置0
	TL1=0xfd;  //与TH1一样
	TR1=1;  //启动定时器
	REN=1;  //串行口控制寄存器SCON，允许串行接收位
	SM0=0;
	SM1=1;  //串行口工作方式为1
	EA=1;  //串行口工作在中断方式，编程中断允许IE寄存器，允许全局中断
	ES=1;  //打开串行口中断
}

void main()
{
	init();
	while(1)
	{
		if(flag==1)
		{
			ES=0;
			for(i=0;i&amp;lt;6;i++)
			{
				SBUF=table[i];
				while(!TI);
				TI=0;
			}
			SBUF=a;
			while(!TI);
			TI=0;
			ES=1;
			flag=0;
		}
	}
}

void ser() interrupt 4
{
	RI=0;
	a=SBUF;
	flag=1;
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-串口</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-led/"" data-c="
          &lt;h1 id=&#34;移位操作&#34;&gt;移位操作&lt;/h1&gt;
&lt;p&gt;&amp;lt;&amp;lt;：左移指令。被操作数的最高位移入单片机PSW寄存器的CY位，CY位中的数丢弃，最低位补0。&lt;br&gt;
&amp;gt;&amp;gt;：右移指令。被操作数的最低位移入单片机PSW寄存器的CY位，CY位中的数丢弃，最高位补0。&lt;br&gt;
循环左移：最高位移入最低位。_crol_实现。&lt;br&gt;
循环右移：最低位移入最高位。_cror_函数实现。&lt;/p&gt;
&lt;h1 id=&#34;psw寄存器&#34;&gt;PSW寄存器&lt;/h1&gt;
&lt;p&gt;程序状态字标志寄存器。8位寄存器，字节地址D0H。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sfr PSW         =   0xD0;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CY&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AC&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;F0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RS1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RS0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;OV&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;P&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;CY：进位标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示运算是否有进位，如果操作结果在最高位有进位或者借位，则该位为1，否则为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AC：辅助进位标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半进位标志，指两个8位数运算低四位是否有半进位，即低四位相加或相减是否进位，如有AC为1，否则为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;F0：用户使用的状态标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可用软件来置1或清0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RS1、RS0:4组工作寄存器区选择控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在汇编语言中，这两位用来选择4组工作寄存器区中的哪一组为当前工作寄存区。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;OV：溢出标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反映带符号数的运算结果是否有溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P：奇偶标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反映累加器ACC内容的奇偶性，如果ACC中的运算结果有偶数个1，则P为0，否则为1。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;流水灯程序&#34;&gt;流水灯程序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;    //包含头文件
#include &amp;lt;intrins.h&amp;gt;  //包含_crol_函数所在的文件
#define uint unsigned int   //宏定义
#define uchar unsigned char
	
//sbit led1=P2^0;    单个led延时
//void delayms(uint xms)
//{
//	uint i,j;
//	for(i=xms;i&amp;gt;0;i--)
//	{
//		for(j=110;j&amp;gt;0;j--);
//	}
//}

//void main()
//{
//	while(1)
//	{
//		led1=0;
//		delayms(2000);
//		led1=1;
//		delayms(2000);
//	}
//}

void delayms(uint);
uchar aa;

void main()
{
	aa=0xfe;   //赋初值1111 1110
	while(1)
	{
		P2=aa;   //点亮一个led
		delayms(500);
		aa=_crol_(aa,1);   //循环左移
	}
}

void delayms(uint xms)
{
	uint i,j;
	for(i=xms;i&amp;gt;0;i--)   //延时xms
	{
		for(j=110;j&amp;gt;0;j--);
	}
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-Led</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-ru-men-1/"" data-c="
          &lt;h1 id=&#34;数码管显示原理&#34;&gt;数码管显示原理&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1752758348337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选用共阳极数码管，IO输出0表示亮，输出1表示不亮。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752758451827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
推导出共阳极显示0-9的十六进制如下：&lt;/p&gt;
&lt;h1 id=&#34;数字显示-共阳&#34;&gt;数字显示-共阳&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#include &amp;lt;intrins.h&amp;gt;
#define uint unsigned int
#define uchar unsigned char
	
sbit dula=P2^6;  //定义段选信号
sbit wela=P2^7;  //定义位选信号

void main()
{
	wela=1;  //位选为高电平，选择某个数码管
	P0=0x01;  //P0=0000 0001,打开第一个数码管
	wela=0;  //关闭位选锁存器
	
//显示0
//	dula=1;  //段选锁存器打开
//	P0=0x40;  //P0=0100 0000，0表示亮
//	dula=0;  //段选锁存器关闭；
	
//显示1
//	dula=1;  //段选锁存器打开
//	P0=0xf9;  //P0=1111 1001，
//	dula=0;  //段选锁存器关闭；
	
//显示2
//	dula=1;  //段选锁存器打开
//	P0=0x24;  //P0=0010 0100，
//	dula=0;  //段选锁存器关闭；
	
//显示3
//	dula=1;  //段选锁存器打开
//	P0=0x30;  //P0=0011 0000，
//	dula=0;  //段选锁存器关闭；
	
//显示4
//	dula=1;  //段选锁存器打开
//	P0=0x19;  //P0=0001 1001，
//	dula=0;  //段选锁存器关闭；
	
//显示5
//	dula=1;  //段选锁存器打开
//	P0=0x12;  //P0=0001 0011，
//	dula=0;  //段选锁存器关闭；
	
//显示6
//	dula=1;  //段选锁存器打开
//	P0=0x02;  //P0=0000 0010，
//	dula=0;  //段选锁存器关闭；
	
//	//显示7
//	dula=1;  //段选锁存器打开
//	P0=0xf8;  //P0=1111 1000，
//	dula=0;  //段选锁存器关闭；
	
//	//显示8
//	dula=1;  //段选锁存器打开
//	P0=0x00;  //P0=0000 0000，
//	dula=0;  //段选锁存器关闭；
	
//	//显示9
	 dula=1;  //段选锁存器打开
	 P0=0x10;  //P0=0001 0000，
 	dula=0;  //段选锁存器关闭；
	 while(1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应共阴极的数码管&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned char code table[]={
     0x3f,0x06，0x5b,0x4f,
     0x66,0x6d,0x7d,0x07,
     0x7f,0x6f,0x77,0x7c,
     0x39,0x5e,0x79,0x71,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注：code关键字表示编码，在单片机c语言中，定义数组是占用内存空间的，定义编码是直接分配到程序空间中，编译后编码占用的是程序存储空间而非内存空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;数字显示-延时从1-f显示-共阴&#34;&gt;数字显示 延时从1-f显示 共阴&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#include &amp;lt;intrins.h&amp;gt;
#define uint unsigned int
#define uchar unsigned char
	
sbit dula=P2^6;  //定义段选信号
sbit wela=P2^7;  //定义位选信号

unsigned char code tableK[]={
	  0x3f,0x06,0x5b,0x4f,
      0x66,0x6d,0x7d,0x07,
      0x7f,0x6f,0x77,0x7c,
      0x39,0x5e,0x79,0x71,
};

uint num;
void delayms(uint);

void main()
{
 	wela=1;  //位选为低电平，选择某个数码管
  	P0=0xfe;  //P0=1111 1110,打开第一个数码管，延时从1-f显示
	wela=0;  //关闭位选锁存器
	
//	dula=1;
//	P0=tableK[1];
//	dula=0;
 	while(1)
 	{
	 	for(num=0;num&amp;lt;16;num++)
	 	{
	 		dula=1;
		 	P0=tableK[num];
			dula=0;
			delayms(500);
		}
	};
}

void delayms(uint xms)
{
	uint i,j;
	for(i=xms;i&amp;gt;0;i--)
 	{
 		for(j=110;j&amp;gt;0;j--);
 	}
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-数码管；</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-zhong-duan/"" data-c="
          &lt;h1 id=&#34;52单片机&#34;&gt;52单片机&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;52单片机共有6个中断源：&lt;br&gt;
&lt;strong&gt;INT0-外部中断0，P3.2端口，低电平或者下降沿引起。&lt;br&gt;
INT1-外部中断1，P3.3端口，低电平或者下降沿引起。&lt;br&gt;
T0-定时器0/计数器0中断，T0计数器计满回零引起。&lt;br&gt;
T1-定时器1/计数器1中断，T1计数器计满回零引起。&lt;br&gt;
T2-定时器2/计数器2中断，T2计数器计满回零引起。&lt;br&gt;
TI/RI-串行口中断，串行端口完成一帧字符发送/接收引起。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753624895792.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;中断允许寄存器ie&#34;&gt;中断允许寄存器IE&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;中断允许寄存器IE用于设定各个中断源的打开和关闭，IE在特殊功能寄存器中，字节地址为A8H，位地址分别为A8H-AFH，可进行位寻址，即可以对寄存器的每一位进行单独操作。单片机复位时IE全部被清0。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ET2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ES&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ET1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EX1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ET0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EX0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AFH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ADH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ACH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ABH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AAH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;A9H&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;A8H&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;EA:全局中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EA=1：打开全局中断控制。&lt;/li&gt;
&lt;li&gt;EA=0：关闭全部中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ET2：定时器/计数器2中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ET2=1：打开T2中断。&lt;/li&gt;
&lt;li&gt;ET2=0：关闭T2中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ES：串行口中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES=1：打开串行口中断。&lt;/li&gt;
&lt;li&gt;ES=0：关闭串行口中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ET1：定时器/计数器1中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ET1=1：打开T1中断。&lt;/li&gt;
&lt;li&gt;ET1=0：关闭T1中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EX1：外部中断1中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EX1=1：打开外部中断1中断。&lt;/li&gt;
&lt;li&gt;EX1=0：关闭外部中断1中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ET0：定时器/计数器0中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ET1=1：打开T0中断。&lt;/li&gt;
&lt;li&gt;ET1=0：关闭T0中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EX0：外部中断0中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EX0=1：打开外部中断0中断。&lt;/li&gt;
&lt;li&gt;EX0=0：关闭外部中断0中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;中断优先级寄存器ip&#34;&gt;中断优先级寄存器IP&lt;/h1&gt;
&lt;p&gt;中断优先级寄存器IP在特殊功能寄存器中，字节地址为B8H，位地址为B8H-BFH，IP用来设定各个中断源属于两级中断中的哪一级，该寄存器可以进行位寻址。单片机复位时IP全部被清0.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PT1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PT0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PX0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BCH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BBH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BAH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B9H&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B8H&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;PS：串行口中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PS=1：串行口中断定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PS=0：串行口中断定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PT1：定时器/计数器1中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PT1=1：定时器/计数器1中断定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PT1=0：定时器/计数器1中断定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PX1：外部中断1中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PX1=1：外部中断1定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PX1=0：外部中断1定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PT0：定时器/计数器0中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PT0=1：定时器/计数器0中断定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PT0=0：定时器/计数器0中断定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PX0：外部中断1中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PX0=1：外部中断0定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PX0=0：外部中断0定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;定时器计数器工作方式寄存器tmod&#34;&gt;定时器/计数器工作方式寄存器TMOD&lt;/h1&gt;
&lt;p&gt;字节地址为89H，不能位寻址，单片机复位时全被清0。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GATE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C/T&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GATE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C/T&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TMOD的高四位用于设定定时器1，低四位用于设定定时器0。&lt;br&gt;
&lt;strong&gt;GATE：门控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GATE=0：定时器/计数器启动与停止仅受TCON寄存器中TRX来控制&lt;/li&gt;
&lt;li&gt;GATE=1：定时器/计数器启动与停止仅受TCON寄存器中TRX和外部中断INTX上的电平状态控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;C/T：定时器/计数器模式选择位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C/T=1：计数器模式。&lt;/li&gt;
&lt;li&gt;C/T=0：定时器模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;M1M0：工作方式选择&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;M1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;M0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;-----&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式0:13位定时器/计数器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式1:16位定时器/计数器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式2:8位初值自动重装的定时器/计数器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式3:仅用于T0，分成两个8位计数器，T1停止计数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;定时器计数器控制寄存器tcon&#34;&gt;定时器/计数器控制寄存器TCON&lt;/h1&gt;
&lt;p&gt;字节地址为88H，位地址为88H-8FH，可进行位寻址，单片机复位全部清0。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TF1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TR1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TF0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TR0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IE1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IT1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IE0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IT0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8FH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8EH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8DH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8CH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8BH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8AH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;89H&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;88H&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;TF1：定时器1溢出标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TF=1：定时器计数溢出后，由硬件使TF1置1，并且申请中断，进入中断服务程序后，由硬件自动清0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TR1：定时器1运行控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由软件清0关闭定时器1，当GATE=1时，且INT1为高电平时，TR1置1启动定时器1；当GATE=0时，TR1置1，启动定时器1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;IE1：外部中断1请求标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;置1表示外部中断1向CPU申请中断。&lt;br&gt;
&lt;strong&gt;IT1：外部中断1触发方式选择位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IT1=0：电平触发模式。&lt;/li&gt;
&lt;li&gt;IT1=1：跳变沿触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#定时器0-工作方式1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑结构图：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753708175871.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753709084503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;定时器初始化过程：&lt;br&gt;
1、对TMOD赋值：（定时器/计数器工作方式寄存器)&lt;br&gt;
2、计算初值，给THX TLX赋值&lt;br&gt;
3、对中断允许寄存器IE进行赋值，开放中断&lt;br&gt;
4、使定时器/计数器控制寄存器TCON中的TRX置位，启动定时器/计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#define uchar unsigned char
#define uint unsigned int

sbit led1=P1^0;

uchar num;

void main()
{
	TMOD=0x01;      //定时器0，工作方式1,0000 0001
	TH0=(65536-45872)/256;	//定时50ms=50000us,50000/1.09=45872
	TL0=(65536-45872)%256;
	EA=1;  //中断允许寄存器打开全局中断允许位
	ET0=1;  //中断允许寄存器打开T0中断允许位
	TR0=1;  //定时器/计数器控制寄存器TCON启动定时器T0
	while(1)		//程序停止在这里等待中断发生
	{
		if(num==20)
		{
			num=0;
			led1=~led1;
		}
	}
}

void T0_time() interrupt 1
{
	TH0=(65536-45872)/256;	//定时50ms=50000us,50000/1.09=45872
	TL0=(65536-45872)%256;
	num++;
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-中断</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-ji-chu-zhi-shi-stc89c52/"" data-c="
          &lt;h1 id=&#34;-引脚分类&#34;&gt;- &lt;em&gt;引脚分类&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;1、电源和时钟引脚：Vcc、GND、XTAL1、XTAL2。&lt;br&gt;
2、编程控制引脚：RST、PSEN、ALE/PROG、EA/Vpp。&lt;br&gt;
3、IO口：P0、P1、P2、P3,。共四组8位IO口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电源-Vcc（40脚）、GND(20脚)。&lt;/li&gt;
&lt;li&gt;外接时钟-XTAL1(19脚)、XTAL2（18脚）。&lt;br&gt;
XTAL1为片内震荡电路的输入端，XTAL2为片内震荡电路的输出端。&lt;/li&gt;
&lt;li&gt;8051的时钟有两种方式：&lt;br&gt;
片内时钟震荡：在XTAL引脚外接石英晶体和震荡电容，电容取值10p-30pf。&lt;br&gt;
外部时钟方式：XTAL1接地，XTAL2接入外部时钟信号。&lt;/li&gt;
&lt;li&gt;RST(9脚）&lt;br&gt;
单片机复位脚，输入连续两个机器周期以上的高电平时有效。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753506486252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;PSEN（29脚）&lt;br&gt;
程序存储器允许输出控制端，在读外部程序存储器时PSEN低电平有效。&lt;/li&gt;
&lt;li&gt;ALE/PROG（30脚）&lt;br&gt;
单片机扩展外部RAM时，ALE用于控制把P0口的输出低8位地址送锁存器锁存起来，实现低位地址和数据的隔离。&lt;/li&gt;
&lt;li&gt;EA/Vpp（31脚）&lt;br&gt;
EA接高电平时，单片机读取内部程序存储器。当扩展有外部ROM时，先读取内部ROM后自动读取外部ROM。&lt;/li&gt;
&lt;li&gt;IO口&lt;br&gt;
P0口（39-32脚）：双向8位三态IO口，每个口可独立控制，P0口没有上拉电阻，为高阻状态，不能正常的输出高低电平，使用时接10k上拉电阻。&lt;br&gt;
P1口（1-8脚）：准双向8位IO口，可独立控制，内带上拉电阻，输出没有锁存状态，输入也不能锁存。不是真正的双向IO口，该口在使用前，要先进行写1操作。&lt;br&gt;
P2口（21-28脚）：准双向8位IO口，可独立控制，内带上拉电阻。&lt;br&gt;
P3口（10-17脚）：准双向8位IO口，可独立控制，内带上拉电阻。有第二功能。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753507122703.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;电平特性&#34;&gt;电平特性&lt;/h1&gt;
&lt;p&gt;常用电平：TTL、CMOS、RS232、RS422、RS485.&lt;br&gt;
TTL：+5V为高电平，0V为低电平。&lt;br&gt;
RS232：+12V为低电平，-12V为高电平。&lt;/p&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753617708021.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单片机中存储的最小单位：位（bit） 0/1&lt;br&gt;
1字节（Byte）=8位（bit）  1B=8b&lt;/p&gt;
&lt;h1 id=&#34;reg51h&#34;&gt;&amp;lt;reg51.h&amp;gt;&lt;/h1&gt;
&lt;p&gt;sfr：特殊功能寄存器的数据声明，声明一个8位的寄存器。&lt;br&gt;
sfr16：16位特殊功能寄存器的数据声明。&lt;br&gt;
sbit：特殊功能位声明，声明一个特殊功能寄存器的某一位。&lt;br&gt;
bit：位变量声明。&lt;/p&gt;
">单片机-基础知识（STC89C52）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-ds18b20/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753017960198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">单片机-DS18B20</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-iic/"" data-c="
          &lt;p&gt;&lt;strong&gt;IIC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inter IC Bus&lt;/li&gt;
&lt;li&gt;由数据线SDA和时钟线SCL构成，采用漏记开路结构和总线连接，因此SCL和SDA均需接上拉电阻，总线在空闲状态为高电平，任一器件输出低电平都可拉低总线。&lt;/li&gt;
&lt;li&gt;IIC在数据传输时，时钟信号为高电平期间，数据线上的数据必须保持稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送启动信号，在SCL高电平期间，SDA出现下降沿。&lt;/li&gt;
&lt;li&gt;发送寻址信号，7位地址寻址时，高7位为地址位，最低位为方向位，0表示主机对从机进行写操作，1表示主机对从机进行读操作。主机发送地址时，总线上的从机都根据7位地址码与自己的地址进行比较，相同即认为自己正被主机寻址，根据R/W确定自己为发送器或者接收器。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:R/W:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;应答信号，应答信号由接收设备产生，在SCL信号为高电平期间，接收设备将SDA拉为低电平，表示数据传输正确，产生应答。&lt;/li&gt;
&lt;li&gt;停止信号，在SCL为高电平期间，SDA出现上升沿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延时&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void delay()  //延时4-5us
{;;}
void delay1ms(uint z)
{
	uint x,y;
	for(x=z;x&amp;gt;0;x--)
	{
		for(y=110;y&amp;gt;0;y--);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//总线初始化
void init()  //总线在初始状态下保持高电平
{
	SCL=1;
	delay();
	SDA=1;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动信号&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//启动信号
void start() //SCL在高电平期间，SDA出现下降沿
{
	SDA=1;
	delay();
	SCL=1;
	delay();
	SDA=0;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;应答信号&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//应答信号
void respon()  //SCL为高电平期间，SDA被从设备拉低
{
	uchar i=0;
	SCL=1;
	delay();
	while((SDA==1)&amp;amp;&amp;amp;(i&amp;lt;255))
	{
		i++;
	}
	SCL=0;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;停止信号&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//停止信号
void stop()  //SCL在高电平期间，SDA出现上升沿信号
{
	SDA=0;
	delay();
	SCL=1;
	delay();
	SDA=1;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;写一个字节&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//写一个字节
void write_byte(uchar date)
{
	uchar i,temp;
	temp=date;
	for(i=0;i&amp;lt;8;i++)
	{
		temp=temp&amp;lt;&amp;lt;1;   //temp左移一位，最高位移入寄存器PSW的CY位，赋值给SDA
		SCL=0;  //IIC在进行数据传送时，SCL为高电平期间，SDA需保持稳定，因此拉低SCL
		delay();
		SDA=CY;
		delay();
		SCL=1;
		delay();
	}
	SCL=0;   
	delay();
	SDA=1;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;读一个字节&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//读一个字节
uchar read_byte()
{
	uchar i,k;
	SCL=0;
	delay();
	SDA=1;
	for(i=0;i&amp;lt;8;i++)
	{
		SCL=1;
		delay();
		k=(k&amp;lt;&amp;lt;1)|SDA;
		SCL=0;
		delay();
	}
	delay();
	return k;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;EEPROM-AT24C02&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752914063901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WP:写保护输入端，用于硬件数据保护，当其为低电平时，可以对整个存储器进行正常的读写操作，当其为高电平时，存储器具有写保护功能，读操作不受影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//例程：
#include &amp;lt;reg52.h&amp;gt;

#define uchar unsigned char
#define uint unsigned int
bit write=0;  //写24C02的标志
sbit SDA=P2^0;
sbit SCL=P2^1;
sbit dula=P2^6;
sbit wela=P2^7;
uchar sec,tcnt;

unsigned char code table[]={
	 0x3f,0x06,0x5b,0x4f,
     0x66,0x6d,0x7d,0x07,
   0x7f,0x6f,0x77,0x7c,
     0x39,0x5e,0x79,0x71,
};

void delay()  //延时4-5us
{;;}
	
void delay1ms(uint z)
{
	uint x,y;
	for(x=z;x&amp;gt;0;x--)
	{
		for(y=110;y&amp;gt;0;y--);
	}
}

//总线初始化
void init()  //总线在初始状态下保持高电平
{
	SCL=1;
	delay();
	SDA=1;
	delay();
}

//启动信号
void start() //SCL在高电平期间，SDA出现下降沿
{
	SDA=1;
	delay();
	SCL=1;
	delay();
	SDA=0;
	delay();
}

//应答信号
void respon()  //SCL为高电平期间，SDA被从设备拉低
{
	uchar i=0;
	SCL=1;
	delay();
	while((SDA==1)&amp;amp;&amp;amp;(i&amp;lt;255))
	{
		i++;
	}
	SCL=0;
	delay();
}

//停止信号
void stop()  //SCL在高电平期间，SDA出现上升沿信号
{
	SDA=0;
	delay();
	SCL=1;
	delay();
	SDA=1;
	delay();
}

//写一个字节
void write_byte(uchar date)
{
	uchar i,temp;
	temp=date;
	for(i=0;i&amp;lt;8;i++)
	{
		temp=temp&amp;lt;&amp;lt;1;   //temp左移一位，最高位移入寄存器PSW的CY位，赋值给SDA
		SCL=0;  //IIC在进行数据传送时，SCL为高电平期间，SDA需保持稳定，因此拉低SCL
		delay();
		SDA=CY;
		delay();
		SCL=1;
		delay();
	}
	SCL=0;   
	delay();
	SDA=1;
	delay();
}

//读一个字节
uchar read_byte()
{
	uchar i,k;
	SCL=0;
	delay();
	SDA=1;
	for(i=0;i&amp;lt;8;i++)
	{
		SCL=1;
		delay();
		k=(k&amp;lt;&amp;lt;1)|SDA;
		SCL=0;
		delay();
	}
	delay();
	return k;
}

void write_add(uchar address,uchar date)
{
	start();
	write_byte(0xa0);  //1010 0000  AT24C02的芯片地址1010 A2 A1 A0 R/W 
	respon();
	write_byte(address);  //器件内部地址
	respon();
	write_byte(date);  //数据
	respon();
	stop();
}

uchar read_add(uchar address)
{
	uchar date;
	start();
	write_byte(0xa0);
	respon();
	write_byte(address);
	respon();
	start();
	write_byte(0xa1);
	respon();
	date=read_byte();
	stop();
	return date;
}
	
void display(uchar bai_c,uchar sh_c)  //显示程序
{
	wela=0;
	dula=0;  //关闭段选锁存器
	wela=1;  //选中位选锁存器
  P0=0x7e;  //0111 1110 第一位数码管使能
	wela=0;  //关闭位选锁存
	P0=0xff;
	
	dula=1;  //打开段选锁存器
	P0=table[bai_c];  //显示第一位数据
	dula=0;  //关闭段选锁存器
	delay1ms(5);
	
	wela=1;  //选中位选锁存器
	P0=0x7d;  //0111 1101 第二位数码管使能
	wela=0;  //关闭位选锁存
	P0=0xff;
	
	dula=1;  //打开段选锁存器
	P0=table[sh_c]; //显示第二位数据
	dula=0;  //关闭段选锁存器
	delay1ms(5);
}

void main()
{
	init();  //初始化，拉高IIC总线
	sec=read_add(2);   //读出保存的数据赋值给sec
	if(sec&amp;gt;100)  //防止读出数据为3位造成两位数码管显示乱码
	{
		sec=0;
	}
	TMOD=0x01;  //0000 0001 定时器T0，工作方式1:16为定时器/计数器
	ET0=1;  //中断允许寄存器IE 定时器/计数器0中断允许位
	EA=1;  //中断允许寄存器IE 全局中断打开
	TH0=(65536-45872)/256;
	TL0=(65536-45872)%256;  //50ms中断一次
	TR0=1;  //定时器控制寄存器TCON 启动定时器1
	while(1)
	{
		display(sec/10,sec%10);
		if(write==1)  //判断计时器是否计时1s
		{
			write=0;  //清0
			write_add(2,sec);  //在24C02的地址2写入数据sec
		}
	}
}

void t0() interrupt 1
{
	TH0=(65536-45872)/256;
	TL0=(65536-45872)%256;
	tcnt++;  //0.05sx20=1s
	if(tcnt==20)  //1s写一次24C02
	{
		tcnt=0;  //清0
		sec++;  //每隔1s，sec加1，定时1s
		write=1;  //写24C02
		if(sec==100)  //到100s后归零
		{ 
			sec=0;
		}
	}
	
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-IIC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-adda/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753802270097.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752903439273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#include &amp;lt;intrins.h&amp;gt;
#define uchar unsigned char
#define uint unsigned int
	
sbit dula=P2^6;   //定义锁存器的锁存端
sbit wela=P2^7;   //定义锁存器的锁存端
sbit adwr=P3^6;   //定义AD转换器的WR端口
sbit adrd=P3^7;   //定义AD转换器的RD端口

//共阴数码管
unsigned char code table[]={
     0x3f,0x06,0x5b,0x4f,
     0x66,0x6d,0x7d,0x07,
     0x7f,0x6f,0x77,0x7c,
     0x39,0x5e,0x79,0x71,
};

void delayms(uint xms)  //延时函数
{
	 uint i,j;
	 for(i=xms;i&amp;gt;0;i--)
	 {
	 	for(j=110;j&amp;gt;0;j--);
	 }
}

void display(uchar bai,uchar shi,uchar ge)  //显示函数
{
	wela=1;
	P0=0x7d;  //0111 1101 显示第2位和选中AD转换器
	wela=0;
	P0=0xff;  //送位选数据时关闭所有显示；防止打开位选锁存；
	dula=1;  //数码管显示
	P0=table[bai];
	dula=0;
	delayms(5);
	
	wela=1;
	P0=0x7b;   //0111 1011 显示第3位数码管并选中AD转换器
	wela=0;
	P0=0xff;
	dula=1;
	P0=table[shi];
	dula=0;
	delayms(5);
	
	wela=1;
	P0=0x77;   //0111 0111 显示第4位数码管并选中AD转换器
	wela=0;
	P0=0xff;
	dula=1;
	P0=table[ge];
	dula=0;
	delayms(5);
	
}

void main()
{
	
	uchar a,A1,A2,A3,adval;
	A1=1;
	A2=2;
	A3=3;
	wela=1;
	P0=0x7f;  //0111 1111 选通CSAD
	wela=0;
	while(1)
	{
		adwr=1;
		_nop_();
		adwr=0;  //启动AD转换；
		_nop_();  //延时一个机器周期
		adwr=1;
		for(a=10;a&amp;gt;0;a--)
		{
			display(A1,A2,A3);
		}
		P1=0xff;  //1111 1111 读取P1之前先全给1
		adrd=1;  //选通ADCS
		_nop_();
		adrd=0;  //AD读使能；
		_nop_();
		adval=P1;  //AD数据读取赋值给P1
		A1=adval/100;
		A2=adval%100/10;
		A3=adval%10;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753887219105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;DAC0832引脚：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753887903411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CS：片选信号输入端，低电平有效。&lt;/li&gt;
&lt;li&gt;WR1：输入寄存器的写选通输入端，负脉冲有效。当CS为0，ILE为1，WR1有效时，DI0-DI7状态被锁存到输入寄存器。&lt;/li&gt;
&lt;li&gt;DI0-DI7：数据输入端，TTL电平。&lt;/li&gt;
&lt;li&gt;Vref：基准电压输入端，电压范围为-10V-+10V。&lt;/li&gt;
&lt;li&gt;Rfb：反馈电阻端，芯片内部此端与IOUT1接有一个15K的电阻。&lt;/li&gt;
&lt;li&gt;IOUT1：电流输出端，当输入全为1，电流最大。&lt;/li&gt;
&lt;li&gt;IOUT2：电流输出端，其值与IOUT1电流之和为一常数。&lt;/li&gt;
&lt;li&gt;XFER：数据传输控制信号输入端，低电平有效。&lt;/li&gt;
&lt;li&gt;WR2：DAC寄存器的写选通输入端，负脉冲有效。当XFER为0且WR2有效时，输入寄存器的状态被传到DAC寄存器中。&lt;/li&gt;
&lt;li&gt;ILE：数据锁存允许信号输入端，高电平有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DAC0832工作方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双缓冲&lt;/li&gt;
&lt;li&gt;单缓冲&lt;/li&gt;
&lt;li&gt;直通：片选、写信号、传送控制都接地。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;

#define uchar unsigned char
#define uint unsigned int
	
sbit dula=P2^6;  //段选
sbit wela=P2^7;  //位选
sbit dawr=P3^6;  //DA的WR端口
sbit dacs=P3^2;  //DA的CS端口
sbit beep=P2^3;  //蜂鸣器端口

void delayms(uint xms)  //延时xms
{
	uint i,j;
	for(i=xms;i&amp;gt;0;i--)
	{
		for(j=110;j&amp;gt;0;j--);
	}
}

void main()
{
	uchar val,flag;
	dula=0;  //关闭段选
	wela=0;  //关闭位选
	dacs=0;  //片选信号，选中DAC
	dawr=0;  //输入寄存器的写信号选通端
	P0=0;
	while(1)
	{
		if(flag==0)
		{
			val+=5;
			P0=val;
			if(val==255)
			{
				flag=1;
				beep=1;
				delayms(100);
				beep=0;
			}
			delayms(50);
		}
		else
		{
			val-=5;
			P0=val;
			if(val==0)
			{
				flag=0;
				beep=1;
				delayms(100);
				beep=0;
			}
			delayms(50);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-ADDA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-ui-she-ji/"" data-c="
          &lt;ul&gt;
&lt;li&gt;PyQt5：&lt;br&gt;
总界面：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749191239648.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
QLabel：主题：基于Yolov5+Deepsort的单目标跟踪器设计&lt;br&gt;
QLabel：显示：label_video，作为识别显示区域&lt;br&gt;
QTextBrowser：模拟终端：显示识别数据&lt;br&gt;
QHBoxLayout：布局：COM、Start、Close、Stop四个按键水平布局&lt;br&gt;
Spacer：水平分割符&lt;br&gt;
QPushButton：按键&lt;br&gt;
QRadioButton：Stop可选择按键&lt;br&gt;
Line：边框线&lt;/li&gt;
&lt;li&gt;优化&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749191562232.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中mainWindow，在属性栏中的windowTitle中更改显示界面左上角名称；windowIcon可选择图片文件更改显示框左上角标识。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749191701398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中label_theme，右击鼠标，选择改变样式表，添加颜色中选择添加background-color可改变背景颜色，选择添加字体可改变字体。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192006897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中QLabel，在右侧属性栏里找到alignment，选择AlignHCenter水平居中，AlignVCenter垂直居中。&lt;br&gt;
其他窗口通过调整大小放置在合适的位置。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192181192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中PushButton，在属性栏中找到cursor，可修改选中按钮后鼠标箭头的显示状态，同理，将Start、Close按键的显示状态均改为指向手势。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192304483.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Edit，选中编辑信号部件，选择Close按键，拖动出来。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192390185.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中下面显示从QWidget继承的信号和槽。左边选择clicked（），右边选择close（）&lt;br&gt;
右边最下面的信号、槽编辑器会显示一个pushButton_close（）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192554344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编辑完后可按键F3退出信号槽编辑状态。&lt;br&gt;
点击左上角窗体预览可进行预览界面。&lt;br&gt;
保存.ui文件，回到pycharm，选中.ui文件，右击鼠标，选择外部工具，点击PYUIC，会在本地目录生成与.ui同名的.py文件。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192708868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新建run_ui.py文件，导入.ui同名的.py文件，下图为显示程序。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192792397.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
运行run_ui.py文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192901932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在.py文件中class Ui_mainWindow类下，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193163996.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可用connect（）进行按键功能的写定。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193236349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，将def open_com（）函数写在class Ui_mainWindow类下，即可设定按键按下的功能。&lt;br&gt;
&lt;code&gt;self.textBrowser_terminal.append(&#39;OPEN COM: &#39;)&lt;/code&gt;可换行并且刷新到最新显示&lt;br&gt;
在模拟终端添加数据输出，textBrowser添加输出的程序有多种：&lt;br&gt;
&lt;code&gt;self.textBrowser_terminal.setText(&#39;OPEN COM: &#39;)&lt;/code&gt;添加文字但不换行不刷新&lt;br&gt;
&lt;code&gt;self.textBrowser_terminal.insertPlainText(&#39;OPEN COM: &#39;)&lt;/code&gt;插入文字不换行&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193703149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;if not self.radioButton.isChecked():&lt;/code&gt;如果radioButton没有选中，执行下述程序，若选中则停止。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193790104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
执行label_video显示程序，并且可调整显示大小至适合label_video框大小。&lt;br&gt;
最终效果图：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749194229147.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计UI设计：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/deepsort-xiong-ya-li-suan-fa/"" data-c="
          &lt;p&gt;参考博客：https://blog.csdn.net/lemonxiaoxiao/article/details/108672039&lt;br&gt;
https://www.cnblogs.com/pprp/articles/12736831.html&lt;/p&gt;
">DeepSort-匈牙利算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/deepsort-qia-er-man-lu-bo/"" data-c="
          &lt;p&gt;&lt;code&gt;import numpy as np&lt;/code&gt;&lt;br&gt;
导入numpy库，并命名为np。Numpy是Python的核心计算库，提供多维数组对象ndarray，数学函数，随机数生成等。&lt;br&gt;
如：a=np.array([1,2,3])   b=np.sum(a)&lt;br&gt;
&lt;code&gt;import scipy.linalg&lt;/code&gt;&lt;br&gt;
导入Scipy库的linalg（线性代数）子模块。该模块包含线性代数运算，如矩阵求逆，求解方程组等。&lt;br&gt;
&lt;code&gt;chi2inv95 = {                 1: 3.8415,                 2: 5.9915,                 3: 7.8147,                 4: 9.4877,                 5: 11.070,                 6: 12.592,                 7: 14.067,                 8: 15.507,                 9: 16.919}&lt;/code&gt;&lt;br&gt;
定义一个名为chi2inv95的字典，存储了卡方分布的95%置信度临界值，用于统计学中的假设检验或不确定性分析。&lt;br&gt;
&lt;code&gt;class KalmanFilter(object):&lt;/code&gt;&lt;br&gt;
卡尔曼滤波器&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749109790837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ndim状态维度为4，dt为时间步长，每次预测时长为1s。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110057596.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
motion_mat为状态转移矩阵&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110220938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
update_mat为更新矩阵，从8维状态向量中提取4维观测值&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110356441.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;std_weight_position = 1. / 20&lt;/code&gt;&lt;br&gt;
&lt;code&gt;std_weight_velocity = 1. / 160&lt;/code&gt;&lt;br&gt;
不确定性权重，位置标准差权重和速度标准差权重&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110571382.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
初始化新轨迹，将检测到的目标（未关联到现有轨迹的测量值）转换为卡尔曼滤波的初始状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：检测框的测量值measurement，为[x,y,a,h]形式，中心坐标x/yx，宽高比a，高度h。&lt;/li&gt;
&lt;li&gt;输出：mean：8维状态向量，如上图所示；covariance：8X8协方差矩阵，表示状态的不确定性。&lt;br&gt;
&lt;code&gt;mean_pos=measurement&lt;/code&gt;， [x,y,a,h]，4X1的矩阵&lt;br&gt;
&lt;code&gt;mean_vel = np.zeros_like(mean_pos)&lt;/code&gt;， [0,0,0,0]，4X1的零向量&lt;br&gt;
&lt;code&gt;mean = np.r_[mean_pos, mean_vel]&lt;/code&gt;， [x,y,a,h,0,0,0,0]&lt;br&gt;
std：初始化标准差&lt;br&gt;
&lt;code&gt;std = [&lt;/code&gt;&lt;br&gt;
&lt;code&gt; 2 * self._std_weight_position * measurement[3],&lt;/code&gt;       x=2*(1/20)*h&lt;br&gt;
&lt;code&gt;2 * self._std_weight_position * measurement[3],&lt;/code&gt;       y&lt;br&gt;
&lt;code&gt; 1e-2,&lt;/code&gt;        a&lt;br&gt;
&lt;code&gt; 2 * self._std_weight_position * measurement[3],&lt;/code&gt;      h&lt;br&gt;
&lt;code&gt;  10 * self._std_weight_velocity * measurement[3],&lt;/code&gt;    vx&lt;br&gt;
&lt;code&gt; 10 * self._std_weight_velocity * measurement[3],&lt;/code&gt;     vy&lt;br&gt;
&lt;code&gt;1e-5,&lt;/code&gt;        va&lt;br&gt;
&lt;code&gt;10 * self._std_weight_velocity * measurement[3]]&lt;/code&gt;      vh&lt;br&gt;
&lt;code&gt;covariance = np.diag(np.square(std))&lt;/code&gt; 协方差矩阵初始化为对角矩阵&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749111869918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
预测步骤：根据目标的当前状态和运动模型，预测其在下一时刻的状态均值和协方差。&lt;/li&gt;
&lt;li&gt;输入：mean：8维状态向量；covariance：8X8协方差矩阵。&lt;/li&gt;
&lt;li&gt;输出：预测后的mean和covariance。&lt;br&gt;
std_pos、std_vel位置噪声和速度噪声，宽高比固定值。&lt;br&gt;
&lt;code&gt;motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))&lt;/code&gt;&lt;br&gt;
过程噪声协方差：将位置和速度噪声拼接为8维向量，平方后转为对角矩阵。&lt;br&gt;
&lt;code&gt;mean = np.dot(self._motion_mat, mean)&lt;/code&gt;&lt;br&gt;
计算两个数组的点积。&lt;br&gt;
&lt;code&gt;covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov&lt;/code&gt;&lt;br&gt;
更新协方差矩阵。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749121834548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
观测空间投影：用于将状态空间的均值和协方差映射到测量空间，同时添加观测噪声。&lt;/li&gt;
&lt;li&gt;输入：mean：8维状态均值向量；covariance：8X8状态协方差矩阵。&lt;/li&gt;
&lt;li&gt;输出：投影后的4维测量均值[x,y,a,h]和4X4测量协方差矩阵。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749122179128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
更新步骤，根据实际测量值修正预测状态。&lt;/li&gt;
&lt;li&gt;输入：mean：预测的8维状态均值；covariance：预测的8X8状态协方差矩阵；measurement：4维测量值[x,y,a,h]。&lt;/li&gt;
&lt;li&gt;输出：new_mean：新的状态均值；new_covariance：新的协方差矩阵。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749122751445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Gating Distance：用于在目标跟踪中衡量预测轨迹与检测框之间的匹配程度。&lt;/li&gt;
&lt;li&gt;输入：mean：8维状态均值向量；covariance：8X8状态协方差矩阵；measurements：NX4的矩阵。每行是一个检测框[x,y,a,h]；only_position：若为True，则仅计算中心坐标(x,y)的距离。&lt;/li&gt;
&lt;li&gt;输出：长度为N的数组，每个元素是对应检测框与预测状态的平方马氏距离。&lt;br&gt;
&lt;code&gt;cholesky_factor = np.linalg.cholesky(covariance)&lt;/code&gt;&lt;br&gt;
对协方差矩阵进行Cholesky分解，避免直接求逆矩阵，提升数值稳定性。&lt;br&gt;
&lt;code&gt;d = measurements - mean&lt;/code&gt;&lt;br&gt;
计算残差检测框坐标-预测坐标。&lt;br&gt;
&lt;code&gt;z = scipy.linalg.solve_triangular(cholesky_factor, d.T, lower=True, check_finite=False,overwrite_b=True)&lt;/code&gt;&lt;br&gt;
解方程组，对残差进行白化处理。&lt;br&gt;
马氏距离求解：https://zhuanlan.zhihu.com/p/520757659&lt;br&gt;
余弦距离参考：https://blog.csdn.net/DeepCBW/article/details/124650876&lt;br&gt;
参考博客：https://blog.csdn.net/qq_45266796/article/details/134775492&lt;br&gt;
https://blog.csdn.net/weixin_39910711/article/details/113985520#commentBox&lt;/li&gt;
&lt;/ul&gt;
">DeepSort-卡尔曼滤波</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/opencv-du-qu-tu-pian/"" data-c="
          &lt;ul&gt;
&lt;li&gt;#python&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748771024615.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;#C++&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748771770050.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748771796101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">Opencv-读取图片</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/opencv-1-an-zhuang-opencv/"" data-c="
          &lt;ul&gt;
&lt;li&gt;安装-基于Python&lt;br&gt;
&lt;code&gt;conda create -n opencv python=3.12&lt;/code&gt; 使用conda创建名为opencv的环境，python版本为3.12&lt;br&gt;
&lt;code&gt;conda activate opencv&lt;/code&gt; 激活opencv环境&lt;br&gt;
&lt;code&gt;conda env list&lt;/code&gt; 查看创建的环境&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489479425.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;conda install -c conda-forge opencv&lt;/code&gt; 安装opencv&lt;br&gt;
安装好检测是否成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489529762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;安装-基于C++&lt;br&gt;
1、访问Opencv的官方下载页面：https://opencv.org/releases/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489940154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择opencv-4.11.0的windows版本&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489972481.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
解压&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747490331641.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置环境变量&lt;br&gt;
将D:\Opencv\opencv\build\x64\vc16\bin添加到系统的环境变量中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747490598040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747490568639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2、安装MinGW-w64&lt;br&gt;
3、CMake&lt;br&gt;
在官网下载CMake，选择二进制文件&lt;br&gt;
https://cmake.org/download/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491005571.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
解压&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491214352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将cmake的bin文件路径添加到系统环境变量中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491773065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491851776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检测cmake是否安装成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491907678.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4、生成MakeFiles&lt;br&gt;
在D:\Opencv\opencv\build\x64下新建一个MinGW文件夹&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492401805.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进入D:\Opencv\cmake-4.0.2-windows-x86_64 (1)\cmake-4.0.2-windows-x86_64\bin，打开cmake-gui。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492454143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击configure，配置如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492530080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
路径C:\msys64\ucrt64\bin下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492800252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
等待&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747493149028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
显示Configure done，勾选BUILD_opencv_world、WITH_OPENGL和BUILD EXAMPLES，不勾选WITH_IPP、WITH_MSMF和ENABLE_PRECOMPILED_HEADERS，CPU_DISPATCH选空，再次点击Configure&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747493471534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
手动下载未下载的文件&lt;br&gt;
https://raw.githubusercontent.com/opencv/opencv_3rdparty/d63d7c154c57242bf2283be61166be2bd30ec47e/ffmpeg/opencv_videoio_ffmpeg.dll&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494166907.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494174939.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
https://raw.githubusercontent.com/opencv/opencv_3rdparty/d63d7c154c57242bf2283be61166be2bd30ec47e/ffmpeg/opencv_videoio_ffmpeg_64.dll&lt;br&gt;
同上&lt;br&gt;
再次点击Configure，出现Configure done后，点击Generate&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494436549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如MakeFiles文件成功生成，CMakeDownloadLog.txt显示如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494536906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5、编译Opencv(先激活opencv环境)&lt;br&gt;
使用cmake确保安装python3，且python配好环境变量&lt;br&gt;
cmd到makefile所在文件夹&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494805786.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
键入mingw32-make -j 8&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494894040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747495801216.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747538192757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
c++版本低于c++14&lt;br&gt;
在powershell中查看c++版本&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747538942930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747538990348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为c++17，Anaconda的mingw编译器版本过低，环境变量优先级高&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747539719911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将msys上移后，无效，还是报错&lt;br&gt;
键入mingw32-make clean清除后，重新mingw32-make -j4&lt;br&gt;
无效，继续报错。😵😵😵&lt;br&gt;
猜测激活环境后，还是继续使用anaconda的编译器，conda deactivate退出opencv环境试试。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747542655268.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
🤡🤡🤡&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747547073309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
升级conda的c++编译器&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747547723531.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
无效，待续。&lt;br&gt;
重新安装mingw64&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747734865352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加到系统环境变量&lt;br&gt;
在vscode里面重新配置g++,测试成功后。删除原来的makefile&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747736131803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747736315089.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
重新按上述步骤操作&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747737230891.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还是报同样的错&lt;br&gt;
删除E盘Library/include，重新运行，然后报错无avif/avif/h，再将include恢复到E盘library下，继续重新运行&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747742794786.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
继续报错，运行mingw32-make单线程编译&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747743151148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
到99%报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747745421775.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
关闭下图这个&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747745704938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747752339448.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747755472659.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编译成功，开始装载&lt;br&gt;
mingw-make install&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747755544527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加系统环境变量D:\Opencv\opencv\build\x64\MinGW\bin&lt;br&gt;
6、VS Code配置&lt;br&gt;
launch.json配置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747756193337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
c_cpp_properties配置（ctrl+shift+p)&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747756572998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
task.json配置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747756834975.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
setting配置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747757386578.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
setting.json看博客。&lt;br&gt;
7、测试&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747757512038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错，修改setting.json中的cpp项路径。&lt;br&gt;
tasks.json添加程序如下图&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748056879144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748056887645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748056961505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
按照第二篇博客配置，成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748058852986.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
参考博客：https://blog.csdn.net/weixin_43101257/article/details/124472866&lt;br&gt;
https://blog.csdn.net/qq_41171302/article/details/146435360&lt;/li&gt;
&lt;/ul&gt;
">Opencv-(1)-安装opencv</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/vs-code-pei-zhi-gcc/"" data-c="
          &lt;ul&gt;
&lt;li&gt;在vs code官网下载安装vs code&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747463277123.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;下载msys2-installer&lt;br&gt;
https://www.mingw-w64.org/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464185379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击msys2&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464233168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Github&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464303869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464334016.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击msys2-x86_64-20250221.exe，下载&lt;/li&gt;
&lt;li&gt;安装msys2&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464520698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击下一步&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464571166.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464607311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464643428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进度条走完，继续默认下一步&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464979561.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认勾选，点击Finishe&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465030412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
键入pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain&lt;br&gt;
按回车，输入y&lt;br&gt;
等待下载完成，关闭终端&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465448602.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开安装msys2的目录，找到ucrt64文件夹并进入，找到bin文件，复制路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465614698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
搜索框搜索编辑环境变量，打开&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465686709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击环境变量&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465746403.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在打开的界面中找到用户变量的Path&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465832295.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双击打开&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465873286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击新建，粘贴复制的路径，点击确定&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465943698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
退出即可&lt;/li&gt;
&lt;li&gt;测试gcc&lt;br&gt;
按win+r，输入cmd&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466056132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
依次输入回车，如图即配置环境成功&lt;/li&gt;
&lt;li&gt;汉化vs code&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466168736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466243642.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
安装完成后，点击右下角改变语言并重启&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466288143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466340999.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;安装C/C++扩展包&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466478165.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">vs code配置gcc</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/gitee/"" data-c="
          &lt;ul&gt;
&lt;li&gt;新建仓库&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374716051.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;填写路径名称&lt;/li&gt;
&lt;li&gt;创建成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374809675.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;打开git bash&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374909560.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;git init&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374947541.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现文件夹下面多一个.git文件夹&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375008241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击进去，编辑config文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375063497.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375644863.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编辑好保存，回到gitee，点击克隆/下载&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375308908.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
复制，在bash界面输入git remote add origin + 链接&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375400900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git pull origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375837196.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git add .&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375957872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git commit -m &#39;说明&#39;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747376050341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git push origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747376171705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错如图&lt;br&gt;
输入命令git push -f origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747376215344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;刷新gitee&lt;/li&gt;
&lt;/ul&gt;
">gitee上传代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-trackpy/"" data-c="
          &lt;h1 id=&#34;import&#34;&gt;import&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743770558767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sys.path.insert(0, &#39;./yolov5&#39;)&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743770809662.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;sys.path=E:\Yolov5\DeepSort\Yolov5_DeepSort\Yolov5_DeepSort&lt;/li&gt;
&lt;li&gt;track.py是 YOLOv5 的目标跟踪脚本，通常需要调用 yolov5 目录下的模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;串口&#34;&gt;串口&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743770990492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;port_list = list(serial.tools.list_ports.comports())&lt;/code&gt;获取当前计算机上所有可用的串口设备列表，并转换为 Python 列表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if len(port_list) == 0:&lt;/code&gt;如果 port_list 为空（len(port_list) == 0），打印 &#39;none&#39;，表示未检测到任何串口设备。&lt;br&gt;
否则，遍历列表并逐个打印每个串口的详细信息（如名称、描述、制造商等）。&lt;br&gt;
&lt;code&gt;portName = &amp;quot;COM3&amp;quot;  # 端口名&lt;/code&gt;&lt;br&gt;
&lt;code&gt;baudRate = 9600  # 波特率&lt;/code&gt;&lt;br&gt;
&lt;code&gt;timeOut = 3&lt;/code&gt;&lt;br&gt;
portName：指定要使用的串口名称（如 COM3 是 Windows 下的典型串口名，Linux/Mac 下可能是 /dev/ttyUSB0）。&lt;br&gt;
baudRate：设置通信波特率（常见值如 9600、115200 等），需与设备端配置一致。&lt;br&gt;
timeOut：设置串口读取超时时间（秒），超过该时间未收到数据则抛出异常。&lt;/li&gt;
&lt;li&gt;作用：&lt;br&gt;
硬件交互：与 Arduino、传感器或其他通过串口通信的设备连接。&lt;br&gt;
调试：确认系统中可用的串口设备，避免手动输入错误端口名。&lt;br&gt;
初始化配置：为后续的串口通信（如 serial.Serial(portName, baudRate, timeout=timeOut)）提供参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;palette&#34;&gt;palette&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;palette = (2 ** 11 - 1, 2 ** 15 - 1, 2 ** 20 - 1)&lt;/code&gt;生成一个包含三个整数的元组，用于表示某种颜色或ID的调色板（Palette）。&lt;br&gt;
2 ** 11 - 1 = 2047&lt;br&gt;
（二进制：11111111111，11位全1）&lt;br&gt;
2 ** 15 - 1 = 32767&lt;br&gt;
（二进制：111111111111111，15位全1）&lt;br&gt;
2 ** 20 - 1 = 1048575&lt;br&gt;
（二进制：11111111111111111111，20位全1）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743771523431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;datect&#34;&gt;datect&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743827853930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;initialize-deepsort&#34;&gt;initialize deepsort&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743828065304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cfg = get_config()&lt;/code&gt;调用 get_config() 函数获取一个默认的配置对象（通常是一个 Config 或 EasyDict 类型的对象）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743828190043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg.merge_from_file(opt.config_deepsort)&lt;/code&gt;从文件 opt.config_deepsort（路径由命令行参数 opt 提供）加载 DeepSort 的配置文件，并合并到 cfg 中。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743828328772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
REID_CKPT:指定 ReID（重识别）模型的权重文件路径。&lt;br&gt;
MAX_DIST: 特征匹配的最大余弦距离阈值。当两个目标的特征向量距离超过 0.2 时，认为它们不匹配。值越小，匹配越严格。&lt;br&gt;
MIN_CONFIDENCE:检测结果的最小置信度阈值。忽略置信度低于 0.3 的检测框.&lt;br&gt;
NMS_MAX_OVERLAP:非极大值抑制（NMS）的重叠阈值。若两个检测框的 IoU（交并比）超过 0.5，则保留置信度更高的框，抑制另一个。&lt;br&gt;
MAX_IOU_DISTANCE:ioU 距离的最大阈值，用于关联检测框和跟踪轨迹。当检测框与预测轨迹的 IoU 距离 ≤ 0.7 时，认为它们可能属于同一目标。&lt;br&gt;
MAX_AGE:轨迹的最大存活帧数,若轨迹连续 70 帧未被匹配到检测框，则删除该轨迹。&lt;br&gt;
N_INIT:新检测目标需连续 3 帧成功匹配，才确认为有效轨迹&lt;br&gt;
NN_BUDGET: 每个轨迹最多保留 100 个历史特征，用于后续匹配，平衡内存和跟踪精度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if os.path.exists(out):&lt;/code&gt;检查输出目录 out 是否已存在。如果目录存在，可能需要先删除旧数据以避免冲突。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.rmtree(out)&lt;/code&gt;递归删除输出目录 out 及其所有内容.确保每次运行时输出目录是空的，避免旧结果干扰新结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.makedirs(out)&lt;/code&gt;重新创建输出目录 out。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;half = device.type != &#39;cpu&#39;&lt;/code&gt;根据设备类型决定是否启用半精度（FP16）计算。&lt;br&gt;
evice.type 是运行设备（如 &#39;cuda&#39; 或 &#39;cpu&#39;）。&lt;br&gt;
半精度（half=True）仅支持 GPU（CUDA），可加速计算并减少显存占用。&lt;br&gt;
如果是 CPU 运行，则强制使用全精度（half=False）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;load-model&#34;&gt;load model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743829011354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;model = attempt_load(yolo_weights, map_location=device)&lt;/code&gt;&lt;br&gt;
加载预训练的 YOLO 模型。&lt;br&gt;
yolo_weights：YOLO 模型权重文件的路径（如 yolov5s.pt）。&lt;br&gt;
map_location=device：指定模型加载的设备（如 &#39;cuda:0&#39; 或 &#39;cpu&#39;）。&lt;br&gt;
默认加载全精度（FP32）模型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stride = int(model.stride.max())&lt;/code&gt;&lt;br&gt;
获取模型的最大步长（stride）。stride 是 YOLO 模型下采样的倍数（如 8、16、32），影响输入图像的尺寸要求。YOLOv5 的 stride 通常是 32（最终特征图的缩放比例）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgsz = check_img_size(imgsz, s=stride)&lt;/code&gt;check_img_size 确保 imgsz 是 stride 的整数倍（避免尺寸对齐问题）。&lt;br&gt;
例如，若 stride=32，imgsz=640 会被接受，而 imgsz=641 会被调整为 640。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;names = model.module.names if hasattr(model, &#39;module&#39;) else model.names&lt;/code&gt;&lt;br&gt;
获取模型训练的类别名称列表&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743829338242.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if half: model.half()&lt;/code&gt;将模型转换为半精度（FP16）模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vid_path, vid_writer = None, None&lt;/code&gt;初始化视频路径和视频写入器变量为 None。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show_vid = check_imshow()&lt;/code&gt;检查当前环境是否支持图像显示&lt;br&gt;
check_imshow()：通常尝试创建一个测试窗口，验证是否支持 cv2.imshow()。&lt;br&gt;
如果环境不支持（如无 GUI 的服务器），则 show_vid 会被设为 False，避免显示报错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cudnn.benchmark = True&lt;/code&gt;启用 cuDNN 的自动优化模式，加速固定尺寸图像的推理（适用于摄像头输入分辨率不变的情况）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;run-inference&#34;&gt;Run inference&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743829837311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;model(torch.zeros(1, 3, imgsz, imgsz).to(device).type_as(next(model.parameters())))&lt;/code&gt;模型预热（Warm-up）。&lt;br&gt;
生成一个全零的虚拟输入张量，形状为 (1, 3, imgsz, imgsz)（批大小 1，3 通道，尺寸 imgsz x imgsz）。&lt;br&gt;
to(device)：将张量移动到指定设备（GPU/CPU）。&lt;br&gt;
type_as(...)：确保张量数据类型与模型参数一致（如 FP16/FP32）。&lt;br&gt;
执行一次前向推理（model(...)）。&lt;br&gt;
初始化 GPU 的 CUDA 上下文，避免首次正式推理时的延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;模型推理-nmsprocessdetections&#34;&gt;模型推理 NMS/process/detections&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743830448793.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for frame_idx, (path, img, im0s, vid_cap) in enumerate(dataset):&lt;/code&gt;&lt;br&gt;
从数据加载器 dataset 中逐帧读取数据，返回：&lt;br&gt;
path：当前帧的路径（如视频文件路径或摄像头索引）。&lt;br&gt;
img：预处理后的图像（尺寸调整、归一化等，形状为 [H, W, C] 或 [B, H, W, C]）。&lt;br&gt;
im0s：原始图像（未缩放的 OpenCV 格式，用于可视化或保存结果）。&lt;br&gt;
vid_cap：视频捕获对象（仅视频文件有效）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = torch.from_numpy(img).to(device)&lt;/code&gt;将 img 转换为 PyTorch 张量并移动到指定设备（GPU/CPU）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = img.half() if half else img.float()  # uint8 to fp16/32&lt;/code&gt;根据 half 参数选择半精度（FP16）或全精度（FP32）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img /= 255.0  # 0 - 255 to 0.0 - 1.0&lt;/code&gt;归一化像素值到 [0.0, 1.0] 范围。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if img.ndimension() == 3:img = img.unsqueeze(0)&lt;/code&gt;如果输入是单张图像（ndimension() == 3），增加批次维度（unsqueeze(0)）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t1 = time_synchronized()&lt;/code&gt;time_synchronized()：同步 GPU 操作并记录时间戳 t1（用于计算推理耗时）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pred = model(img, augment=opt.augment)[0]&lt;/code&gt;&lt;br&gt;
执行模型推理：augment：是否启用数据增强（如多尺度测试）。&lt;br&gt;
pred：模型的原始输出（未处理的检测框，形状为 [N, 6]，其中 6 为 [x1, y1, x2, y2, conf, cls]）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;non_max_suppression&lt;/code&gt;过滤冗余检测框：&lt;br&gt;
opt.conf_thres：置信度阈值（低于此值的检测框被丢弃）。&lt;br&gt;
opt.iou_thres：IoU 阈值（重叠高于此值的框会被合并）。&lt;br&gt;
classes：指定保留的类别（如只检测行人）。&lt;br&gt;
agnostic：是否跨类别进行 NMS（如合并不同类别的重叠框）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p, s, im0 = path[i], &#39;%g: &#39; % i, im0s[i].copy()&lt;/code&gt;webcam 为 True 时，处理多路视频流（path[i] 和 im0s[i]）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p, s, im0 = path, &#39;&#39;, im0s&lt;/code&gt;webcam 为 False 时，处理单路输入（path 和 im0s）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s += &#39;%gx%g &#39; % img.shape[2:]  # print string&lt;/code&gt;构建日志字符串（如 &amp;quot;640x480 &amp;quot;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;boxes&#34;&gt;boxes&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743831544299.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;det[:, :4] = scale_coords(img.shape[2:], det[:, :4], im0.shape).round()&lt;/code&gt;&lt;br&gt;
将检测框坐标从模型输入尺寸（img.shape[2:]，如 640x640）缩放到原始图像尺寸（im0.shape，如 1920x1080）。输出：det 的坐标变为 [x1, y1, x2, y2]（原始图像尺度）。&lt;br&gt;
scale_coords：线性缩放坐标（保持宽高比）。&lt;br&gt;
.round()：将坐标四舍五入为整数（便于后续绘制或处理）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s += &#39;%g %ss, &#39; % (n, names[int(c)])&lt;/code&gt;&lt;br&gt;
示例输出：若检测到 2 人和 1 车，s 变为 &amp;quot;2 persons, 1 cars, &amp;quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x_c, y_c, bbox_w, bbox_h = xyxy_to_xywh(*xyxy)&lt;/code&gt;将 YOLO 的 xyxy 格式转换为 DeepSort 所需的 [x_center, y_center, width, height] 格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;outputs = deepsort.update(xywhs, confss, im0)&lt;/code&gt;&lt;br&gt;
输入：&lt;br&gt;
xywhs：检测框的中心坐标和宽高。&lt;br&gt;
confss：检测置信度。&lt;br&gt;
im0：原始图像（用于视觉特征提取）。&lt;br&gt;
输出：outputs 形状为 [M, 5]，每行为 [x1, y1, x2, y2, track_id]（跟踪后的目标框和 ID）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743835223285.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743835539421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;stream-results&#34;&gt;Stream results&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743835635489.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;xyxy-to-xywh&#34;&gt;xyxy to xywh&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743836706336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入：*xyxy&lt;br&gt;
可变参数，接受 4 个值（x1, y1, x2, y2），表示检测框的左上角和右下角坐标。&lt;br&gt;
输出：返回 4 个值（x_c, y_c, w, h），即中心点坐标和宽高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bbox_left = min([xyxy[0].item(), xyxy[2].item()])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bbox_top = min([xyxy[1].item(), xyxy[3].item()])&lt;/code&gt;&lt;br&gt;
确保 bbox_left 和 bbox_top 是左上角坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bbox_w = abs(xyxy[0].item() - xyxy[2].item())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bbox_h = abs(xyxy[1].item() - xyxy[3].item())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;.item() 的作用：&lt;br&gt;
如果输入是 PyTorch 张量，.item() 将其转换为 Python 标量（数值）。&lt;br&gt;
使用绝对值保证宽高为正数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x_c = (bbox_left + bbox_w / 2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y_c = (bbox_top + bbox_h / 2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;xyxy-to-tlwh&#34;&gt;xyxy to tlwh&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837084243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
用于将目标检测框的坐标从 [x1, y1, x2, y2]（左上角和右下角坐标）格式转换为 [top_left_x, top_left_y, width, height]（左上角坐标 + 宽高）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for i, box in enumerate(bbox_xyxy):&lt;/code&gt;遍历每个检测框&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x1, y1, x2, y2 = [int(i) for i in box]&lt;/code&gt;将坐标值强制转换为整数（适用于浮点数输入或张量）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;label-color&#34;&gt;label color&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837282041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据目标类别标签（label）生成一个固定的颜色值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def compute_color_for_labels(label):&lt;/code&gt;&lt;br&gt;
输入：label&lt;br&gt;
目标的类别标签（整数，如 0 表示 &amp;quot;person&amp;quot;，1 表示 &amp;quot;car&amp;quot;）。&lt;br&gt;
输出：一个 RGB 颜色元组（如 (255, 128, 0)），用于可视化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color = [int((p * (label ** 2 - label + 1)) % 255) for p in palette]&lt;/code&gt;&lt;br&gt;
公式 label ** 2 - label + 1 是一个简单的哈希函数，确保不同 label 映射到不同的颜色值。&lt;br&gt;
% 255 保证结果在 [0, 255] 范围内（RGB 值的合法区间）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return tuple(color)&lt;/code&gt;&lt;br&gt;
将列表 color 转换为元组（如 (R, G, B)），便于 OpenCV 等库使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;draw-boxes&#34;&gt;draw boxes&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837478158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837658670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837691869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837743841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837781892.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837833620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837878782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id = int(identities[i]) if identities is not None else 0&lt;/code&gt;&lt;br&gt;
若未提供 identities，默认 ID 为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color = compute_color_for_labels(id)&lt;/code&gt;&lt;br&gt;
调用 compute_color_for_labels根据 ID 生成唯一颜色（用于框和文本）。&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计track.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-trainpy/"" data-c="
          &lt;h1 id=&#34;set-ddp-variables设置分布式训练参数&#34;&gt;Set DDP variables设置分布式训练参数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743430632740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
world_size：表示参与分布式训练的进程总数（GPU 数量）。从环境变量 WORLD_SIZE 中读取（由分布式框架如 torch.distributed 自动设置），若未设置则默认为 1（单机单卡）。&lt;br&gt;
global_rank：表示当前进程的全局排名（从 0 到 world_size-1）。从环境变量 RANK 中读取，若未设置则默认为 -1（非分布式模式）.&lt;/p&gt;
&lt;h1 id=&#34;resume-恢复&#34;&gt;resume 恢复&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743430973122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;opt.data, opt.cfg, opt.hyp = check_file(opt.data), check_file(opt.cfg), check_file(opt.hyp)  # check files&lt;/code&gt;&lt;br&gt;
检查文件路径：check_file() 确保 opt.data（数据集配置）、opt.cfg（模型配置）、opt.hyp（超参数文件）存在。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assert len(opt.cfg) or len(opt.weights), &#39;either --cfg or --weights must be specified&#39;&lt;/code&gt;&lt;br&gt;
assert len(opt.cfg) or len(opt.weights) 确保必须指定 --cfg（模型结构）或 --weights（预训练权重）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opt.img_size.extend([opt.img_size[-1]] * (2 - len(opt.img_size)))&lt;/code&gt;&lt;br&gt;
opt.img_size.extend(...) 将 img_size 扩展为 2 个值（训练和测试尺寸相同），例如 [640] → [640, 640]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ddp-model&#34;&gt;DDP Model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743431434703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if opt.local_rank != -1:&lt;/code&gt;如果 opt.local_rank 不是 -1，表示启用分布式训练&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(opt.hyp) as f:&lt;/code&gt;从 opt.hyp 指定的 YAML 文件中加载超参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hyp = yaml.load(f, Loader=yaml.FullLoader)  # load hyps&lt;/code&gt; 使用 yaml.FullLoader 解析 YAML 文件为字典（hyp）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if &#39;box&#39; not in hyp:&lt;/code&gt;检查超参数中是否存在 &#39;box&#39; 键（用于边界框损失计算）。如果不存在，则假设旧版参数 &#39;giou&#39; 存在，并将其重命名为 &#39;box&#39;，同时输出兼容性警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;train&#34;&gt;Train&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743432009952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logger.info(opt&lt;/code&gt;)使用 logger 打印 opt（训练配置参数），方便用户查看当前的训练设置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if not opt.evolve:&lt;/code&gt;检查是否处于超参数进化模式（evolve）。如果不是，则执行后续的 TensorBoard 初始化逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tb_writer = None  # init loggers&lt;/code&gt; 初始化 tb_writer（TensorBoard 写入器）为 None，后续会根据条件重新赋值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if opt.global_rank in [-1, 0]:&lt;/code&gt;检查当前进程的全局排名（global_rank），通常用于分布式训练。-1 表示单机训练，0 表示主进程（在多机多卡训练中）。只有主进程或单机训练时才执行以下操作，避免重复记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(f&#39;Start Tensorboard with &amp;quot;tensorboard --logdir {opt.project}&amp;quot;, view at http://localhost:6006/&#39;)&lt;/code&gt;&lt;br&gt;
打印提示信息，告诉用户如何启动 TensorBoard 服务，并指定日志目录为 opt.project（训练结果保存路径）。用户可以通过访问 http://localhost:6006/ 查看训练过程的可视化结果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tb_writer = SummaryWriter(opt.save_dir)  # Tensorboard&lt;/code&gt;初始化 SummaryWriter（TensorBoard 的日志写入器），日志将保存到 opt.save_dir（模型和日志的保存目录）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;train(hyp, opt, device, tb_writer, wandb)&lt;/code&gt;调用&lt;br&gt;
train函数开始训练，传入以下参数：&lt;br&gt;
hyp：超参数配置（如学习率、权重衰减等）。&lt;br&gt;
opt：训练选项（如数据集路径、批次大小等）。&lt;br&gt;
device：训练设备（如 cuda:0 或 cpu）。&lt;br&gt;
tb_writer：TensorBoard 写入器，用于记录训练指标。&lt;br&gt;
wandb：可选参数，用于 Weights &amp;amp; Biases 日志记录（如果启用）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743509985474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;def train(hyp, opt, device, tb_writer=None, wandb=None):&lt;/code&gt;&lt;br&gt;
定义训练函数 train，接收以下参数：&lt;br&gt;
hyp：超参数配置（如学习率、权重衰减等）。&lt;br&gt;
opt：训练选项（如数据集路径、批次大小等）。&lt;br&gt;
device：训练设备（如 cuda:0 或 cpu）。&lt;br&gt;
tb_writer（可选）：TensorBoard 日志写入器，默认为 None。&lt;br&gt;
wandb（可选）：Weights &amp;amp; Biases 日志工具，默认为 None。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(f&#39;Hyperparameters {hyp}&#39;)&lt;/code&gt;&lt;br&gt;
使用 logger 打印当前的超参数配置 hyp，方便调试和记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wdir = save_dir / &#39;weights&#39;&lt;/code&gt;定义权重文件的保存目录（save_dir/weights）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wdir.mkdir(parents=True, exist_ok=True)  # make dir&lt;/code&gt;&lt;br&gt;
parents=True：自动创建父目录（如果不存在）。&lt;br&gt;
exist_ok=True：如果目录已存在，不报错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last = wdir / &#39;last.pt&#39;&lt;/code&gt;保存最后一轮的模型权重。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;best = wdir / &#39;best.pt&#39;&lt;/code&gt;保存验证集上性能最好的模型权重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;results_file = save_dir / &#39;results.txt&#39;&lt;/code&gt;保存训练过程中的指标（如损失、精度等）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743510469538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(save_dir / &#39;hyp.yaml&#39;, &#39;w&#39;) as f:&lt;/code&gt;将超参数 hyp 保存到 save_dir/hyp.yaml 文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(save_dir / &#39;opt.yaml&#39;, &#39;w&#39;) as f:&lt;/code&gt;将训练选项 opt（通过 vars(opt) 转换为字典）保存到 save_dir/opt.yaml 文件。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743510713288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yaml.dump(hyp, f, sort_keys=False)&lt;/code&gt;&lt;br&gt;
sort_keys=False 保持参数原始顺序，不按字母排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plots = not opt.evolve&lt;/code&gt;plots：是否生成训练曲线图（如果是超参数进化模式 evolve，则不生成）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cuda = device.type != &#39;cpu&#39;&lt;/code&gt;检查当前设备是否为 GPU&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data_dict = yaml.load(f, Loader=yaml.FullLoader)&lt;/code&gt;&lt;br&gt;
从 opt.data（数据集配置文件路径，如 data/coco.yaml）加载 YAML 文件，解析为字典 data_dict。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743511070491.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;train_path = data_dict[&#39;train&#39;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test_path = data_dict[&#39;val&#39;]&lt;/code&gt;&lt;br&gt;
从 data_dict 中获取训练集和验证集的路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743511297397.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nc = 1 if opt.single_cls else int(data_dict[&#39;nc&#39;])&lt;/code&gt;&lt;br&gt;
类别数量。如果启用单类别模式（opt.single_cls），则强制设为 1；否则使用 data_dict[&#39;nc&#39;]。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;names = [&#39;item&#39;] if opt.single_cls and len(data_dict[&#39;names&#39;]) != 1 else data_dict[&#39;names&#39;]&lt;/code&gt;&lt;br&gt;
类别名称列表。如果是单类别模式且配置文件中名称不唯一，则设为 [&#39;item&#39;]；否则使用 data_dict[&#39;names&#39;]。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assert len(names) == nc, &#39;%g names found for nc=%g dataset in %s&#39; % (len(names), nc, opt.data)&lt;/code&gt;检查类别数量 nc 和名称列表 names 的长度是否一致，否则报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;model&#34;&gt;Model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743511567205.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pretrained = weights.endswith(&#39;.pt&#39;)&lt;/code&gt;通过检查 weights 路径是否以 .pt 结尾，判断是否使用预训练权重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with torch_distributed_zero_first(rank):&lt;/code&gt;确保分布式训练中，主进程先下载权重，其他进程等待。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;attempt_download(weights)&lt;/code&gt;如果本地不存在 weights 文件，则从网络下载（如从 YOLOv5 官方仓库下载）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ckpt = torch.load(weights, map_location=device)&lt;/code&gt;加载 .pt 文件到 ckpt（字典形式），并指定加载到 device（如 cuda:0 或 cpu）。ckpt 通常包含模型权重 state_dict、超参数 hyp、模型配置 yaml 等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if hyp.get(&#39;anchors&#39;):&lt;/code&gt;如果超参数 hyp 中指定了 anchors，则强制覆盖模型配置中的锚点参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; ckpt[&#39;model&#39;].yaml[&#39;anchors&#39;] = round(hyp[&#39;anchors&#39;])&lt;/code&gt;round(hyp[&#39;anchors&#39;]) 对锚点值取整，确保其为整数。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743516282637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743516489869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;model = Model(opt.cfg or ckpt[&#39;model&#39;].yaml, ch=3, nc=nc).to(device)&lt;/code&gt;&lt;br&gt;
如果 opt.cfg（模型配置文件路径）存在，则优先使用；否则使用预训练模型中的配置 ckpt[&#39;model&#39;].yaml。&lt;br&gt;
ch=3：输入图像的通道数（RGB）。&lt;br&gt;
nc=nc：类别数量（从数据集配置中获取）。&lt;br&gt;
.to(device)：将模型移动到指定设备（GPU/CPU）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743516848843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exclude = [&#39;anchor&#39;] if opt.cfg or hyp.get(&#39;anchors&#39;) else []&lt;/code&gt;如果使用自定义配置（opt.cfg）或覆盖锚点（hyp[&#39;anchors&#39;]），则排除 anchor 相关权重（防止冲突）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state_dict = ckpt[&#39;model&#39;].float().state_dict()&lt;/code&gt;将预训练权重转换为 FP32 格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state_dict = intersect_dicts(state_dict, model.state_dict(), exclude=exclude)&lt;/code&gt;筛选预训练权重中与当前模型结构匹配的部分（忽略不匹配的层）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;model.load_state_dict(state_dict, strict=False)&lt;/code&gt;加载权重，允许部分加载&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(&#39;Transferred %g/%g items from %s&#39; % (len(state_dict), len(model.state_dict()), weights))&lt;/code&gt;记录成功加载的权重数量（例如 Transferred 300/320 items from yolov5s.pt）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;else:model = Model(opt.cfg, ch=3, nc=nc).to(device)  # create&lt;/code&gt;如果没有提供预训练权重（pretrained=False），则直接根据 opt.cfg 创建新模型，并随机初始化权重。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;freeze&#34;&gt;Freeze&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;freeze = []&lt;/code&gt;定义一个空列表 freeze，用于存储需要冻结的层名称。用户可以通过修改 freeze 列表（例如 freeze = [&#39;backbone&#39;]）来冻结模型的某些部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for k, v in model.named_parameters():&lt;/code&gt;遍历模型中所有可训练参数，k 是参数名称（如 model.0.conv.weight），v 是参数张量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v.requires_grad = True&lt;/code&gt;默认将所有参数的 requires_grad 设为 True，表示在训练时更新这些参数的权重。默认启用梯度计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if any(x in k for x in freeze): print(&#39;freezing %s&#39; % k) v.requires_grad = False&lt;/code&gt;检查当前参数名称 k 是否包含 freeze 列表中的任何子字符串（例如 k 包含 backbone）。&lt;br&gt;
如果匹配，则打印冻结日志，并将该参数的 requires_grad 设为 False（冻结权重，不参与梯度更新）&lt;br&gt;
若 freeze = [&#39;backbone&#39;]，则所有名称中包含 backbone 的层（如backbone.conv1.weight）会被冻结。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;optimizer-优化器&#34;&gt;optimizer 优化器&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743518275245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nbs = 64  # nominal batch size&lt;/code&gt;名义批次大小（Nominal Batch Size），默认为 64，作为基准值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accumulate = max(round(nbs / total_batch_size), 1)&lt;/code&gt;梯度累积步数。当实际总批次大小（total_batch_size，如多卡训练的全局批次）小于 nbs 时，通过多次前向-反向传播累积梯度，再更新权重（等效增大批次大小）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hyp[&#39;weight_decay&#39;] *= total_batch_size * accumulate / nbs&lt;/code&gt;根据实际批次大小调整权重衰减系数，保持与名义批次的一致性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pg0, pg1, pg2 = [], [], []&lt;/code&gt;&lt;br&gt;
将模型参数分为三组，用于差异化优化策略：&lt;br&gt;
pg0：BatchNorm2d 层的权重（不应用权重衰减）。&lt;br&gt;
pg1：普通卷积层的权重（应用权重衰减）。&lt;br&gt;
pg2：所有层的偏置参数（不应用权重衰减）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if opt.adam:&lt;/code&gt;&lt;br&gt;
如果使用 Adam 优化器（opt.adam=True）：&lt;br&gt;
初始化 Adam，设置学习率 lr0，并将 beta1 替换为超参数 momentum。&lt;br&gt;
默认使用 SGD 优化器：&lt;br&gt;
初始化 SGD，设置学习率 lr0、动量 momentum，并启用 Nesterov 加速。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimizer.add_param_group({&#39;params&#39;: pg1, &#39;weight_decay&#39;: hyp[&#39;weight_decay&#39;]})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimizer.add_param_group({&#39;params&#39;: pg2})&lt;/code&gt;&lt;br&gt;
将分组参数添加到优化器：&lt;br&gt;
pg1（卷积权重）附带权重衰减。&lt;br&gt;
pg2（偏置）不附带权重衰减。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lf = one_cycle(1, hyp[&#39;lrf&#39;], epochs)&lt;/code&gt;one_cycle：生成一个余弦退火学习率调度函数，初始值为 1，最终值降至 hyp[&#39;lrf&#39;]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)&lt;/code&gt;&lt;br&gt;
LambdaLR：将调度函数 lf 应用到优化器，实现学习率动态调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;resume&#34;&gt;Resume&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743741125203.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
start_epoch：初始化为 0，表示训练从第 0 个 epoch 开始。&lt;br&gt;
best_fitness：初始化为 0.0，用于记录模型的最佳性能指标&lt;br&gt;
如果 pretrained 为 True，表示需要加载预训练模型的参数。&lt;br&gt;
ckpt 是预训练模型的检查点（checkpoint）字典。&lt;br&gt;
如果检查点中包含优化器状态（ckpt[&#39;optimizer&#39;] 不为 None），则将其加载到当前优化器（optimizer）中，以恢复训练时的优化器参数（如动量、学习率等）。&lt;br&gt;
从检查点中加载之前保存的最佳性能指标（best_fitness），用于后续模型保存和早停（early stopping）等逻辑。&lt;/p&gt;
&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743741510973.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ckpt 是预训练模型的检查点字典。使用 ckpt.get(&#39;training_results&#39;) 检查检查点中是否包含键 &#39;training_results&#39;（历史训练结果，如损失、精度等指标）。如果存在（不为 None），则执行后续操作。&lt;br&gt;
results_file 是保存训练结果的文件路径（默认是 results.txt）。以写入模式（&#39;w&#39;）打开文件，并将检查点中的 training_results内容写入文件中。这样做的目的是恢复之前的训练记录，方便后续继续训练时能够跟踪完整的训练历史。&lt;/p&gt;
&lt;h1 id=&#34;epochs&#34;&gt;Epochs&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743741693792.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从检查点 ckpt 中加载之前训练到的 epoch 值（ckpt[&#39;epoch&#39;]），并 +1 作为本次训练的起始 epoch。&lt;br&gt;
如果用户通过命令行参数 --resume 显式要求恢复训练：&lt;br&gt;
使用 assert 检查 start_epoch 是否大于 0。如果为 0，说明之前已经完成了全部 epochs 的训练，无需恢复，直接报错提示。&lt;br&gt;
错误消息示例：&amp;quot;model.pt training to 200 epochs is finished, nothing to resume.&amp;quot;&lt;br&gt;
如果用户设置的 epochs（本次训练的总 epoch 数）小于 start_epoch（恢复的起始 epoch）：&lt;br&gt;
说明用户可能想继续微调（fine-tune）模型，因此将总 epoch 数调整为 原 epochs + 已训练的 epoch 数。&lt;br&gt;
例如：检查点已训练 50 个 epoch，用户设置 epochs=10，则实际总 epoch 数为 50 + 10 = 60。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;del ckpt, state_dict&lt;/code&gt;删除检查点 ckpt 和模型状态字典 state_dict，释放内存资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;image-size&#34;&gt;Image size&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743742131661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gs = int(model.stride.max())&lt;/code&gt;&lt;br&gt;
model.stride 是模型各层的下采样步长（如 [8, 16, 32]）。&lt;br&gt;
max() 取最大步长（如 32），并转换为整数 gs。&lt;br&gt;
作用：gs 表示特征图的最小网格尺寸（grid size），用于后续调整图像尺寸对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nl = model.model[-1].nl&lt;/code&gt;&lt;br&gt;
model.model[-1] 是模型的最后一层（检测头，如 Detect 层）。&lt;br&gt;
nl 是检测头的层数（YOLOv5 默认为 3，对应 3 种尺度的检测输出）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgsz, imgsz_test = [check_img_size(x, gs) for x in opt.img_size]&lt;/code&gt;&lt;br&gt;
opt.img_size 是用户设置的训练和测试图像尺寸（如 [640, 640]）。&lt;br&gt;
check_img_size(x, gs) 是一个函数，确保图像尺寸 x 是 gs 的整数倍（避免特征图尺寸出现小数）&lt;br&gt;
输出：&lt;br&gt;
imgsz：调整后的训练图像尺寸。&lt;br&gt;
imgsz_test：调整后的测试图像尺寸。&lt;br&gt;
假设 gs=32，用户设置 img_size=640：&lt;br&gt;
检查 640 % 32 == 0（满足条件，直接返回 640）。&lt;br&gt;
如果用户设置 img_size=641，则自动向下舍入到最近的合法值 640。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dp-model-数据并行data-parallelism&#34;&gt;DP model 数据并行（Data Parallelism）&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743742724927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
cuda：布尔值，表示是否启用 CUDA（即是否使用 GPU）。&lt;br&gt;
rank == -1：rank 是分布式训练的进程编号，-1 表示当前是非分布式训练（单机多 GPU）。&lt;br&gt;
torch.cuda.device_count() &amp;gt; 1：检测当前系统中可用的 GPU 数量是否大于 1。&lt;br&gt;
条件满足时：执行 DataParallel 包装，启用多 GPU 数据并行。&lt;/p&gt;
&lt;h1 id=&#34;syncbatchnorm-同步批归一化&#34;&gt;SyncBatchNorm 同步批归一化&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743743552701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
opt.sync_bn：布尔值，表示用户是否通过命令行参数 --sync-bn 显式启用了同步批归一化。&lt;br&gt;
cuda：布尔值，表示是否使用 GPU 训练。&lt;br&gt;
rank != -1：rank 是分布式训练的进程编号，-1 表示单机单 GPU 训练，非 -1 表示当前是分布式训练（如多 GPU 或多节点）&lt;/p&gt;
&lt;h1 id=&#34;ema-创建指数移动平均&#34;&gt;EMA 创建指数移动平均&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ema = ModelEMA(model) if rank in [-1, 0] else None&lt;/code&gt;&lt;br&gt;
ModelEMA(model):这是一个封装类，用于计算模型的指数移动平均（EMA）。&lt;br&gt;
EMA 是一种平滑模型参数的技术，可以减少训练过程中的波动，提升模型的泛化能力。&lt;br&gt;
它会维护一个影子模型（shadow model），在每次参数更新时，按一定衰减率（如 0.999）更新影子模型的参数。&lt;br&gt;
rank in [-1, 0]:rank 表示当前进程的编号，用于分布式训练（如 torch.distributed 或 multiprocessing）。&lt;br&gt;
rank = -1：单机单卡（非分布式训练）。&lt;br&gt;
rank = 0：分布式训练的主进程（负责日志、保存模型等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;trainloader-创建数据加载器&#34;&gt;Trainloader 创建数据加载器&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743744086944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
train_path：训练数据路径（如 data.yaml 中定义的路径）。&lt;br&gt;
imgsz：输入图像的尺寸（如 640）。&lt;br&gt;
batch_size：每个批次的样本数。&lt;br&gt;
gs：模型步长（grid size），用于确保图像尺寸能被 gs 整除。&lt;br&gt;
opt：命令行参数对象（包含超参数配置）。&lt;br&gt;
hyp：超参数字典（如学习率、数据增强参数等）。&lt;br&gt;
augment=True：启用数据增强（如翻转、缩放等）。&lt;br&gt;
cache=opt.cache_images：是否缓存图像到内存（加速后续训练）。&lt;br&gt;
rect=opt.rect：是否使用矩形训练（减少填充，提升效率）。&lt;br&gt;
rank：当前进程编号（分布式训练时使用）。&lt;br&gt;
world_size：总进程数（分布式训练时使用）。&lt;br&gt;
workers：数据加载的子进程数。&lt;br&gt;
image_weights：是否按样本权重采样（解决类别不平衡）。&lt;br&gt;
quad：是否使用四合一拼接数据增强（Mosaic 增强的变种）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mlc = np.concatenate(dataset.labels, 0)[:, 0].max()&lt;/code&gt;从数据集的标签中提取所有类别编号，并计算最大值 mlc（Max Label Class）。&lt;br&gt;
dataset.labels：数据集中所有图像的标签列表（每个标签的格式为 [class_id, x_center, y_center, width, height]）。&lt;br&gt;
np.concatenate(dataset.labels, 0)：将所有标签拼接成一个二维数组。&lt;br&gt;
[:, 0]：提取所有标签的类别编号（第 0 列）。&lt;br&gt;
.max()：计算类别编号的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;process-0&#34;&gt;process 0&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743746418878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plot_labels(labels, save_dir, loggers)&lt;/code&gt; 生成 labels.jpg 文件，显示类别频率和框的宽高比。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check_anchors(dataset, model=model, thr=hyp[&#39;anchor_t&#39;], imgsz=imgsz)&lt;/code&gt;&lt;br&gt;
根据训练数据集的标签，自动优化模型的锚框尺寸。&lt;br&gt;
hyp[&#39;anchor_t&#39;]：锚框匹配阈值（超参数，默认 4.0）。&lt;br&gt;
imgsz：输入图像尺寸。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;model-parameter&#34;&gt;model parameter&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743748552045.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hyp[&#39;cls&#39;] *= nc / 80. &lt;/code&gt;根据实际类别数 nc 调整分类损失权重 hyp[&#39;cls&#39;]（默认基于 COCO 数据集的 80 类）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hyp[&#39;obj&#39;] *= imgsz ** 2 / 640. ** 2 * 3. / nl&lt;/code&gt;根据输入图像尺寸 (imgsz) 和输出层数 (nl) 调整目标存在损失权重 hyp[&#39;obj&#39;]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;start-train&#34;&gt;start train&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743748923988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t0 = time.time()&lt;/code&gt; 记录训练开始的时间戳，用于后续计算总训练耗时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nw = max(round(hyp[&#39;warmup_epochs&#39;] * nb), 1000)&lt;/code&gt;确定学习率热身（Warmup）阶段的迭代次数。&lt;br&gt;
hyp[&#39;warmup_epochs&#39;]：热身轮次数（默认 3 轮）。&lt;br&gt;
nb：每个 epoch 的批次数量（len(dataloader)）。&lt;br&gt;
max(..., 1000)：至少热身 1000 次迭代（避免小数据集热身不足）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maps = np.zeros(nc)&lt;/code&gt;存储每个类别的 mAP（初始为 0）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;results = (0, 0, 0, 0, 0, 0, 0)&lt;/code&gt;&lt;br&gt;
初始化评估结果元组，包含：&lt;br&gt;
P：精确率（Precision）&lt;br&gt;
R：召回率（Recall）&lt;br&gt;
mAP@.5：IoU 阈值为 0.5 的 mAP&lt;br&gt;
mAP@.5-.95：IoU 阈值从 0.5 到 0.95 的平均 mAP&lt;br&gt;
val_loss：验证损失（边界框、目标存在、分类损失）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scheduler.last_epoch = start_epoch - 1&lt;/code&gt;设置学习率调度器的起始轮次,last_epoch 必须比当前轮次小 1，否则调度器会跳过第一轮调整。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler = amp.GradScaler(enabled=cuda)&lt;/code&gt; 启用混合精度训练,enabled=cuda：仅在 GPU 训练时启用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;update-image-weights-optional&#34;&gt;Update image weights (optional)&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743750030157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;mean-losses&#34;&gt;mean losses&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743750197725.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mloss = torch.zeros(4, device=device)&lt;/code&gt;初始化一个长度为 4 的张量，用于累积当前 epoch 的四种损失均值：&lt;br&gt;
mloss[0]：边界框损失（box_loss）&lt;br&gt;
mloss[1]：目标存在损失（obj_loss）&lt;br&gt;
mloss[2]：分类损失（cls_loss）&lt;br&gt;
mloss[3]：总损失（total_loss）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pbar = enumerate(dataloader)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info((&#39;\n&#39; + &#39;%10s&#39; * 8) % (&#39;Epoch&#39;, &#39;gpu_mem&#39;, &#39;box&#39;, &#39;obj&#39;, &#39;cls&#39;, ``&#39;total&#39;, &#39;targets&#39;, &#39;img_size&#39;))&lt;/code&gt;&lt;br&gt;
日志输出示例：&lt;br&gt;
Epoch   gpu_mem       box       obj      cls    total  targets  img_size&lt;br&gt;
gpu_mem：GPU 显存占用（GB）&lt;br&gt;
box/obj/cls/total：各项损失值&lt;br&gt;
targets：当前批次的目标数量&lt;br&gt;
img_size：图像尺寸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pbar = tqdm(pbar, total=nb)&lt;/code&gt;&lt;br&gt;
仅在主进程（单卡或 rank=0）显示进度条，避免多进程日志混乱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for i, (imgs, targets, paths, _) in pbar:&lt;/code&gt;&lt;br&gt;
imgs：批次的输入图像（形状为 [batch_size, 3, H, W]）&lt;br&gt;
targets：标注信息（形状为 [num_targets, 6]，每行格式为 [batch_index, class_id, x, y, w, h]）&lt;br&gt;
paths：图像文件路径（用于调试）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ni = i + nb * epoch&lt;/code&gt;累计迭代次数 ni：用于学习率热身和日志记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgs = imgs.to(device, non_blocking=True).float() / 255.0 &lt;/code&gt;&lt;br&gt;
.to(device)：将数据转移到 GPU（若 cuda=True）。&lt;br&gt;
non_blocking=True：异步传输，提升数据加载效率。&lt;br&gt;
/ 255.0：将像素值从 [0, 255] 归一化到 [0.0, 1.0]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;warm-up&#34;&gt;Warm up&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743751020247.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;accumulate = max(1, np.interp(ni, xi, [1, nbs / total_batch_size]).round())&lt;/code&gt;nbs：名义批次大小（nominal batch size，如 64）。&lt;br&gt;
total_batch_size：实际批次大小（单卡 batch_size × 卡数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;multi-scale&#34;&gt;Multi scale&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743753618364.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;forward-backward-optimize&#34;&gt;Forward Backward optimize&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743753942871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;with amp.autocast(enabled=cuda):&lt;/code&gt;启用自动混合精度（Automatic Mixed Precision, AMP）训练（如果CUDA可用），以减少显存占用并加速计算。amp.autocast：自动将部分操作转换为低精度（FP16），同时保持关键部分的精度（FP32）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pred = model(imgs)&lt;/code&gt;将输入图像 imgs 输入模型，得到预测结果 pred。&lt;br&gt;
model(imgs)：调用模型的前向传播方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loss, loss_items = compute_loss(pred, targets.to(device), model)&lt;/code&gt;计算损失函数，返回总损失 loss 和各部分损失项 loss_items。&lt;br&gt;
compute_loss：YOLOv5的损失函数，包括分类损失、边界框损失和置信度损失。&lt;br&gt;
targets.to(device)：将标注数据（目标）移动到与模型相同的设备（如GPU）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loss *= opt.world_size&lt;/code&gt;如果使用分布式训练（DDP模式），将损失乘以 world_size（GPU数量），以便后续梯度平均。&lt;br&gt;
rank：当前进程的排名（-1表示单机训练）。&lt;br&gt;
opt.world_size：参与训练的GPU总数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler.scale(loss).backward()&lt;/code&gt;使用梯度缩放（Gradient Scaling）执行反向传播。&lt;br&gt;
scaler.scale(loss)：在混合精度训练中，缩放损失值以避免梯度下溢。&lt;br&gt;
.backward()：计算梯度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if ni % accumulate == 0:&lt;/code&gt;每隔 accumulate 步（梯度累积步数）执行一次参数更新。&lt;br&gt;
ni：当前迭代次数。&lt;br&gt;
accumulate：梯度累积的步数（模拟更大的batch size）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler.step(optimizer)&lt;/code&gt;更新模型参数（优化器步进）。&lt;br&gt;
scaler.step：在混合精度训练中，先反缩放梯度，再调用 optimizer.step()。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler.update()&lt;/code&gt;调整梯度缩放因子（根据梯度动态调整缩放比例）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimizer.zero_grad()&lt;/code&gt;清空优化器的梯度缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ema.update(model)&lt;/code&gt;如果启用指数移动平均（EMA），更新EMA模型的参数。&lt;br&gt;
ema.update(model)：将当前模型的参数按一定权重（动量）更新到EMA模型中，用于提升模型泛化性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;print-plot&#34;&gt;Print plot&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743754685903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mloss = (mloss * i + loss_items) / (i + 1) &lt;/code&gt;计算并更新平均损失（mloss）。&lt;br&gt;
mloss：历史平均损失的滑动平均值。&lt;br&gt;
loss_items：当前批次的各项损失值（分类、边界框、置信度等）。&lt;br&gt;
i：当前批次索引（用于滑动平均计算）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem = &#39;%.3gG&#39; % (torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0)&lt;/code&gt;获取当前GPU显存占用（单位：GB）。&lt;br&gt;
torch.cuda.memory_reserved()：返回已分配的显存总量。&lt;br&gt;
1E9：转换为GB单位。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s = (&#39;%10s&#39; * 2 + &#39;%10.4g&#39; * 6) % (&#39;%g/%g&#39; % (epoch, epochs - 1), mem, *mloss, targets.shape[0], imgs.shape[-1])&lt;/code&gt;格式化训练日志字符串，包括：&lt;br&gt;
epoch/epochs-1：当前轮次/总轮次（如 1/300）。&lt;br&gt;
mem：显存占用。&lt;br&gt;
*mloss：展开平均损失值（分类、边界框、置信度等）。&lt;br&gt;
targets.shape[0]：当前批次的标注目标数量。&lt;br&gt;
imgs.shape[-1]：输入图像的尺寸（如 640）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pbar.set_description(s)&lt;/code&gt;更新进度条（tqdm）的显示信息，实时展示训练状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread(target=plot_images, args=(imgs, targets, paths, f), daemon=True).start()&lt;/code&gt;启动一个后台线程（Thread）调用 plot_images 函数，绘制当前批次的图像和标注框。&lt;br&gt;
imgs：输入图像张量。&lt;br&gt;
targets：标注数据（类别、边界框）。&lt;br&gt;
paths：图像文件路径（用于显示文件名）。&lt;br&gt;
daemon=True：线程随主进程退出而终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;模型评估-map&#34;&gt;模型评估 MAP&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743755712304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ema.update_attr(model, include=[&#39;yaml&#39;, &#39;nc&#39;, &#39;hyp&#39;, &#39;gr&#39;, &#39;names&#39;, &#39;stride&#39;, &#39;class_weights&#39;])&lt;/code&gt;&lt;br&gt;
如果启用了指数移动平均（EMA），则更新 EMA 模型的属性（如配置文件、类别数、超参数等），确保 EMA 模型与原始模型同步关键参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;final_epoch = epoch + 1 == epochs&lt;/code&gt;判断当前 epoch 是否是最后一个 epoch（epoch + 1 等于总 epoch 数 epochs）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if not opt.notest or final_epoch: &lt;/code&gt;如果未设置 --notest 参数（即需要测试）或当前是最终 epoch，则执行测试逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;results, maps, times = test.test&lt;/code&gt;调用 test.py 中的 test() 函数计算 mAP，传入以下参数：&lt;br&gt;
opt.data：数据集配置文件路径（如 data/coco.yaml）。&lt;br&gt;
batch_size：测试时的批次大小。&lt;br&gt;
imgsz：测试图像尺寸。&lt;br&gt;
model：使用 EMA 模型（如果启用）进行推理。&lt;br&gt;
single_cls：是否单类别检测（由 --single-cls 参数控制）。&lt;br&gt;
dataloader：测试数据加载器。&lt;br&gt;
save_dir：结果保存目录。&lt;br&gt;
plots：仅在最终 epoch 时生成评估图表（如 PR 曲线、混淆矩阵等）。&lt;br&gt;
log_imgs：如果启用 WandB 日志，记录测试图像数量（由 --log-imgs 控制）。&lt;br&gt;
输出结果：&lt;br&gt;
results：包含精度（precision）、召回率（recall）、mAP@0.5、mAP@0.5:0.95 等指标。&lt;br&gt;
maps：各类别的 mAP 值。&lt;br&gt;
times：推理耗时统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;writelogupdate-best-map&#34;&gt;Write/Log/Update best mAP&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743756299799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;with open(results_file, &#39;a&#39;) as f:&lt;/code&gt;results_file：存储评估结果的文本文件路径（如 runs/train/exp/results.txt）。&lt;br&gt;
&#39;a&#39; 模式：以追加（append）方式打开文件，保留历史记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f.write(s + &#39;%10.4g&#39; * 7 % results + &#39;\n&#39;)  # P, R, mAP@.5, mAP@.5-.95,&lt;/code&gt; &lt;code&gt;val_loss(box, obj, cls)&lt;/code&gt;&lt;br&gt;
&#39;%10.4g&#39; * 7 % results：将 results 中的 7 个数值格式化为固定宽度（10 字符）、4 位有效数字的浮点数。通常对应：&lt;br&gt;
Precision (P)&lt;br&gt;
Recall (R)&lt;br&gt;
mAP@0.5&lt;br&gt;
mAP@0.5:0.95&lt;br&gt;
验证损失（box, obj, cls）&lt;br&gt;
&#39;\n&#39;：换行符，确保每次写入的结果单独成行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if len(opt.name) and opt.bucket:&lt;/code&gt;opt.name：实验名称（非空时触发上传）。&lt;br&gt;
opt.bucket：GCS 存储桶名称（如 my-bucket）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.system(&#39;gsutil cp %s gs://%s/results/results%s.txt&#39; % (results_file, opt.bucket, opt.name))&lt;/code&gt;使用 gsutil cp 命令将本地文件 results_file 复制到 GCS 路径 gs://{bucket}/results/results{name}.txt。&lt;br&gt;
例如：若 opt.name=&#39;exp1&#39; 且 opt.bucket=&#39;my-bucket&#39;，文件会被上传到 gs://my-bucket/results/results_exp1.txt。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags =&lt;/code&gt;&lt;br&gt;
训练损失：&lt;br&gt;
train/box_loss（边界框回归损失）、&lt;br&gt;
train/obj_loss（目标置信度损失）、&lt;br&gt;
train/cls_loss（分类损失）。&lt;br&gt;
评估指标：&lt;br&gt;
metrics/precision（精度）&lt;br&gt;
metrics/recall（召回率）&lt;br&gt;
metrics/mAP_0.5（mAP@0.5）&lt;br&gt;
metrics/mAP_0.5:0.95（mAP@0.5:0.95）。&lt;br&gt;
验证损失：&lt;br&gt;
val/box_loss&lt;br&gt;
val/obj_loss&lt;br&gt;
val/cls_loss（与训练损失对应，但基于验证集计算）。&lt;br&gt;
学习率：&lt;br&gt;
x/lr0、x/lr1、x/lr2 分别对应优化器中不同参数组的学习率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for x, tag in zip(list(mloss[:-1]) + list(results) + lr, tags):&lt;/code&gt;&lt;br&gt;
mloss[:-1]：训练损失的均值（排除可能存在的额外统计项）。&lt;br&gt;
results：评估指标（如 precision、recall、mAP 等，来自 test.test() 的返回值）。&lt;br&gt;
lr：学习率列表（对应不同参数组）。&lt;br&gt;
通过 zip() 将数值 (x) 和标签 (tag) 一一配对。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tb_writer.add_scalar(tag, x, epoch)  # tensorboard&lt;/code&gt;将数值 x 记录到 TensorBoard，标签为 tag，横轴为 epoch。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fi = fitness(np.array(results).reshape(1, -1))&lt;/code&gt;&lt;br&gt;
results 是一个包含模型评估指标的列表（如精确度 P、召回率 R、mAP@0.5、mAP@0.5-0.95 等）。&lt;br&gt;
np.array(results).reshape(1, -1) 将 results 转换为一个 NumPy 数组，并调整形状为 (1, n)，其中 n 是原始 results 的长度。&lt;br&gt;
fitness() 是一个自定义函数，用于计算模型的适应度值。通常，适应度是这些指标的加权组合（如 0.1&lt;em&gt;P + 0.9&lt;/em&gt;R 或其他权重配置），用于综合评估模型性能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if fi &amp;gt; best_fitness:&lt;/code&gt;比较当前适应度 fi 和历史最佳适应度 best_fitness。&lt;br&gt;
如果当前适应度更高，说明模型性能有所提升。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;best_fitness = fi&lt;/code&gt;更新 best_fitness 为当前更高的适应度值 fi，用于后续比较和模型保存逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;save-model&#34;&gt;save model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743758099246.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;save = (not opt.nosave) or (final_epoch and not opt.evolve)&lt;/code&gt;根据命令行参数 opt.nosave 和训练阶段（是否最后一轮 final_epoch 或是否在超参数进化模式 opt.evolve）判断是否需要保存模型。&lt;br&gt;
opt.evolve：是否处于超参数进化模式（一种自动化调参方法）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(results_file, &#39;r&#39;) as f:&lt;/code&gt;读取训练结果文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743758433509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.save(ckpt, last)&lt;/code&gt;保存最后一次训练的模型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if best_fitness == fi:&lt;/code&gt;&lt;br&gt;
&lt;code&gt;torch.save(ckpt, best)&lt;/code&gt;条件 best_fitness == fi 表示当前模型的适应度（fi）达到了历史最佳（best_fitness）。如果当前适应度是历史最佳，额外保存为最佳模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;strip-optimizers-移除优化器&#34;&gt;Strip optimizers 移除优化器&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743759232020.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检查当前进程：仅在主进程（rank 为 -1 或 0）执行操作。&lt;br&gt;
选择最终模型：优先使用性能最佳的模型（best.pt），若不存在则使用最后一次训练的模型（last.pt）&lt;br&gt;
移除优化器状态：对 last.pt 和 best.pt 文件调用 strip_optimizer()，以减小文件体积。&lt;br&gt;
上传模型到云存储：如果指定了 Google Cloud Storage 的存储桶（opt.bucket），将最终模型上传。&lt;/p&gt;
&lt;h1 id=&#34;plots&#34;&gt;Plots&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743759838825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;test-bestpt&#34;&gt;Test best.pt&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743759888366.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logger.info(&#39;%g epochs completed in %.3f hours.\n&#39; % (epoch - start_epoch + 1, (time.time() - t0) / 3600))&lt;/code&gt;&lt;br&gt;
记录训练完成的 epoch 数量和总耗时。&lt;br&gt;
epoch - start_epoch + 1：计算实际训练的 epoch 数量（从 start_epoch 到当前 epoch）。&lt;br&gt;
(time.time() - t0) / 3600：将训练时间（秒）转换为小时，保留 3 位小数。&lt;br&gt;
通过 logger.info 输出日志，例如：&amp;quot;10 epochs completed in 2.345 hours.&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dist.destroy_process_group()&lt;/code&gt;&lt;br&gt;
在分布式训练（多 GPU/多节点训练）结束时，清理并释放进程组资源。&lt;br&gt;
如果训练时使用了 PyTorch 的分布式训练（如 torch.distributed），需要在训练结束后调用此函数，以避免资源泄漏或进程残留。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.cuda.empty_cache()&lt;/code&gt;&lt;br&gt;
释放 PyTorch 在 CUDA 设备（GPU）上未使用的缓存内存。&lt;br&gt;
在训练或推理过程中，PyTorch 会缓存一部分 GPU 内存以加速后续操作（如张量分配、计算等）。&lt;br&gt;
调用此函数会强制释放这些缓存，但不会影响已分配给张量的显存。&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计train.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-yolopy/"" data-c="
          &lt;h1 id=&#34;parser&#34;&gt;parser&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743327817787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;yolov5syaml&#34;&gt;yolov5s.yaml&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743328013437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743328052860.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743328086291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nc: 80  # number of classes&lt;/li&gt;
&lt;li&gt;depth_multiple: 0.33  # model depth multiple 模型深度倍数 和number有关，要乘&lt;/li&gt;
&lt;li&gt;width_multiple: 0.50  # layer channel multiple 层级通道倍数 和args有关，要乘&lt;/li&gt;
&lt;li&gt;yolov5s.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332256199.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;yolov5m.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332309256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;yolov5l.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332326243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;yolov5x.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332345639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
yolov5n.yaml、yolov5l.yaml、yolov5m.yaml、yolov5s.yaml、yolov5x.yaml只有这两个倍数变化，模型越复杂，倍数越大。&lt;/li&gt;
&lt;li&gt;[from, number, module, args]&lt;/li&gt;
&lt;li&gt;[-1, 1, Focus, [64, 3]&lt;br&gt;
from=-1:从上一层过来的&lt;/li&gt;
&lt;li&gt;[-1, 10], 1, Concat, [1]&lt;br&gt;
from=[-1,10]:从22层和10层过来&lt;/li&gt;
&lt;li&gt;[-1, 3, C3, [128]]&lt;br&gt;
number=3,第2层有3个C3模块&lt;/li&gt;
&lt;li&gt;module:&lt;br&gt;
conv:卷积层&lt;br&gt;
C3：&lt;br&gt;
SPP:&lt;br&gt;
nn.Upsample:&lt;br&gt;
Concat:&lt;br&gt;
Detect:&lt;/li&gt;
&lt;li&gt;args:给module传的参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743331344943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
0-P1/2：第一层，P1，640x640输入的RGB图像-》320x320输出&lt;br&gt;
1-P2/4：第二层，P2，640x640输入的RGB图像-》160x160输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;流程图fpn-pan&#34;&gt;流程图（FPN、PAN)&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743342494810.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;model&#34;&gt;Model&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743417145301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
cfg:配置文件&lt;br&gt;
ch：channels，RGB三通道&lt;br&gt;
nc：类别数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;self.yaml.get(&#39;ch&#39;, ch)&lt;/code&gt;   优先使用yaml配置，否则使用默认值ch，体现配置优先级。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m = self.model[-1]&lt;/code&gt;   获取模型最后一层，预期为Detect层。YOLOv5 的检测头。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if isinstance(m, Detect):&lt;/code&gt;  确认最后一层是否为Detect类的实例，确保后续操作仅对检测头执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; s = 256  # 2x min stride&lt;/code&gt; 设定基准输入尺寸 256x256（通常为最小下采样步长 stride 的 2 倍，用于计算特征图缩放比例）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m.stride&lt;/code&gt; 通过前向传播一个 1xchx256x256 的零张量，获取各检测层的输出特征图尺寸。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m.anchors /= m.stride.view(-1, 1, 1)&lt;/code&gt; 将锚框尺寸归一化到特征图尺度（除以对应层的 stride）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743419153523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialize_weights(self)&lt;/code&gt;初始化模型所有层的权重参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.info()&lt;/code&gt; 打印模型的结构摘要信息（如层数、参数数量、梯度占比等）。&lt;br&gt;
输出内容：&lt;br&gt;
各层的名称、类型、输入/输出维度。&lt;br&gt;
总参数量（可训练/不可训练）。&lt;br&gt;
浮点运算量（FLOPs）估算（如果实现）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(&#39;&#39;)&lt;/code&gt; 输出一个空行到日志，用于分隔模型初始化日志与其他后续日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;前向传播&#34;&gt;前向传播&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743420773667.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743421285880.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
x:输入图像张量&lt;br&gt;
augment:是否启用数据增强（多尺度+翻转）&lt;br&gt;
profile:是否启用性能分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;forward_once:单次前向传播&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y, dt = [], []  # outputs&lt;/code&gt;&lt;br&gt;
y:存储每一层的输出结果。&lt;br&gt;
dt: 在性能分析模式下（profile=True），记录每一层的计算耗时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for m in self.model:&lt;/code&gt; 遍历模型的所有层&lt;/li&gt;
&lt;li&gt;m.f:表示当前层 m 的输入来源（默认为 -1，即来自前一层的输出）。&lt;br&gt;
如果 m.f 是整数（如 3），直接从 y[3] 获取输入（跳层连接）。&lt;br&gt;
如果 m.f 是列表（如 [2, 4, -1]），拼接多个层的输出作为输入（多分支结构）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;fuse&#34;&gt;fuse&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743422569569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
融合卷积层（Conv2d）和批归一化层（BatchNorm2d），目的是优化模型的计算效率&lt;br&gt;
遍历模型的所有模块：for m in self.model.modules() 会遍历模型中的每一层。&lt;br&gt;
检查模块类型：if type(m) is Conv and hasattr(m, &#39;bn&#39;) 判断当前模块是否是 Conv 类型（自定义的卷积层类），并且是否包含 bn（批归一化层）属性。&lt;br&gt;
融合卷积和批归一化：调用 fuse_conv_and_bn(m.conv, m.bn) 将卷积层和批归一化层的参数合并为一个新的卷积层，并更新 m.conv。&lt;br&gt;
移除批归一化层：delattr(m, &#39;bn&#39;) 删除原来的批归一化层。&lt;br&gt;
更新前向传播方法：m.forward = m.fuseforward 将前向传播方法替换为融合后的版本（&lt;br&gt;
fuseforward是专门为融合后的层设计的方法）。&lt;br&gt;
打印模型信息：self.info() 输出融合后的模型结构信息。&lt;/p&gt;
&lt;h1 id=&#34;nmsnon-maximum-suppression非极大值抑制&#34;&gt;NMS(Non-Maximum Suppression，非极大值抑制)&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743423006177.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;mode 参数：&lt;br&gt;
mode=True：表示需要添加 NMS 模块。&lt;br&gt;
mode=False：表示需要移除 NMS 模块。&lt;/li&gt;
&lt;li&gt;present 变量：&lt;br&gt;
检查模型的最后一层是否是 NMS 类型（type(self.model[-1]) is NMS）。&lt;br&gt;
如果最后一层已经是 NMS，present 为 True；否则为 False。&lt;/li&gt;
&lt;li&gt;添加 NMS 模块（if mode and not present）：&lt;br&gt;
如果 mode=True 且当前模型没有 NMS 模块（not present），则执行以下操作：&lt;br&gt;
创建一个新的 NMS() 模块实例 m。&lt;br&gt;
设置 m.f = -1（通常表示该模块的来源层，-1 可能表示“无”或“自动”）。&lt;br&gt;
设置 m.i 为当前最后一层的索引 +1（确保新模块的索引正确）。&lt;br&gt;
使用 add_module 方法将 NMS 模块添加到模型的末尾。&lt;br&gt;
调用 self.eval() 将模型切换到推理模式（因为 NMS 通常在推理时使用）。&lt;/li&gt;
&lt;li&gt;移除 NMS 模块（elif not mode and present）：&lt;br&gt;
如果 mode=False 且当前模型包含 NMS 模块（present），则执行以下操作：&lt;br&gt;
直接通过切片 self.model[:-1] 移除最后一层（即 NMS 模块）。&lt;/li&gt;
&lt;li&gt;训练时：通常不需要 NMS，可以调用 model.nms(False) 移除 NMS 模块。&lt;/li&gt;
&lt;li&gt;推理时：需要 NMS 过滤冗余检测框，可以调用 model.nms(True) 添加 NMS 模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;info打印&#34;&gt;info打印&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def info(self, verbose=False, img_size=640):  model_info(self, verbose, img_size)&lt;/code&gt;&lt;br&gt;
self: 表示该方法属于某个类（通常是YOLOv5的模型类）。&lt;br&gt;
verbose=False: 一个布尔参数，控制是否打印详细信息。默认为 False，即只打印基本信息。&lt;br&gt;
img_size=640: 输入图像的尺寸，默认为 640（YOLOv5的默认输入分辨率）。&lt;br&gt;
调用 model_info(self, verbose, img_size) 函数，将当前模型实例、verbose 标志和 img_size 传递给它。&lt;br&gt;
model_info 函数的作用是分析模型的结构和参数，并打印相关信息，例如：&lt;br&gt;
模型的层数、参数数量、计算量（FLOPs）。&lt;br&gt;
各层的详细信息（如果 verbose=True）。&lt;br&gt;
输入尺寸对模型的影响。&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计yolo.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji/"" data-c="
          &lt;h1 id=&#34;opt-parserparse_args&#34;&gt;opt = parser.parse_args()&lt;/h1&gt;
&lt;p&gt;---解析命令行参数的代码&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743255463863.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
---运行结果：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743255507270.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
---解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parser = argparse.ArgumentParser():parser是通过argparse.ArgumentParser()创建的一个命令行参数解析器对象。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.parse_args()：ArgumentParser()解析命令行传入的参数，将命令行输入的参数转换为一个namespace对象。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opt = parser.parse_args():将解析后的参数存储在变量opt中，可以通过print(opt.weights)等访问。如果没有传递函数，parser.add_argument(&#39;--demo&#39;, action=&#39;store_true&#39;, help=&#39;&#39;),运行print(opt.demo)结果为False。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parser.add_argument(&#39;--img-size&#39;, type=int, default=640, help=&#39;inference size (pixels)&#39;)命令行参数为img-size，但是运行会被转化为img_size，访问时要用print(opt.img_size)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;torchno_grad&#34;&gt;torch.no_grad()&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743257318494.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;with torch.no_grad():使用pytorch的no_grad上下文管理器，禁用梯度计算，减少内存占用。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;webcam&#34;&gt;webcam&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;webcam = source.isnumeric() or source.endswith(&#39;.txt&#39;) or source.lower().startswith((&#39;rtsp://&#39;, &#39;rtmp://&#39;, &#39;http://&#39;))&lt;/code&gt;&lt;br&gt;
------通过逻辑判断确定输入源 source 是否为以下类型之一：&lt;br&gt;
------摄像头设备：source.isnumeric() 为 True 表示摄像头索引（如 0 表示默认摄像头）。&lt;br&gt;
------视频文件列表：source.endswith(&#39;.txt&#39;) 为 True 表示输入是一个文本文件，内含多个视频/图像路径（每行一个路径）。&lt;br&gt;
------网络视频流：source.lower().startswith(...) 检查是否以流媒体协议（如 rtsp://、rtmp://、http://）开头。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.isnumeric判断source是否由数字构成，返回布尔值True或者False。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;save_dir&#34;&gt;save_dir&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;save_dir = Path(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok)):生成一个自动递增的、唯一的保存目录路径。&lt;/code&gt;&lt;br&gt;
------Path(opt.project) / opt.name：将命令行参数 opt.project（主项目目录，如 runs/detect）和 opt.name（自定义实验名称，如 exp）拼接成路径（如 runs/detect/exp）。&lt;br&gt;
------increment_path，处理路径冲突。如果 runs/detect/exp 已存在，则自动重命名为 runs/detect/exp2、runs/detect/exp3 等（避免覆盖）。exist_ok=opt.exist_ok：若 opt.exist_ok 为 True，则允许目录已存在（不递增）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(save_dir / &#39;labels&#39; if save_txt else save_dir).mkdir(parents=True, exist_ok=True)&lt;/code&gt;&lt;br&gt;
------如果 save_txt 为 True：创建 save_dir/labels 子目录（用于保存检测结果的文本文件，如 YOLO 格式的 .txt 标注文件）。如果 save_txt 为 False：直接创建 save_dir 目录（仅保存图像/视频结果）。parents=True：自动创建父目录（如 runs/detect/exp 不存在时会一并创建）。&lt;br&gt;
exist_ok=True：目录已存在时不报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;device&#34;&gt;device&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;device = select_device(opt.device):根据用户输入的 opt.device 参数选择运行设备（CPU 或 GPU）。‘cpu&#39;：强制使用 CPU。  &#39;0&#39; 或 &#39;cuda:0&#39;：使用第一块 GPU。  &#39;&#39;（空字符串）：自动选择可用设备（优先 GPU）。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;half = device.type != &#39;cpu&#39;:half=True：仅在 GPU（CUDA）上启用 FP16，可加速推理并减少显存占用。half=False：在 CPU 上强制使用 FP32（单精度），因为 CPU 对 FP16 支持不佳。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;model&#34;&gt;model&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;model = attempt_load(weights, map_location=device)  # load FP16 model 加载模型权重文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgsz = check_img_size(imgsz, s=model.stride.max()) #检查用户指定img_size是否满足模型要求，默认stride=32,imgsz为32的倍数，640或者672&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if half: model.half()  # to FP16 #根据device选择GPU可知half=True,加载FP16.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;classify&#34;&gt;classify&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;classify = False if classify: modelc = load_classifier(name=&#39;resnet101&#39;, n=2)  # initialize modelc.load_state_dict(torch.load(&#39;weights/resnet101.pt&#39;, map_location=device)[&#39;model&#39;]).to(device).eval()&lt;/code&gt;&lt;br&gt;
---设置一个布尔标志 classify，默认为 False，表示不启用分类功能。&lt;br&gt;
------若需启用分类（如同时执行检测和分类任务），需手动改为 True 或通过命令行参数控制。&lt;br&gt;
---检查是否启用分类功能。若为 True，则执行以下操作：&lt;br&gt;
------加载预训练的分类模型（如 ResNet101）。&lt;br&gt;
------将分类模型与检测模型结合使用（YOLOv5 默认仅做检测，分类是可选扩展功能）。&lt;br&gt;
---这段代码为 YOLOv5 提供了扩展能力，可在目标检测后对检测到的物体进行二次分类（例如检测车辆后进一步分类为“卡车”或“轿车”）。默认不启用，因为 YOLOv5 主要聚焦于检测任务，分类需额外数据和模型支持。&lt;br&gt;
---分类模型与检测模型的区别：&lt;br&gt;
------检测模型（YOLOv5）：输出边界框和类别（如“狗”）。&lt;br&gt;
------分类模型（ResNet）：对裁剪后的区域进行细粒度分类（如“哈士奇” vs “金毛”）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;是否为实时流&#34;&gt;是否为实时流&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743301191381.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
---vid_path：用于存储当前处理的 视频文件路径（如 data/video.mp4），初始化为 None 表示尚未加载任何视频。&lt;br&gt;
---vid_writer：用于存储 视频写入器对象（如 OpenCV 的 VideoWriter），初始化为 None 表示尚未创建写入器。&lt;br&gt;
---当输入源是视频文件或摄像头时，代码会动态更新这两个变量：&lt;br&gt;
------vid_path 记录当前视频路径（用于逻辑判断或调试信息）。&lt;br&gt;
------vid_writer 初始化视频写入器，用于将检测结果保存为新的视频文件。&lt;br&gt;
---if webcam: 判断输入源是否为实时流&lt;br&gt;
---view_img = True 若输入是实时流，强制开启实时显示（view_img 设为 True），便于用户观察摄像头或视频流的检测结果。&lt;br&gt;
---cudnn.benchmark = True 启用 CuDNN 的自动优化模式，加速固定尺寸图像的推理。&lt;br&gt;
适用于实时流场景（图像尺寸通常不变），通过自动选择最优卷积算法提升 GPU 计算效率。&lt;br&gt;
---dataset = LoadStreams(source, img_size=imgsz) 使用 LoadStreams 类加载实时流数据：&lt;br&gt;
------source：摄像头索引（如 0）或流地址（如 rtsp://example.com）。&lt;br&gt;
------img_size：图像缩放尺寸（如 640）。&lt;br&gt;
------LoadStreams 会以多线程方式持续读取帧，并返回迭代器（每项包含帧数组、原始帧、路径等）&lt;br&gt;
---dataset = LoadImages(source, img_size=imgsz)使用 LoadImages 类加载静态文件数据：&lt;br&gt;
------source：文件路径（如 data/image.jpg）或包含多个路径的文本文件。&lt;br&gt;
------img_size：图像缩放尺寸。&lt;br&gt;
------LoadImages 返回迭代器，逐个处理文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据加载器差异：&lt;/li&gt;
&lt;li&gt;LoadStreams：专为实时流设计，支持多线程读取，适合高帧率处理。&lt;/li&gt;
&lt;li&gt;LoadImages：针对文件处理，单线程顺序读取，适合批量处理图像/视频。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;name-colors&#34;&gt;name、colors&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;names = model.module.names if hasattr(model, &#39;module&#39;) else model.names&lt;/code&gt;&lt;br&gt;
names根据weights权重文件变。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colors = [[random.randint(0, 255) for _ in range(3)] for _ in names]&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743302176449.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
colors随机分配，从0到255&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;warmup&#34;&gt;warmup&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; t0 = time.time()&lt;/code&gt;&lt;br&gt;
记录当前时间戳 t0，通常用于后续计算总耗时（如预处理+推理+后处理的总时间）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = torch.zeros((1, 3, imgsz, imgsz), device=device)  # init img&lt;/code&gt;&lt;br&gt;
创建一个全零的张量作为虚拟输入图像。&lt;br&gt;
形状 (1, 3, imgsz, imgsz)：&lt;br&gt;
1：批大小（batch size为1）。&lt;br&gt;
3：通道数（RGB图像）。&lt;br&gt;
imgsz：图像的高度和宽度（必须是模型支持的输入尺寸，如640x640）。&lt;br&gt;
device=device：将张量放置在指定设备（如 cuda:0 或 cpu）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; _ = model(img.half() if half else img) if device.type != &#39;cpu&#39; else None  # run once&lt;/code&gt;&lt;br&gt;
执行一次虚拟推理（预热模型）。&lt;br&gt;
img.half() if half else img：&lt;br&gt;
如果 half=True（启用半精度FP16推理），将输入转换为 torch.float16；否则保持 torch.float32。&lt;br&gt;
if device.type != &#39;cpu&#39;：&lt;br&gt;
仅在GPU设备上执行预热（CPU无需预热，因为无CUDA初始化开销）。&lt;br&gt;
_ = ...：&lt;br&gt;
忽略输出结果（因为仅是预热，无需处理输出）。&lt;/li&gt;
&lt;li&gt;作用：&lt;br&gt;
1、避免首次推理延迟：GPU首次执行某些操作时（如CUDA内核加载）会有额外开销。预热后，后续推理速度更稳定。&lt;br&gt;
2、半精度（FP16）适配：&lt;br&gt;
如果启用 half 模式，确保模型和输入数据精度一致。&lt;br&gt;
3、设备兼容性：&lt;br&gt;
跳过CPU的预热（因其无显著初始化延迟）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dataset&#34;&gt;dataset&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743312246958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for path, img, im0s, vid_cap in dataset:&lt;/code&gt;&lt;br&gt;
从 dataset 中逐项读取数据，每次迭代返回：&lt;br&gt;
path：图像/视频文件的路径。&lt;br&gt;
img：预处理后的图像（NumPy数组，通常为缩放后的尺寸，如640x640）。&lt;br&gt;
im0s：原始图像（未缩放，用于后续可视化）。&lt;br&gt;
vid_cap：视频捕获对象（若输入是视频）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = torch.from_numpy(img).to(device)&lt;/code&gt;&lt;br&gt;
将NumPy数组 img 转为PyTorch张量Tensor，并移动到指定设备（如GPU或CPU）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315972669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315981240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315993501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = img.half() if half else img.float()  # uint8 to fp16/32&lt;/code&gt;&lt;br&gt;
根据 half 标志选择精度：&lt;br&gt;
half=True：转为半精度（torch.float16，适合GPU加速）。&lt;br&gt;
half=False：转为单精度（torch.float32，默认）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img /= 255.0  # 0 - 255 to 0.0 - 1.0&lt;/code&gt;&lt;br&gt;
将像素值从 [0, 255] 范围归一化到 [0.0, 1.0]，符合模型输入要求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;        if img.ndimension() == 3: img = img.unsqueeze(0)&lt;/code&gt;&lt;br&gt;
若输入张量是3维（[C, H, W]），则添加批次维度变为4维（[1, C, H, W]），因为模型预期输入为批处理形式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;时间戳&#34;&gt;时间戳&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t0 = time.time()&lt;/code&gt;&lt;br&gt;
Python 标准库 time 中的一个函数，返回当前时间的时间戳（以秒为单位，从 Unix 纪元（1970年1月1日）开始计算的浮点数）。t0 记录了代码执行到这一行时的时刻，后续可以通过 t1 = time.time() 计算时间差（t1 - t0），从而统计某段代码的运行时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t1 = time_synchronized()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t2 = time_synchronized()&lt;/code&gt;&lt;br&gt;
time.time() 是纯 CPU 时间，不处理 GPU 同步，因此在涉及 GPU 计算（如深度学习模型推理）时可能不够准确。time_synchronized()（自定义函数）通常会先同步 GPU 操作，适合需要精确测量 GPU 加速任务的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;pred&#34;&gt;pred&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pred = model(img, augment=opt.augment)[0]&lt;/code&gt;&lt;br&gt;
model：训练好的目标检测模型（如 YOLOv5）。&lt;br&gt;
img：输入的图像数据（通常是经过预处理的张量）。&lt;br&gt;
augment=opt.augment：是否启用测试时数据增强（Test-Time Augmentation, TTA），由配置参数 opt.augment 控制（例如翻转、缩放等增强操作）。模型可能返回多个输出（如检测结果、特征图等），这里通过 [0] 取第一个输出，即检测结果的预测张量（包含边界框、置信度、类别等信息）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;非极大值抑制nms&#34;&gt;非极大值抑制NMS&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pred = non_max_suppression(pred, opt.conf_thres, opt.iou_thres, classes=opt.classes, agnostic=opt.agnostic_nms)&lt;/code&gt;&lt;br&gt;
non_max_suppression：非极大值抑制（NMS），用于去除冗余的检测框。&lt;br&gt;
pred：模型输出的预测结果。&lt;br&gt;
opt.conf_thres：置信度阈值，低于此值的预测会被过滤。&lt;br&gt;
opt.iou_thres：交并比（IoU）阈值，用于判断框之间的重叠程度。&lt;br&gt;
classes=opt.classes：指定要保留的目标类别。&lt;br&gt;
agnostic=opt.agnostic_nms：是否进行类别无关的NMS（即跨类别抑制）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;应用分类器apply-classifier&#34;&gt;应用分类器Apply Classifier&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pred = apply_classifier(pred, modelc, img, im0s)&lt;/code&gt;&lt;br&gt;
apply_classifier：应用分类器，对检测结果进行进一步的类别细化或调整。&lt;br&gt;
pred：经过非极大值抑制（NMS）处理后的预测结果。&lt;br&gt;
modelc：分类器模型，用于对检测到的目标进行二次分类。&lt;br&gt;
img：输入图像的预处理形式（通常为归一化后的张量）。&lt;br&gt;
im0s：原始图像（未预处理的格式），可能用于可视化或辅助分类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;过程分类&#34;&gt;过程分类&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315025215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for i, det in enumerate(pred): &lt;/code&gt;遍历 pred（预测结果），i 是索引，det 是当前检测到的目标信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; if webcam:&lt;/code&gt;判断输入是否为摄像头（webcam 模式），如果是，则处理多帧图像（batch_size &amp;gt;= 1）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p, s, im0, frame = ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;摄像头模式：&lt;br&gt;
path[i]：当前帧的路径。&lt;br&gt;
&#39;%g: &#39; % i：格式化字符串，标记当前帧序号。&lt;br&gt;
im0s[i].copy()：复制当前帧图像（避免修改原始数据）。&lt;br&gt;
dataset.count：帧计数器。&lt;/li&gt;
&lt;li&gt;非摄像头模式：&lt;br&gt;
path：单张图像或视频文件的路径。&lt;br&gt;
&#39;&#39;：空字符串（无帧标记）。&lt;br&gt;
im0s：原始图像数据。&lt;br&gt;
getattr(dataset, &#39;frame&#39;, 0)：获取 dataset 的 frame 属性（默认为 0）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;p-pathp&#34;&gt;p = Path(p)&lt;/h1&gt;
&lt;p&gt;使用 Python 的 pathlib.Path 将字符串路径 p 转换为 Path 对象，以便更方便地处理文件路径操作（如拼接、解析等）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315802639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;save_path = str(save_dir / p.name)  # img.jpg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;txt_path = str(save_dir / &#39;labels&#39; / p.stem) + (&#39;&#39; if dataset.mode == &#39;image&#39; else f&#39;_{frame}&#39;)  # img.txt&lt;/code&gt;&lt;br&gt;
save_path 是保存检测结果图片的路径（如 img.jpg）。&lt;br&gt;
txt_path 是保存检测标签文本的路径（如 img.txt），如果是图像模式（dataset.mode == &#39;image&#39;），文件名直接使用 p.stem；否则（如视频模式），会在文件名后追加帧号 _{frame}。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s += &#39;%gx%g &#39; % img.shape[2:]  # print string&lt;/code&gt;&lt;br&gt;
将图像的宽度和高度（img.shape[2:]）格式化为字符串（如 &amp;quot;640x480&amp;quot;），并追加到字符串 s 中。&lt;br&gt;
%g 是 Python 的格式化占位符，自动选择较短的浮点数或整数表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # normalization gain whwh&lt;/code&gt;&lt;br&gt;
将原始图像 im0 的形状（(H, W, C) 或 (H, W)）转换为 PyTorch 张量，并重新排列为 [W, H, W, H]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;缩放尺寸&#34;&gt;缩放尺寸&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if len(det):              # Rescale boxes from img_size to im0 size   det[:, :4] = scale_coords(img.shape[2:], det[:, :4], im0.shape).round()&lt;/code&gt;&lt;br&gt;
如果检测结果 det 非空（len(det) &amp;gt; 0），则执行以下操作：调用 scale_coords 函数，将边界框坐标从模型输入尺寸（img.shape[2:]，即 [height, width]）缩放到原始图像尺寸（im0.shape）&lt;br&gt;
.round() 对缩放后的坐标进行四舍五入取整，确保边界框坐标为整数像素值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;print&#34;&gt;print&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743316642245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
遍历检测结果 det 中的每个唯一类别索引 c。&lt;br&gt;
统计属于当前类别 c 的检测框数量 n。&lt;br&gt;
将类别名称（从 names 列表中获取）和对应的数量格式化为字符串（如 &amp;quot;3 cars, &amp;quot;），并追加到变量 s 中。&lt;br&gt;
最终 s 会包含类似 &amp;quot;3 cars, 2 persons, &amp;quot; 的统计信息。&lt;/p&gt;
&lt;h1 id=&#34;write-results&#34;&gt;write results&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743317759145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
遍历检测结果：逆序处理检测结果 det，解包每个检测框的坐标 xyxy、置信度 conf 和类别 cls。&lt;br&gt;
坐标转换：将 xyxy（左上右下坐标）转换为 xywh（中心点坐标+宽高）并归一化（除以 gn）。&lt;br&gt;
格式组装：根据配置 opt.save_conf 决定是否在输出行中包含置信度 conf。&lt;br&gt;
写入文件：以追加模式打开文件，将数据格式化为空格分隔的字符串（如 &amp;quot;0 0.5 0.5 0.2 0.2 0.9&amp;quot;）并写入。&lt;br&gt;
条件判断：检查是否需要保存图像（save_img）或实时显示图像（view_img）。&lt;br&gt;
生成标签：组合类别名称（从 names 列表获取）和置信度（格式化为两位小数），例如 &amp;quot;car 0.95&amp;quot;。&lt;br&gt;
绘制检测框：调用 plot_one_box 函数，在原始图像 im0 上绘制矩形框：&lt;br&gt;
使用 xyxy 坐标指定框的位置。&lt;br&gt;
使用 colors[int(cls)] 根据类别索引选择颜色。&lt;br&gt;
设置框的线条粗细为 3 像素。&lt;/p&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计detect.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/layout/"" data-c="
          &lt;h1 id=&#34;高速信号布线&#34;&gt;高速信号布线&lt;/h1&gt;
&lt;p&gt;1、走线长度，尽量短。&lt;br&gt;
2、避免打孔换层。&lt;br&gt;
3、高速信号的回流地要完整。&lt;br&gt;
4、要包地处理，减少干扰或被干扰。&lt;br&gt;
5、高速走线不能有锐角和直角，尽量弧度。&lt;br&gt;
6、阻抗匹配：&lt;br&gt;
------阻抗匹配就是指在信号传输中的源端、传输线、负载端之间的阻抗相等。阻抗匹配目的是为了防止信号反射，保证信号的完整性。如果阻抗不匹配，信号就会在源端和阻抗不匹配点之间来回反射，可能导致信号衰减、失真。&lt;br&gt;
7、阻抗匹配方法：&lt;br&gt;
------有串联电阻匹配或并联电阻匹配，可以放在源端或负载端，根据实际信号要求来选择电阻大小，一般是用于低频信号；&lt;br&gt;
------有阻抗匹配网络设计，如Π网络、LC网络等，一般是用于高速信号，比如WIFI模组的RF走线上的匹配网络（WIFI模组和天线之间）。&lt;br&gt;
8、EMC\EMI设计：&lt;br&gt;
A、关键的高速信号和时钟信号要进行包地，要有完整的回流路径；&lt;br&gt;
B、时钟信号上串的RC要放在源端，要包地良好及提供完整的回流路径；&lt;br&gt;
C、预留在接口座子上的走线小电容，要靠近端子放置。这个小电容方便调试，不同电容值，其谐振频率不一样，可滤除不同频率，解决辐射问题。也可以用小电容来解决ESD问题（ESD采用的电容容值，也是利用电容的谐振频率来计算的）。&lt;br&gt;
D、有飞线的接口座子，尽量放在板边，避免飞线跨过高速信号或时钟信号。&lt;br&gt;
E、DCDC要使得提供电流的两个回流路径尽量短。&lt;br&gt;
F、对于高速信号的传输线的阻抗要有明确的要求，比如HDMI走线100欧姆、USB走线90欧姆、RF走线50欧姆、MIPI走线100欧姆等。小系统DDR部分走线的单端阻抗50欧姆或差分阻抗100欧姆，但要参考原厂的Demo要求，有的并不是50欧姆或100欧姆。&lt;br&gt;
G、如有屏蔽罩的话，屏蔽罩与PCB板上的地铜皮接触要尽量多，且多打地过孔。&lt;/p&gt;
">Layout</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dian-li-dian-zi-ji-zhu/"" data-c="
          &lt;p&gt;1、电力二极管：&lt;br&gt;
静态特性：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740066190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态特性：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740108888.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主要类型：普通二极管、快恢复二极管、肖特基二极管&lt;br&gt;
2、压敏电阻&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740142505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、共模电感&lt;br&gt;
也叫共模扼流圈，共模电感是一个以铁氧体为磁芯的共模干扰抑制器件，它由两个尺寸相同，匝数相同的线圈对称地绕制在同一个铁氧体环形磁芯上，形成一个四端器件，要对于共模信号呈现出大电感具有抑制作用，而对于差模信号呈现出很小的漏电感几乎不起作用。原理是流过共模电流时磁环中的磁通相互叠加，从而具有相当大的电感量，对共模电流起到抑制作用，而当两线圈流过差模电流时，磁环中的磁通相互抵消，几乎没有电感量，所以差模电流可以无衰减地通过。因此共模电感在平衡线路中能有效地抑制共模干扰信号，而对线路正常传输的差模信号无影响。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740185140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740192026.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4、滤波电路&lt;br&gt;
电容滤波&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740234802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图2(b)为电容滤波电路。由于电容 C1 对直流电相当于开路，这样整流电路输出的直流电压不能通过C1 到地，只有加到负载 RL 图为 RL 上。对于整流电路输出的交流成分，因 C1 容量较大，容抗较小，交流成分通过 C1 流到地端，而不能加到负载 RL。这样，通过电容 C1 的滤波， 从单向脉动性直流电中取出了所需要的直流电压 +U。滤波电容 C1 的容量越大，对交流成分的容抗越小，使残留在负载 RL 上的交流成分越小，滤波效果就越好。&lt;br&gt;
电感滤波&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740268142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于整流电路输出的交流成分，因 L1 电感量较大，感抗较大，对交流成分产生很大的阻碍作用，阻止了交流电通过 C1 流到加到负载 RL。这样，通过电感 L1 的滤波，从单向脉动性直流电中取出了所需要的直流电压 +U。滤波电感 L1 的电感量越大，对交流成分的感抗越大，使残留在负载 RL 上的交流成分越小，滤波效果就越好，但直流电阻也会增大。&lt;br&gt;
pi型RC滤波&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740300171.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
(1)这一电路的滤波原理是：从整流电路输出的电压首先经过 C1 的滤波，将大部分的交流成分滤除，然后再加到由 R1 和 C2 构成的滤波电路中。C2 的容抗与 R1 构成一个分压电路，因 C2 的容抗很小，所以对交流成分的分压衰减量很大，达到滤波目的。对于直流电而言，由于 C2 具有隔直作用，所以 R1 和 C2 分压电路对直流不存在分压衰减的作用，这样直流电压通过 R1 输出。&lt;br&gt;
(2)在 R1 大小不变时，加大 C2 的容量可以提高滤波效果，在 C2 容量大小不变时，加大 R1 的阻值可以提高滤波效果。但是，滤波电阻 R1 的阻值不能太大，因为流过负载的直流电流要流过 R1，在 R1 上会产生直流压降，使直流输出电压 Uo2 减小。R1 的阻值越大，或流过负载的电流越大时，在 R1 上的压降越大，使直流输出电压越低。&lt;br&gt;
(3)C1 是第一节滤波电容，加大容量可以提高滤波效果。但是 C1 太大后，在开机时对 C1 的充电时间很长，这一充电电流是流过整流二极管的，当充电电流太大、时间太长时，会损坏整流二极管。所以采用这种 π 型 RC 滤波电路可以使 C1 容量较小，通过合理设计 R1 和 C2 的值来进一步提高滤波效果。&lt;br&gt;
(4)这一滤波电路中共有 3 个直流电压输出端，分别输出 Uo1、Uo2 和 Uo3 三组直流电压。其中，Uo1 只经过电容 C1 滤波;Uo2 则经过了 C1、 R1 和 C2 电路的滤波，所以滤波效果更好，Uo2 中的交流成分更小;Uo3 则经过了 2 节滤波电路的滤波，滤波效果最好，所以 Uo3 中的交流成分最少。&lt;br&gt;
(5)3 个直流输出电压的大小是不同的。Uo1 电压最高，一般这一电压直接加到功率放大器电路，或加到需要直流工作电压最高、工作电流最大的电路中;Uo2 电压稍低，这是因为电阻 R1 对直流电压存在电压降;Uo3 电压最低，这一电压一般供给前级电路作为直流工作电压，因为前级电路的直流工作电压比较低，且要求直流工作电压中的交流成分少。&lt;br&gt;
pi型LC滤波电路&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740337737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在图 5 的电路中，整流电路输出的单向脉动性直流电压先经电容 C1 滤波，去掉大部分交流成分，然后再加到 L1 和 C2 滤波电路中。&lt;br&gt;
对于交流成分而言，L1 对它的感抗很大，这样在 L1 上的交流电压降大，加到负载上的交流成分小。&lt;br&gt;
对直流电而言，由于 L1 不呈现感抗，相当于通路，同时滤波电感采用的线径较粗，直流电阻很小，这样对直流电压基本上没有电压降，所以直流输出电压比较高，这是采用电感滤波器的主要优点。&lt;/p&gt;
">电力电子技术</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/fan-ji-kai-guan-dian-yuan/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739261573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739266954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739272011.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739277085.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
保险丝：电流过大时烧坏，保护后级电路。&lt;br&gt;
压敏电阻：过压保护，电压过高时短路，烧坏保险丝，保护后级电路。&lt;br&gt;
NTC：负温度系数的热敏电阻，瞬间电流过大时，防止浪涌电流。&lt;br&gt;
共模电感：也叫共模扼流圈，共模电感是一个以铁氧体为磁芯的共模干扰抑制器件，它由两个尺寸相同，匝数相同的线圈对称地绕制在同一个铁氧体环形磁芯上，形成一个四端器件，要对于共模信号呈现出大电感具有抑制作用，而对于差模信号呈现出很小的漏电感几乎不起作用。原理是流过共模电流时磁环中的磁通相互叠加，从而具有相当大的电感量，对共模电流起到抑制作用，而当两线圈流过差模电流时，磁环中的磁通相互抵消，几乎没有电感量，所以差模电流可以无衰减地通过。因此共模电感在平衡线路中能有效地抑制共模干扰信号，而对线路正常传输的差模信号无影响。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739300591.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回路面积要尽可能小&lt;br&gt;
从理论上（即假设电容为纯电容）说，电容越大，阻抗越小，通过的频率也越高。 但实际上超过1μF 的电容大多为电解电容，有很大的电感成份，所以频率高后反而阻抗会增大。 有时会看到有一个电容量较大电解电容并联了一个小电容，这时大电容通低频，小电容通高频。 电容的作用就是通高阻低，通高频阻低频。 电容越小低频越容易通过，电容越大高频越容易通过&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739330738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
两个回路面积要小&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739353848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回路面积要小&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739378366.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
负载电阻：空载运行设备容易坏。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739404865.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4脚和6脚走线不能挨在一起，反馈信号属于敏感信号，驱动信号属于干扰信号。隔地。&lt;br&gt;
R26和R22靠近MOS管，不能把310V高电压带到U1.&lt;br&gt;
C18：给C18充电，SENSE检测电流。&lt;br&gt;
R22:当MOS管关断的时候,拉低栅极,避免误触发.&lt;br&gt;
R27:图中的 R27 是一个 1Ω、功率为 2W 的电阻，它主要起到电流采样的作用。在 MOS 开关电路工作时，负载电流会流经 R27，根据欧姆定律，R27 两端会产生与电流成正比的电压降。这个电压信号可以被 OCP 电路（过功率保护电路）检测到，当电流过大，即 R27 两端电压达到一定阈值时，OCP 电路会触发保护动作，关断 MOS 管，从而防止电路因过流而损坏 。&lt;br&gt;
OCP 电路即过流保护（Over - Current Protection）电路.&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739445525.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
D4、R15加速开关管关断。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739470736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Y电容：热地、冷地。&lt;br&gt;
Y电容和光耦靠近变压器（一上一下）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739496647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当MOS管关断的时候，变压器1脚接到D3，流过电阻R5继续回到变压器。&lt;br&gt;
R5\D3\C3靠近变压器布局。&lt;br&gt;
R7\R3\R9R布局靠近310V高压。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739519526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单点接地：MOS管的HGND、Y电容的HGND、主芯片的地，分别接到整流桥后面大电容的地。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739546507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
● 电压采样：电阻 R25 和 R32 组成分压电路，对输出电压进行采样，将采样后的电压送入 TL431 的参考端。当输出电压变化时，采样电压也随之改变。&lt;br&gt;
● 基准比较与放大：TL431 是一个精密的可调基准源，内部会将采样电压与 2.5V 的基准电压进行比较。若采样电压偏离设定值，TL431 会调整其输出电流，从而改变通过光耦 PC1B 中发光二极管的电流。&lt;br&gt;
● 光耦隔离与反馈：光耦 PC1B 起到电气隔离作用，其内部发光二极管的发光强度随通过电流变化，进而控制光耦中光敏晶体管的导通程度。通过光耦的反馈，将输出电压的变化信息传递到前级控制电路，实现对输出电压的调节，保持输出电压稳定。&lt;br&gt;
● 其他元件作用：电容 C20 与电阻 R31 组成 RC 网络，可对信号进行滤波和相位补偿，防止电路产生振荡；电阻 R21 用于限制通过光耦发光二极管的电流；R24 在光耦部分起到一定的限流和保护作用 。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739612978.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739619891.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
高压低压电气隔离4.6mm&lt;br&gt;
爬电距离6.4mm&lt;br&gt;
火线和零线、普通线之间2mm&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739644447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
开槽增大爬电距离&amp;gt;0.8mm&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739668657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回路面积尽可能小&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739693693.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导流槽，不能直接铺上去&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739811036.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739817502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739822669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739827577.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739834711.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739841218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
红胶工艺：竖着摆。&lt;br&gt;
https://blog.csdn.net/qq_33559992/article/details/121118817&lt;/p&gt;
">反激开关电源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/kai-guan-dian-yuan/"" data-c="
          &lt;p&gt;1、全桥逆变电路：&lt;br&gt;
https://blog.csdn.net/qq_42078934/article/details/127140491&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738707629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2、半桥电路：&lt;br&gt;
https://blog.csdn.net/qq_42078934/article/details/127073851&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738762019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、PUSH-PULL推挽电路&lt;br&gt;
https://blog.csdn.net/chenyongxyzg/article/details/135678046&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738804465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4、FlyBack单管反激&lt;br&gt;
https://blog.csdn.net/qq_42945764/article/details/105026626&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738844436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5、Buck/Boost电路&lt;br&gt;
https://blog.csdn.net/qq_58845450/article/details/134695390&lt;br&gt;
6、Boost升压电路&lt;br&gt;
https://blog.csdn.net/m0_66099690/article/details/128687901&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738938807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
7、Buck降压电路&lt;br&gt;
https://blog.csdn.net/m0_66099690/article/details/128687901&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738992396.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739000442.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
8、电源防雷模块（11种）（压敏电阻、气体放电管）&lt;br&gt;
（1）、单相并联式防雷器：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739079471.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
正常工作的时候，压敏电阻两端之间的阻抗是非常大的，可以近似地看成是开路的（实际上存在着非常微小的漏电流，一般10-20uA）。一旦雷击能量来了，会有瞬间高压加载压敏电阻上，这个时候压敏电阻就会被击穿，呈现出非常低的阻抗。这个内阻在雷电这个能量源的内阻Re面前，相对来说非常小，那么根据电阻分压的原理压敏电阻上的电压就会非常小。压敏电阻和后级负载是并联关系，因为压敏电阻相对负载电阻来说也非常小，所以大量能量都是从压敏电阻流过，被压敏电阻吸收了。通过这样的方式，就实现了对负载的保护。&lt;/p&gt;
">开关电源：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/kuai-su-que-ding-2-ceng-dao-8-ceng-ban-de-die-ceng-she-ji/"" data-c="
          &lt;p&gt;元件面下面（第二层）为地平面，提供器件屏蔽层以及为顶层布线提供参考平面；敏感信号层应该与一个内电层相邻（内部电源/地层），利用内电层的大铜膜来为信号层提供屏蔽。电路中的高速信号传输层应该是信号中间层，并且夹在两个内电层之间。这样两个内电层的铜膜可以为高速信号传输提供电磁屏蔽，同时也能有效地将高速信号的辐射限制在两个内电层之间，不对外造成干扰。&lt;br&gt;
所有信号层尽可能与地平面相邻。&lt;br&gt;
尽量避免两信号层直接相邻；相邻的信号层之间容易引入串扰，从而导致电路功能失效。在两信号层之间加入地平面可以有效地避免串扰。&lt;br&gt;
主电源尽可能与其对应地相邻；&lt;br&gt;
对于母板的层排布，现有母板很难控制平行长距离布线，对于板级工作频率在50MHZ以上的（50MHZ以下的情况可参照，适当放宽），建议排布原则：&lt;br&gt;
● 元件面、焊接面为完整的地平面（屏蔽）；&lt;br&gt;
●无相邻平行布线层；&lt;br&gt;
●所有信号层尽可能与地平面相邻；&lt;br&gt;
●关键信号与地层相邻，不跨分割区。&lt;br&gt;
多个接地的内电层可以有效地降低接地阻抗。例如，A信号层和B信号层采用各自单独的地平面，可以有效地降低共模干扰。&lt;br&gt;
对于两层板来说，由于板层数量少，已经不存在叠层的问题。控制EMI辐射主要从布线和布局来考虑；单层板和双层板的电磁兼容问题越来越突出。造成这种现象的主要原因就是因是信号回路面积过大，不仅产生了较强的电磁辐射，而且使电路对外界干扰敏感。要改善线路的电磁兼容性，最简单的方法是减小关键信号的回路面积。关键信号：从电磁兼容的角度考虑，关键信号主要指产生较强辐射的信号和对外界敏感的信号。能够产生较强辐射的信号一般是周期性信号，如时钟或地址的低位信号。对干扰敏感的信号是指那些电平较低的模拟信号。单、双层板通常使用在低于10KHz的低频模拟设计中:1）在同一层的电源走线以辐射状走线，并最小化线的长度总和；2）走电源、地线时，相互靠近；在关键信号线边上布一条地线，这条地线应尽量靠近信号线。这样就形成了较小的回路面积，减小差模辐射对外界干扰的敏感度。当信号线的旁边加一条地线后，就形成了一个面积最小的回路，信号电流肯定会取道这个回路，而不是其它地线路径。3）如果是双层线路板，可以在线路板的另一面，紧靠近信号线的下面，沿着信号线布一条地线，一线尽量宽些。这样形成的回路面积等于线路板的厚度乘以信号线的长度。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738404172.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
SIG －GND(PWR－) PWR (GND－) SIG；2. GND－SIG(PWR)－SIG(PWR)－GND；对于以上两种叠层设计，潜在的问题是对于传统的1.6mm（62mil ）板厚。层间距将会变得很大，不仅不利于控制阻抗，层间耦合及屏蔽；特别是电源地层之间间距很大，降低了板电容，不利于滤除噪声。对于第一种方案，通常应用于板上芯片较多的情况。这种方案可得到较好的SI 性能，对于EMI性能来说并不是很好，主要要通过走线及其他细节来控制。主要注意：地层放在信号最密集的信号层的相连层，有利于吸收和抑制辐射；增大板面积，体现20H规则。对于第二种方案，通常应用于板上芯片密度足够低和芯片周围有足够面积( 放置所要求的电源覆铜层) 的场合。此种方案PCB的外层均为地层，中间两层均为信号 / 电源层。信号层上的电源用宽线走线，这可使电源电流的路径阻抗低，且信号微带路径的阻抗也低，也可通过外层地屏蔽内层信号辐射。从EMI控制的角度看， 这是现有的最佳4 层PCB结构。主要注意：中间两层信号、电源混合层间距要拉开，走线方向垂直，避免出现串扰；适当控制板面积，体现20H规则；如果要控制走线阻抗，上述方案要非常小心地将走线布置在电源和接地铺铜岛的下边。另外，电源或地层上的铺铜之间应尽可能地互连在一起，以确保DC和低频的连接性。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738439044.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于芯片密度较大、时钟频率较高的设计应考虑6 层板的设计，推荐叠层方式：1.SIG－GND－SIG－PWR－GND－SIG；对于这种方案，这种叠层方案可得到较好的信号完整性，信号层与接地层相邻，电源层和接地层配对，每个走线层的阻抗都可较好控制，且两个地层都是能良好的吸收磁力线。并且在电源、地层完整的情况下能为每个信号层都提供较好的回流路径。&lt;br&gt;
2.GND－SIG－GND－PWR－SIG －GND；对于这种方案，该种方案只适用于器件密度不是很高的情况，这种叠层具有上面叠层的所有优点，并且这样顶层和底层的地平面比较完整，能作为一个较好的屏蔽层来使用。需要注意的是电源层要靠近非主元件面的那一层，因为底层的平面会更完整。因此， EMI性能要比第一种方案好。小结：对于六层板的方案, 电源层与地层之间的间距应尽量减小，以获得好的电源、地耦合。但62mil 的板厚, 层间距虽然得到减小, 还是不容易把主电源与地层之间的间距控制得很小。对比第一种方案与第二种方案，第二种方案成本要大大增加。因此，我们叠层时通常选择第一种方案。设计时，遵循20H规则和镜像层规则设计。&lt;br&gt;
案例：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738531485.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738536538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">快速确定2层到8层板的叠层设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dian-yuan-fen-ge/"" data-c="
          &lt;p&gt;a) 小电源优先在信号层铺铜，其次通过满足载流的走线连接；&lt;br&gt;
b) 12V、5V 电源如果是开关电源的输入电源，优先在信号层处理掉（表层、内层信号层），如果一定要在平面层分割，不要用作重要信号线的参考平面；这样可以有效减小此类“高”压对信号的影响；&lt;br&gt;
c) 如果分割出的电源平面用作信号的参考平面，电源平面优先作为用电模块的信号参考平面；如果有多个电源，优先参考电压低的电源；例如DDR3，使用的是1.5V 电源，则1.5V 电源平面可以用作DDR3 模块的信号参考平面，但尽量不要参考3.3V 电源或者其他电源；（通常DDR3 数据参考地平面，地址控制信号参考电源平面）&lt;br&gt;
d) 电源平面和地平面紧相邻，如果电源平面相邻的是信号层，尽量在信号层多补一些GND 铜，并打GND 过孔；&lt;br&gt;
e) 分割线宽度要合理；分割线宽度和两个电源的电压差有关，一般推荐：模数之间分割宽度：25mil；数字之间分割宽度15mil，局部可以更小一些；分割线宽度也可以根据板上空间情况灵活调整，原则上越大越好；&lt;br&gt;
f) 机壳地分割隔离宽度优先2mm，局部根据情况调整，一般要求不小于1mm；其他信号远离机壳地，包括信号线、过孔、铺铜等；&lt;br&gt;
l）确认电源、地能承载足够的电流，过孔数量是否满足承载要求。&lt;br&gt;
（估算方法：外层铜厚1oz时1A/mm线宽，内层0.5A/mm线宽）&lt;br&gt;
2）为降低平面的边缘辐射效应，在电源层与地层间要尽量满足20H原则。&lt;br&gt;
（条件允许的话，电源层的缩进得越多越好）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737904115.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737963448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737986392.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738021528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738029138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738070600.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738078148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738126994.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738167536.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738173345.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738179190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">电源分割</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ge-xing-ye-de-pcb-she-ji-gui-fan/"" data-c="
          &lt;p&gt;1、铝基板PCB设计：&lt;br&gt;
铝基板往往应用於功率器件，功率密度大，所以铜箔比较厚。如果使用到3oz以上的铜箔，厚铜箔的 蚀刻加工需要工程设计线宽补偿，否则，蚀刻後线宽就会超差。 铝基板的铝基面在PCB加工过程中必须事先用保护膜给予保护，否则，一些化学药品会浸蚀铝基面， 导致外观受损。且保护膜极易被碰伤，造成缺口，这就要求整个PCB加工过程必须插架。 玻纤板锣板使用的铣刀硬度比较小，而铝基板使用的铣刀硬度大。加工过程中生产玻纤板铣刀转速快， 而生产铝基板至少慢了三分之二。 电脑铣边玻纤板只是使用机器本身的散热系统散热就可以了，但是加工铝基板就必须另外的针对锣头 加酒精散热。&lt;br&gt;
2、嵌入式PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
3、工控类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
4、消费类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
5、汽电类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
6、高频类PCB设计：&lt;br&gt;
射频走线建议：&lt;br&gt;
尽可能使用四层板，模块和天线之间的射频 PCB 走线，需要进行50Ω阻抗控制，且长度尽量短。射频线周围要用接地铜箔包裹，接地铜箔距离射频线的间距要求为 2 倍射频线线宽以上，接地铜箔要多打接地过孔，保证接地阻抗尽量小。为减小RF 焊盘较大导致寄生电容较大而引起的天线性能降低的可能性，模块射频焊盘下第一层和第二层都建议挖空。双层板无法控制阻抗，所以在双层板走线时，尽量把射频线走短（弧线），然后线宽在30&lt;sub&gt;40mil，走线到周围地铜箔距离在1&lt;/sub&gt;1.5 倍线宽之间。建议采用周边的地铜箔作为参考平面，根据走线到地铜箔的间距以及走线线宽来计算阻抗（也可以要求板厂做50 欧姆阻抗匹配，因为阻抗也跟材质有关——介电常数）。一般推荐采用π型滤波，即串联一个电感，在电感两端并联1 个到地电容，在不需要进行匹配时，可以不焊电容，将电感用0 欧姆电阻替代。如果经过较长走线，则中间需要增加匹配网络，如下图所示。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737755182.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
7、通信类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
8、军工类PCB设计：&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;/p&gt;
">各行业的PCB设计规范</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/conda-ming-ling-xing/"" data-c="
          &lt;p&gt;conda --version 查看conda的版本&lt;br&gt;
conda config --show  查看conda的环境配置&lt;br&gt;
#设置清华镜像&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/&lt;br&gt;
#设置bioconda&lt;br&gt;
conda config --add channels bioconda&lt;br&gt;
conda config --add channels conda-forge&lt;br&gt;
#设置搜索时显示通道地址&lt;br&gt;
conda config --set show_channel_urls yes&lt;br&gt;
conda env list 查看conda的环境&lt;br&gt;
conda activate env 激活环境&lt;br&gt;
conda deactivate  退出环境&lt;br&gt;
conda remove --name env_name --all 删除指定环境&lt;br&gt;
conda remove --name env_name package_name删除环境中的指定包&lt;br&gt;
conda create -n env_name python=3.9 创建环境&lt;br&gt;
conda info 查看当前环境&lt;/p&gt;
">conda命令行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/xteminal-ming-ling-xing/"" data-c="
          &lt;p&gt;ssh 192.168.31.143 连接树莓派&lt;br&gt;
su - root 进入root&lt;br&gt;
vncserver-virtual 启动vncserver&lt;br&gt;
改变虚拟界面分辨率&lt;br&gt;
sudo raspi-config&lt;br&gt;
vncserver-virtual -geometry 1920x1080&lt;br&gt;
vncserver-virtual -kill :1结束虚拟界面&lt;br&gt;
scp mzc@192.168.31.143:/E:... /home/&lt;/p&gt;
">Xteminal命令行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/yolo-chuang-jian-huan-jing-ming-ling-xing/"" data-c="
          &lt;p&gt;1、conda create -n XXX(环境名）python=X.X(该环境中希望安装的python版本。  --yolo -python3.9&lt;br&gt;
2、conda activate yolo --进入创建的虚拟环境&lt;br&gt;
3、conda list --查看环境配置&lt;br&gt;
4、conda install cudnn==8.1.0&lt;br&gt;
5、cmd命令：&lt;br&gt;
cd /    回到根目录&lt;br&gt;
cd ../  回到上一级目录&lt;br&gt;
进入某一目录：直接D:或者E:&lt;br&gt;
6、pip install -r requirements.txt&lt;br&gt;
7、conda info --envs  查看创建的虚拟环境路径&lt;br&gt;
8、报错：&lt;br&gt;
ckagesNotFoundError: The following packages are not available from current channels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;torchvision==0.10.0+cu111&lt;/li&gt;
&lt;li&gt;torch==1.9.0+cu111&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Current channels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge&lt;/li&gt;
&lt;li&gt;defaults&lt;/li&gt;
&lt;li&gt;https://repo.anaconda.com/pkgs/main&lt;/li&gt;
&lt;li&gt;https://repo.anaconda.com/pkgs/r&lt;/li&gt;
&lt;li&gt;https://repo.anaconda.com/pkgs/msys2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To search for alternate channels that may provide the conda package you&#39;re&lt;br&gt;
looking for, navigate to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://anaconda.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and use the search bar at the top of the page.&lt;br&gt;
解决：在该链接https://anaconda.org下搜索&lt;br&gt;
9、pillow和pytorch、numpy版本问题，安装卸载使用pip，不用conda，解决。&lt;br&gt;
10、安装pyqt：&lt;br&gt;
pip install PyQt5&lt;br&gt;
pip install pyqt5-tools -i https://pypi.tuna.tsinghua.edu.cn/simple&lt;br&gt;
11、conda create -n XXX --clone yolo5   复制已有环境&lt;br&gt;
12、conda env list  查看创建的环境&lt;br&gt;
13、conda config --show channels 查看源&lt;br&gt;
14、conda config --remove channels https:// 删除源&lt;br&gt;
15、conda clean --all 清除缓存&lt;br&gt;
16、conda config --add channels ... 添加源&lt;br&gt;
17、nvcc --version 查看CUDA版本&lt;br&gt;
18、watch -n 1 nvidia-smi 查看GPU使用情况&lt;br&gt;
19、dwebp input.webp -o output.png 将webp文件转换为png文件&lt;br&gt;
20、conda env remove -n myenv 删除环境&lt;/p&gt;
">Yolo创建环境命令行：</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>