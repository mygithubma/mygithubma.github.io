<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="路漫漫其修远兮，吾将上下而求索。">
<meta name="theme-color" content="#495057">
<title>电平 | 仙道枫的博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1771130437796">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="电平" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>仙道枫的博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">寄蜉蝣于天地 渺沧海之一粟。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://lzmhc.top:8081/" target="_blank">
                  <i class="fa fa-globe"></i> 天空之城
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">枫</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">128</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://mygithubma.github.io/dian-ping/"> 电平 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2025-08-09 10:13:54">2025-08-09</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >1<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >1<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p>LVPECL</p>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      枫
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://mygithubma.github.io/dian-ping/" title="电平">https://mygithubma.github.io/dian-ping/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="ESD" href="https://mygithubma.github.io/esd/">ESD</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="ESD" href="https://mygithubma.github.io/esd/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Linux命令行" href="https://mygithubma.github.io/linux-ming-ling-xing/">Linux命令行</a>
        <a class="nav-mobile-next" title="Linux命令行" href="https://mygithubma.github.io/linux-ming-ling-xing/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\custom-bgImg.jpg" />
              </div>
              
                
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ZG0ta_c8yu/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1770835536593.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击sigrity_eda_dir&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770835581807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
确保此处只有对应版本的一个目录，若存在不同的多个，会报错&lt;/p&gt;
">Sigrity Aurura - 点击Set up Default Models无反应，环境变量配置无误</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/oKhImbt8mm/"" data-c="
          &lt;p&gt;用Aurora打开brd文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770812249878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择Design Setup Workflow&lt;br&gt;
点击Set up Default Models&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770812379667.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单端信号仿真&lt;br&gt;
cds:cadence sigrity&lt;br&gt;
in/out/bi:&lt;br&gt;
1p2v:1.2V;DDR的VDD&lt;br&gt;
1pf：c load&lt;br&gt;
noterm：没有终端电阻&lt;br&gt;
40：driver&lt;br&gt;
按照上图设置好模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770812561865.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
切换为Topology ectraction workflow&lt;br&gt;
select net选择一条网络&lt;/p&gt;
">Sigrity Topology Workbench+Aurora 仿真DDR Tx-Rx眼图</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/h9osNET9uq/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1770560721204.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击options&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770560766057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770786937371.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以DDR的MA0-16&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770786992854.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770787128272.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770787185830.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DDR的地址线，走flyby拓扑&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770810400934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在拓扑里面重新连线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770810609424.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点update constraint manager&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770810701665.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770810663836.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在规则里面已导入设置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770810846983.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770810893956.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Sigrity Topology Workbench-flyby拓扑结构导入allegro</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/l6HcrEpte8/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1769237314452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导入dra封装时，该dra封装的焊盘pad采用了flash symbol，首先找到封装名为MBTB_S440，打开该封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769237456026.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769237489360.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双击NR37D37&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769237533039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到名为TH67的Flash name&lt;br&gt;
按照这里的尺寸制作一个Flash symbol&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769237676403.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769237855520.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不做负片的话，可以不做Flash 焊盘，直接修改NR37D37焊盘&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769238220843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后进入dra封装refresh一下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769238267795.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1769238579344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在PCB界面refresh一下padstack，就能重新放进去了&lt;/p&gt;
">Allegro导入网表报错找不到flash symbol</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/QhrOCKa_JP/"" data-c="
          &lt;ul&gt;
&lt;li&gt;PDN设计&lt;br&gt;
电源分配网络设计&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768733588371.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开PowerTree软件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768733944998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新建Powertree&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768734126611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择Allegro Schematic netlist folder时，需要导入从原理图导出的Netlist&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768734272440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开options&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768734399020.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
弹出Starting Componments界面&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768734928012.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先配置VDD的电源输入=1.2V，J1&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768735001029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768735827341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770528884652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
配置每个DCDC或者LDO芯片&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770528937676.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导出csv文件保存&lt;br&gt;
点击OK，检查后点击build tree&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770529006189.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770529300598.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击这个切换背景&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770529979613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770530015983.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">Sigrity Aurora仿真-PowerTree文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cUfMOwWpWJ/"" data-c="
          &lt;p&gt;分配给PWR Net电压值&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768732384568.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768732820976.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Start&lt;br&gt;
导入PowerTree文件,点击start simulink&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1770530920025.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Sigrity Aurora仿真-IR Drop</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/GFPRYnuXgp/"" data-c="
          &lt;p&gt;打开软件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768655561185.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择Pspice A/D，然后选择Capture&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768655633746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768656012147.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击OK&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768656132173.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768656192029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768656226448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导出后报错信息&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768656309042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导出的文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768656351996.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
用Orcad打开OLB文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768656887607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新建Pspice&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768657444478.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加lib文件并设为全局&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768657569872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后就可以开始仿真&lt;/p&gt;
">IBIS模型添加到Orcad</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/yZD8TfUVmG/"" data-c="
          &lt;p&gt;设置方法和reflection一样，添加IBIS模型&lt;br&gt;
添加DC voltage，包括所有的GND、PGND、AGND等为0V&lt;br&gt;
打开Sigrity Aurora ,勾选&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1771068820208.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1771069119138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1771069284084.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1771069496602.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击start&lt;/p&gt;
">Sigrity Aurora仿真-Crosstalk串扰</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/44QbwZNUYh/"" data-c="
          &lt;p&gt;添加DC voltage，包括所有的GND、PGND、AGND等为0V&lt;br&gt;
前述操作和其他仿真类似&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加IBIS模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768664093249.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双击或者左下角点击&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768664177061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击...找到ibs文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768664213634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在ibis模型介绍中可以找到该IBIS模型对应的DDR颗粒类型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768664243397.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768664303544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768729681361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错了，查看日志&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768730957355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编辑IBS模型去掉&amp;quot;.&amp;quot;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768731448989.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不报错了&lt;br&gt;
有时候报ERROR (line    9) - File name opened &#39;27c256-1.ibs&#39; not the same as File_name &#39;at28c256e-15d.ibs&#39;.错误&lt;br&gt;
在IBIS模型中，前面几行会定义.ibs模型文件名，修改为一样重新导入&lt;br&gt;
这个错误通常出现在使用IBIS模型（一种用于模拟芯片输入/输出特性的标准文件格式）时。错误信息表明，在第9行，软件打开的文件名是 27c256-1.ibs，但文件内部声明的文件名却是 at28c256e-15d.ibs，两者不一致，导致校验失败。&lt;/li&gt;
&lt;/ul&gt;
">Sigrity Aurora仿真-Reflection反射</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/lTBB6N6-JR/"" data-c="
          &lt;p&gt;添加DC voltage，包括所有的GND、PGND、AGND等为0V&lt;br&gt;
相互平行的走线，在其中一条出现上升沿或者下降沿的时候，会在另一条平行的走线上感应出电压从而影响另一条走线的信号，解决方法为增大线之间的间距或者使其交错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768641001197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Tr=50ps，信号上升时间为50ps，可以修改&lt;br&gt;
Coupling Coefficient：2%，耦合系数小于2%的可以不用显示出来，可以忽略&lt;br&gt;
Geometry Window：0mm，走线旁边0mm以内的范围全部考虑&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768636221390.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置方法类似于前面的阻抗分析&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768636312952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看出这一段走线耦合很高，Net Name作为受害者，Aggressor Net Name为他的攻击者&lt;br&gt;
右边颜色条可以拉动，只显示范围内的coupling&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768636449659.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
S3和S4之间没有平面层隔离&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768636495887.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将这两条线间距加大，可见其耦合消失了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768636613674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
再挑选两条中间有平面层的走线，可见就算平行其也不会有耦合&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768637092082.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在这里还可以看到走线耦合是哪两层之间&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768637152087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Sigrity Aurora仿真-耦合分析 Coupling</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/yAfSxcZJjm/"" data-c="
          &lt;p&gt;添加DC voltage，包括所有的GND、PGND、AGND等为0V&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768631877412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768632032822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中需要仿真的信号,点击create&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768632162318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建好之后点击Start Analysis&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768633237101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768641757583.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
RPQF越接近1越好&lt;br&gt;
点击Start Simulation&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768633479273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择11层作为参考平面，点击View Return Path Visions&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768633650239.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
关闭所有Etch，在第11层能很明显看到一条走线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768633723898.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768633768540.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768633922900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
顶层的走线参考回流路径在第二层&lt;/p&gt;
">Sigrity Aurora仿真-返回路径 Return Path</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/6DXm4zDfNw/"" data-c="
          &lt;p&gt;打开PCB Editor，change editor到aurora&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768622568574.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻抗仿真&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768622679312.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加DC voltage，包括所有的GND、PGND、AGND等为0V&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768622862774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择Analysis Modes为Net Based，然后点击select nets&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768623195558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择网络，以DDR为例，ECC校验CB0-7，数据线DQ0-63，数据差分组DQS0-8，数据掩码DM0-7&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768623689111.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选好之后，Select Nets前面会出现绿色√&lt;br&gt;
下面的Set up Analysis Options可以不设&lt;br&gt;
点击Start Analysis等待分析完成后Save Analysis Results&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768624041174.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
保存完成后Save Analysis Results前面会出现绿色√&lt;br&gt;
点击view Impedance Tables会显示一个表格，其中对每一个网络的走线都是分小段进行显示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768624955594.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768625661398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
出现黄色或者绿色的表示阻抗出现突变&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768625793924.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以切换到View Impedance Visions&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768626121653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以根据颜色判断哪一段走线的阻抗突变&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768626602092.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768626631866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改一下铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768626730256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
重新Start Analysis&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768626832232.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见阻抗变连续&lt;/li&gt;
&lt;/ul&gt;
">Sigrity Aurora仿真-阻抗连续 Impedance</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/TqKzQvubtw/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1768319950117.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768320132838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768399598250.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768400001644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
放置发射端，鼠标右键点一下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768400146838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768400431790.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
搭建如图所示的模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768482782370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Sigrity-拓扑仿真工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/6mtyYMK0NJ/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1767798030428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使能GND和VCC网络，勾选此选项是：当有其他disable的网络，与仿真的电源铜皮重叠的时候，其平面间会形成电容效应，勾选后会自动考虑这些电容效应。&lt;br&gt;
仿真VCC和GND的阻抗&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767798210943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若板子比较大，可以切割出VCC部分的铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767798322286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在Layers栏里面，点击前面的小图标可以关闭那一层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767798528990.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767798687072.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767798786508.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以4_38V为例&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767881377365.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767881463325.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由原理图可看出该电源与GND之间有两个电容，分别是C54和C6&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767881558818.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在Sigrity中，模型这里该两个电容前面都有勾代表开路阻抗要仿真该电容的模型&lt;br&gt;
在右边属性栏下面可以看出电容的SPICE模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.PartialCkt 602433-081_22UF ExtNode =  1 2
C 1 2 22u
.EndPartialCkt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中第二行有值代表识别到正确的VALUE值，若未填写VALUE值则看不到第二行&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767881771428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
多个电容时，可以在文件路径下添加一个capmodel文件夹用于存放电容的SPICE参数模型或者S参数模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767881841967.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767882265425.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从该网站可以寻找电容的SPICE网表&lt;br&gt;
https://ds.murata.com/simsurfing/mlcc.html?lcid=zh-cn&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767882689670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767882862166.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767883282058.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在新建的ckt文件里面添加各自模型的SPICE参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*0.1UF_C0201
.PartialCkt 0p1UF_C0201 ExtNode =  1 2
C1 1 11 8.23e-8
L2 11 12 1.46e-10
R3 12 13 2.62e-2
C4 13 14 4.66e-6
R4 13 14 420
C5 14 15 6.29e-6
R5 14 15 59.3
C6 15 16 7.06e-6
R6 15 16 7.29
C7 16 17 6.14e-6
R7 16 17 1.16
C8 17 18 5.27e-6
R8 17 18 2.15e-1
C9 18 19 3.09e-6
R9 18 19 5.24e-2
L10 19 20 3.71e-11
R10 19 20 6.39
L11 20 21 1.61e-11
R11 20 21 1.75e-1
L12 21 22 4.70e-11
R12 21 22 7.48e-2
C13 22 2 7.22e-8
L13 22 2 2.88e-11
R13 22 2 1.61e-2
R100 1 11 5.00e+8
.EndPartialCkt

*22UF_C0603
.PartialCkt 22UF_C0603 ExtNode =  1 2
C1 1 11 1.51e-5
L2 11 12 1.94e-10
R3 12 13 2.48e-3
C4 13 14 1.12e-3
R4 13 14 2.13
C5 14 15 1.34e-3
R5 14 15 4.22e-1
C6 15 16 1.21e-3
R6 15 16 8.76e-2
C7 16 17 1.43e-3
R7 16 17 1.47e-2
C8 17 18 8.70e-4
R8 17 18 3.07e-3
L9 18 19 2.55e-11
R9 18 19 1.07e-1
L10 19 20 5.62e-11
R10 19 20 2.45e-2
L11 20 21 2.21e-10
R11 20 21 7.07e-3
L12 21 22 1.11e-10
R12 21 22 4.99e-3
C13 22 23 1.63e-4
L13 22 23 2.29e-11
R13 22 23 1.42e-3
C14 23 24 2.48e-5
L14 23 24 7.58e-11
R14 23 24 2.90e-3
C15 24 2 2.43e-11
L15 24 2 2.53e-11
R15 24 2 2.75
R100 1 11 2.27e+6
.EndPartialCkt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若是S参数模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.PartialCkt 602433-081_22UF ExtNode =  1 2
S1 1 2 3 2 Model=&amp;quot;S参数模型文件路径\模型文件名.s2p&amp;quot;
V 3 2 0
.EndPartialCkt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767883811347.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767886865447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
成功导入前面会有绿色的勾&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768140223042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意spice模型的参数需要核对正确&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置port&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768142924029.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
U45为电源芯片，若要设置U45芯片的所有GND引脚都为port的负端，选中U45，点击Generate port，芯片GND引脚会出现绿色的符号，port正端为4.38V&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768143118061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样，这个端口的配置就配置好了，电源的端口一般设置为0.1欧姆&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768143635221.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若port负端只用了芯片的部分引脚，可以通过箭头指向的选项来框选部分区域，然后点击Generate port&lt;br&gt;
设置仿真频率&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768143995993.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置CPU&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768144085260.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768145633895.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">Sigrity使用教程-AC开路阻抗</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/rCX1EVLPXK/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1767626724167.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767626813068.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-弧形走线</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/tvtNnxd3eL/"" data-c="
          &lt;ul&gt;
&lt;li&gt;SI仿真过孔处理&lt;br&gt;
在做SI仿真时&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767622707377.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
BGA扇出时，箭头所指的过孔由于过孔的焊盘，会在扇出的部分没有参考平面，在仿真是会报错，Sigrity设置了一种special voids&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767622860228.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767622950992.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767622986172.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击shape process&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767623059325.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如箭头所指，斜线表示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767623107985.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767623225122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
软件在仿真时，会默认此处有铜皮，但是实际上并无电气连接&lt;/li&gt;
&lt;li&gt;PI仿真&lt;br&gt;
PI仿真时，不希望出现special voids，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767623541638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改四个值为2mil&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767623687291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
shape process下，再显示special voids，可以看见没有斜线表示了&lt;/li&gt;
&lt;li&gt;自动显示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767623789620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选此选项，鼠标箭头指向哪里会自动显示当前的网络&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767623842309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767624353932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此处可设置两个过孔有重叠报错时可以融合为一个L形的过孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767624427350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767624689444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此处设置为90，表示走线模型为矩形&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767624850187.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置耦合关系，若要设置有一点点耦合就建立模型，可以设置上面为1%，下面为10ps&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767625092893.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此处可以看到耦合的参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767625426286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
自动保存&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767625588410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767625643109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
与此处同步&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767625852763.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767626078684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767626248447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767626368362.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
越小精度越高，可改为40mil&lt;/li&gt;
&lt;/ul&gt;
">Sigrity使用教程-VIA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/QH10XRgYfc/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1767450292573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其他设置参考频域仿真&lt;/p&gt;
">Sigrity使用教程-SpeedEM Generator时域仿真眼图</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/xN8GnhuiM-/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1767360600387.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开brd文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767360648421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
右下角Layer Selection可以选择PCB网络颜色&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767360774456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在Nets标签页下随机点在一个Net上右击鼠标，选择Disable All Nets&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767360857716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择Layers标签页，切换到需要仿真的层，鼠标箭头放到一组差分线上&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767360990122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767361035826.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检查叠层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767361114679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
电气层选择为COPPER，介质层可以选择FR-4或者FR4，点击右下角View Material可以查看各层的一些参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767361460563.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767366343133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
软件默认的1OZ COPPER和FR-4里面参数不全&lt;br&gt;
再进入到Pad Stack里面设置过孔焊盘&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767361861370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中焊盘，在plating thickness处填入1.4mil&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767362055028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在过孔添加1mil&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767362204458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DP0和DM0为一组&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767362501067.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若是有匹配电阻，两端应该是Xnet，需要先打散&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767362617518.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设存在电阻，打散差分线后，单独选中电阻前端和后端的net，选择merge，然后把另一个差分线也merge&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767362849181.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后选中GND&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767363341969.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建端口&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767363387025.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
按照软件默认创建&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767363642033.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
关闭该窗口&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767363716767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置截止频率为6Ghz&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767363827126.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击OK&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767363889449.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
保存，点击start&lt;br&gt;
S参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767364162348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
阻抗&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767364204825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
串扰&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767364240256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767364273937.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Sigrity仿真差分线</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/r6kzcH8fvw/"" data-c="
          &lt;ul&gt;
&lt;li&gt;PCB：printed circuit board。印制电路板。&lt;/li&gt;
&lt;li&gt;高速板材的基本参数&lt;br&gt;
DK：介电常数。一个充满电介质的电容器的电容C与真空电子容器的电容的比值。&lt;br&gt;
DF：损耗因子。&lt;br&gt;
导体损耗与表面粗糙度。&lt;br&gt;
玻纤效应。&lt;br&gt;
Low DK：传输线的阻抗与板材的DK、线宽（差分线线宽、间距）、到参考平面的距离以及铜厚有关。其中只有到参考平面的距离与阻抗成正比，板材的DK、线宽以及铜厚都与阻抗成反比。&lt;br&gt;
降低板材的DK后，可以通过增加线宽来维持对应的阻抗，增加线宽可以改善导体损耗。&lt;br&gt;
-软板&lt;br&gt;
FPC：flexible printed circuit，软性线路板、柔性印刷电路板。&lt;/li&gt;
&lt;/ul&gt;
">高速设计与板材</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/IIPU8LCj20/"" data-c="
          &lt;ul&gt;
&lt;li&gt;电源完整性&lt;br&gt;
在电源设计中，电压传到负载端，中间的传输导线不免会有电感存在，负载端的电流也不会是恒定值，变化的电流△I在路径上由电感产生感应的△U，这就是通常说的电源噪声。电流越大，△I越大，△U就会越大，包含噪声、纹波等。&lt;br&gt;
开关电源、线性稳压电源（LDO）&lt;br&gt;
LDO：低压差线性稳压，输入输出电压差值不能过大，效率低，大部分功耗消耗在其内部调整管的内阻，以发热的形式，因此LDO电源要铺铜散热。&lt;/li&gt;
&lt;li&gt;开关电源的布局&lt;br&gt;
1、开关管布局紧凑，考虑大电流通道，输入输出的地直连。&lt;br&gt;
2、输入滤波器件，紧邻开关管，确保大电流先滤波再进入开关管。&lt;br&gt;
3、输出滤波器件，紧邻开关管，确保大电流先滤波再进入单板平面。&lt;br&gt;
4、输入、输出回路，MOS管、续流管回路要尽量小。&lt;br&gt;
5、控制电路的比较电路，靠近控制芯片放置。&lt;br&gt;
6、控制电路的采样电路，采样电阻放在输出滤波与比较电路的中间，布局时保证采样电路尽量靠近芯片引脚和比较电路。&lt;br&gt;
7、控制电路本身的滤波网络、电容尽量靠近芯片引脚，且控制信号器件也尽量靠近芯片。&lt;br&gt;
-开关电源的布线&lt;br&gt;
1、开关管部分：尽量粗短，一般用铺铜实现，考虑大电流通道。&lt;br&gt;
2、输入、输出滤波：到电源平面的过孔数目和位置，输入过孔在滤波电容的前面，输出过孔在滤波电容的后面。&lt;br&gt;
3、输入、输出的地：用大铜皮连接到一起，多打地孔到平面。&lt;br&gt;
4、控制电路的地：模拟地、数字地分开，单点接地。&lt;br&gt;
5、控制电路的采样：模拟信号、采样点在输出滤波之后，如果有电流采样和电压采样，布成差分线的紧耦合形式，采样线尽量短，减少受干扰的空间。&lt;br&gt;
6、控制电路的调制输出：模拟信号不要在开关管下面走长线，远离大电流的电源和地等区域。&lt;/li&gt;
&lt;li&gt;过孔载流&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;过孔孔径&lt;/th&gt;
&lt;th&gt;温升（10℃）设计值(A)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10mil&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12mil&lt;/td&gt;
&lt;td&gt;1.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16mil&lt;/td&gt;
&lt;td&gt;1.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20mil&lt;/td&gt;
&lt;td&gt;1.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;24mil&lt;/td&gt;
&lt;td&gt;1.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40mil&lt;/td&gt;
&lt;td&gt;2.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80mil&lt;/td&gt;
&lt;td&gt;3.6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;交流电源的设计&lt;br&gt;
PDN：power delivery network，电源分配网络。&lt;br&gt;
目标阻抗的PDN设计：&lt;br&gt;
Z（target）={ U（powersupply）* X（allowed ripple）}  / △I(current)&lt;br&gt;
Z(target)：目标阻抗&lt;br&gt;
X(allowed ripple)：可允许电源噪声波动&lt;br&gt;
数学意义：只要真实的PDN阻抗不大于目标阻抗，同时电流的变化也不大于预设的△I，那么其电源噪声就不会超过允许的波动范围。&lt;br&gt;
例：电源1:2.5V，最大工作电流5A，电源2：1V，最大工作电流10A。&lt;br&gt;
由上述公司可计算电源1其PDN设计的目标阻抗是50mΩ；电源2为10mΩ。&lt;br&gt;
{2.5*10%} / 5 =50mΩ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电源噪声和纹波&lt;br&gt;
由电源开关频率所产生的波动，定义为电源纹波。&lt;br&gt;
由芯片切换所产生的波动，定义为电源噪声。&lt;br&gt;
开关电源的开关频率正常是几百千赫兹到2MHz，因此，在测试电源纹波时，为了避免引入其他不必要的噪声，建议示波器的带宽限制为20MHz。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">电源设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/gao-su-chuan-xing-zong-xian-she-ji-yu-fang-zhen/"" data-c="
          &lt;ul&gt;
&lt;li&gt;高频串行总线特征：&lt;br&gt;
1、加重&lt;br&gt;
在调频收发技术中，如语音和图像信号中，在低频段能量大，高频段能量小，而鉴频器输出噪声的功率谱密度与频率的平方成正比（低频噪声小，高频噪声大），造成信号的低频信噪比很大，高频信噪比很小，使得高频传输困难。&lt;br&gt;
预加重（pre-emphasis）：一种在发送端事先对发送信号的高频分量进行补偿的方法。通过增大信号跳变沿后第一个bit（跳变bit）的幅度。例：对于一个00111的序列，做完预加重后序列里第一个“1”的幅度会比第二个和第三个“1”的幅度大，由于跳变bit代表了信号里的高频分量，所以这种方法有助于提高发送信号里的高频分量。&lt;br&gt;
去加重（de-emphasis）：不增加跳变bit的幅度，而是相应减小非跳变bit的幅度。&lt;br&gt;
2、均衡&lt;br&gt;
当线路上存在串扰时，预加重和去加重都会将高频串扰分量也放大，增大串扰。&lt;br&gt;
均衡用于接收端，相当于一个高通滤波器，种类非常多，有线性均衡、非线性均衡、频域均衡、时域均衡、固定均衡、可变均衡、手动均衡、自适应均衡、码元间隔均衡、分数间隔均衡。&lt;br&gt;
PCB设计常用的：连续时间线性均衡（continus time linear equalizer：CTLE）、前向反馈均衡器（feed forward equalizer：FFE）、判决反馈均衡器（decision feedback equalizer：DFE）。&lt;br&gt;
码间干扰（ISI）：由信号的码型带来的恶劣影响。信号中存在连续的0和1，也有单独的0和1 ，其翻转对应低频和高频，连续的0或者1 在经历较高幅度后突然要转为低电平，这个高频对应的衰减很大，导致其电平不能到一个正确的位置。加入均衡后，低频的衰减很大，高频衰减变小，这样连续的0或者1突然改变时，低频和高频的幅度不会那么大。&lt;br&gt;
CTLE曲线：在低频时增益为负常数，随着频率升高增益衰减，经过一个高频后又开始慢慢变大的曲线。用在接收端。&lt;br&gt;
FFE：用在发射端，利用波形本身来校正接收到的信号。改变发射信号的波形。发送端进行FFE均衡后，相当于增加了一个高通滤波器，事先就把发送信号的低频进行衰减，在接收端高频和低频幅度的差距变小，有效解决ISI带来的影响。&lt;/li&gt;
&lt;li&gt;高速串行总线布局要求&lt;br&gt;
滤波电容靠近芯片引脚&lt;br&gt;
差分线的AC耦合电容出线均匀等长，电容前后部分等长，误差不超过5mil，具体布局要不要靠近发送芯片无要求，优先级低于滤波电容、串联匹配电阻&lt;br&gt;
高速串行信号布线：参考面首选地平面、保证参考平面完整、避免沿着电源平面分割布线、距板边满足20H要求、差分线要满足实时等长（不能在接收端进行绕城等长，这样会导致差分线相位偏移）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767252304574.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767252584833.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走线离稳压器区域的电源过孔反焊盘大于10H,如果信号线只能从电源孔附近走线,要在信号线和电源过孔之间打地孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767252985365.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
增加回流地孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767253210634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
尽量不要穿过差分线走线，可以顺着差分线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767253408388.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
BGA过孔间走线，尽量选择相同网络性质的过孔处绕线，TX的信号尽量在同样TX的过孔处走折现，也可以选择地孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767253565526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">高速串行总线设计与仿真</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ddrx-she-ji-yu-fang-zhen/"" data-c="
          &lt;ul&gt;
&lt;li&gt;DDR SDRAM&lt;br&gt;
全称：Double Data Rate SDRAM，双倍数据率同步动态随机存储器。&lt;br&gt;
ROM：只读存储器&lt;br&gt;
RAM：随机存储器。分SRAM 静态RAM和DRAM 动态RAM两类。&lt;br&gt;
SDRAM：是在DRAM上发展而来的，同步动态随机存储器。&lt;br&gt;
DDR SDRAM：在SDRAM上发展而来。&lt;br&gt;
GDDR：图形处理。&lt;br&gt;
LPDDR：低功耗等移动终端及消费电子。&lt;/li&gt;
&lt;li&gt;DDRx布局布线&lt;br&gt;
1、BGA可维修性：BGA周边器件5mm禁止，最小为3mm。&lt;br&gt;
2、DFM可靠性：布局时器件与器件之间满足DFM的间距要求，且考虑元件摆放的美观性。&lt;br&gt;
3、等长要求。&lt;br&gt;
4、滤波电容、上拉电阻的位置。滤波电容靠近各个PIn放置，储能电容均匀放置在芯片周边；上拉电阻按要求放置（布线长度小于500mil）。&lt;br&gt;
5、滤波电容的布局要求：&lt;br&gt;
CPU端和DDR端，每个引脚对应一个滤波电容，且滤波电容尽可能靠近引脚放置。&lt;br&gt;
线短而粗，回路尽量短，CPU和颗粒周边均匀摆放一些储能电容，DDR颗粒每片至少有一个储能电容。&lt;br&gt;
Vrefca和Vrefdq的滤波电容及分压电阻要分别靠近芯片的电源引脚。&lt;br&gt;
终端匹配电阻：Flyby结构靠近最后一个DDR颗粒的位置放置。&lt;br&gt;
Vtt上拉电阻：靠近最后一个DDR颗粒的位置，上拉电阻到颗粒之间的走线越短越好，建议小于500mil，每个终端Vtt上拉电阻对应放置一个滤波电容，最多两个电阻共用一个电容，Vtt电源一般直接在元件面同层铺铜来完成连接，布局时需要保证一定的电源通道，还要离颗粒不能太远。&lt;br&gt;
6、数据线分组：DQ0-7、DQMx、DQSxP/DQSxN一组；&lt;br&gt;
数据线布线：同组同层，尽量以GND层为参考平面，走线间距，组内尽量3H，组间间距5H以上，DQS拓扑与DQ拓扑5H，DQS差分线的线间距小于2倍线宽（紧耦合），差分对的长度控制在5mil以内，组内等长以DQS拓扑结构为基准，等长控制在20mil以内，数据线还要注意最长的长度要求，组间不需要考虑等长。&lt;br&gt;
7、拓扑结构要看芯片是否支持读写平衡（read and write leveling），支持采用Flyby拓扑，否则应采用T形拓扑，（保证CPU到DDR各支点等长，终端电阻要接在最大的T点上），&lt;br&gt;
8、对于Flyby拓扑，各个DDR颗粒间的走线，尽量用COPY，长度误差控制在20mil以内，推荐5mil，最大不超过100mil；时钟线推荐带状线布线，以GND/POWER平面为参考平面，对内等长控制在5mil以内，源端和终端匹配的走线，长度不要太长（推荐300mil以内）；有多个负载时，为了减少串扰和加大负载容性补偿，到第一个DDRx颗粒的走线阻抗可以比后面的走线阻抗小5-8欧姆；ADD/CMD/Ctrl/Clk网络从控制器到第一个DDRx颗粒的走线长度不超过6000mil，到最后一个DDRx颗粒不超过12000mil（具体看芯片差异}；正反贴时，分支的节点走线长度小于200mil且尽量等长，时钟信号的小于150mil。&lt;br&gt;
9、地址、控制信号以时钟作参考，误差控制在100mil以内&lt;br&gt;
10、确认芯片是否有pin delay，要确保pin delay打开&lt;br&gt;
11、表层走线尽量短&lt;br&gt;
12、Z轴延时打开&lt;/li&gt;
&lt;li&gt;电源处理&lt;br&gt;
Vdd：1.5V，引脚比较分散，电流较大，需要电源平面分配一个区域&lt;br&gt;
Vtt：元件面铺铜&lt;br&gt;
Vref：用与器件同层的铜皮或者走线，走线时要先经过电容再接到引脚，建议25-30mil的线宽&lt;br&gt;
小滤波电容：小电容尽量靠近相应的电源引脚，电容的引线尽量短，减少电源或者地共用过孔。&lt;/li&gt;
&lt;li&gt;时钟信号差分电容&lt;br&gt;
并联在差分线P和N之间，最好靠近发射端&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767242048905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767242074811.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
芯片无读写平衡功能，数据线和地址线的长度尽量相差在500mil以内，否则会出现DDR频率上不去的问题。&lt;/li&gt;
&lt;/ul&gt;
">DDRx设计与仿真</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-deng-chang-yu-deng-shi-50-ou-mu-wei-dai-xian-fang-zhen/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1767023159813.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
仿真后：&lt;br&gt;
Tref=919.3ps&lt;br&gt;
Tvia=930.3ps&lt;br&gt;
T1w=909.3ps&lt;br&gt;
Tfg=933.3ps&lt;br&gt;
T3w=917.3ps&lt;br&gt;
via存在物理长度，且其本身存在寄生电容和寄生电感，实际的传输延时会较普通传输线长&lt;br&gt;
1W蛇形走线，其信号本来应该按照红色蛇形线走，但是由于其信号的自耦和，其实际大概按照绿色线走，所以传输会快，而3W蛇形走线会好很多&lt;br&gt;
分割平面，信号的回流路径增大，信号会绕远一点的路径回流&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1767023496623.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
绕差分线走等长时，小波浪较大波浪好，但是小波浪不能太小，太小小波浪会由于高频的趋肤效应，越高频的走线会越走直线，一般应保证每一段的小波浪都为2-3倍线宽。&lt;/p&gt;
">硬件-等长与等时（50欧姆微带线仿真）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/autocad-kuai-jie-jian/"" data-c="
          &lt;p&gt;空格-确认&lt;br&gt;
F7-栅格显示开关&lt;br&gt;
F9-捕捉栅格&lt;br&gt;
F8-正交限制光标&lt;br&gt;
F10-按指定角度限制光标&lt;br&gt;
F3-对象捕捉&lt;br&gt;
L-直线&lt;br&gt;
C-圆形&lt;br&gt;
XL-射线&lt;br&gt;
E-删除&lt;br&gt;
H-填充&lt;br&gt;
TR-修剪&lt;br&gt;
EX-延伸&lt;br&gt;
PO-点&lt;br&gt;
S-拉伸&lt;br&gt;
U-返回&lt;br&gt;
DDI-直径标注&lt;br&gt;
DAN-角度标注&lt;br&gt;
OP-系统选项设置&lt;br&gt;
A-圆弧&lt;br&gt;
T-多行文字&lt;br&gt;
B-块定义&lt;br&gt;
I-块插入&lt;br&gt;
W-定义块文件&lt;br&gt;
CO-复制&lt;br&gt;
MI-镜像&lt;br&gt;
O-偏移&lt;br&gt;
F-倒圆角&lt;br&gt;
D-标注样式&lt;br&gt;
DLI-线性标注&lt;br&gt;
DRA-半径标注&lt;br&gt;
OS-对象捕捉设置&lt;/p&gt;
">Autocad快捷键</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/bios-xiang-jie/"" data-c="
          &lt;p&gt;&lt;strong&gt;Main&lt;/strong&gt;&lt;br&gt;
-System Date、System Time:时间&lt;br&gt;
&lt;strong&gt;Advanced&lt;/strong&gt;&lt;br&gt;
-Start Easy Flash：刷BIOS&lt;br&gt;
-Internal Pointing Device：触摸板开关&lt;br&gt;
-Wake On Lid Open：开盖自动开机唤醒控制&lt;br&gt;
-Legacy USB Suppor：&lt;br&gt;
当它开启时：BIOS/UEFI会为USB设备（如键盘、鼠标、U盘）加载一套传统的驱动程序。这使得：您可以在BIOS设置界面中使用USB键盘和鼠标。您可以从USB启动盘（如系统安装U盘）启动，即使该启动盘是以传统的“Legacy”方式制作的。一些非常老旧的、不兼容现代驱动的USB设备可能在DOS环境或旧系统中被识别。当它关闭时：BIOS/UEFI将不再提供对USB设备的传统支持。只有符合最新UEFI规范（通常使用USB mass storage device协议）的设备才能在启动前期被识别&lt;br&gt;
-XHCI Legacy Support：&lt;br&gt;
eXtensible Host Controller Interface，它是USB 3.0及后续版本（USB 3.1, 3.2, USB4）的硬件控制标准。所有蓝色的USB 3.0接口都由XHCI控制器管理。&lt;br&gt;
旧标准：USB 2.0及以下的控制器标准是 EHCI。Legacy USB Support：更通用，是让整个BIOS环境支持老旧USB设备的“总开关”。它影响所有USB接口（包括2.0和3.0）。XHCI Legacy Support：更专用，是让USB 3.0+ 的硬件控制器兼容老系统的“专项开关”。它主要影响蓝色的USB 3.0+接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SATA Configuration：&lt;br&gt;
控制硬盘的使用模式。AHCI 全称为 高级主机控制器接口。它是一种技术标准，允许软件（如操作系统）与 SATA 硬盘（包括传统机械硬盘和SATA接口的固态硬盘）进行高效通信的工作模式。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766890862321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-Network stack configuration：&lt;br&gt;
Network Stack Configuration（网络堆栈配置）是主板上的一项内置功能，它本质上是在电脑开机自检阶段，为网卡加载一套基本的驱动和网络协议，使其能在操作系统启动之前就具备网络连接能力。&lt;br&gt;
&lt;strong&gt;Boot&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Fast Boot：&lt;br&gt;
电脑正常的开机流程（POST，上电自检）会做很多事：检测所有硬件（内存、硬盘、USB设备、扩展卡等）、初始化它们、等待用户按键进入BIOS。Fast Boot 通过大幅精简或跳过这些步骤来提速：跳过全面硬件检测：只检测启动必需的硬件（如CPU、内存、启动硬盘），跳过对次要设备（如额外的PCIe插槽、部分USB端口）的详细检查和初始化。禁用部分接口：在启动阶段临时禁用大部分USB接口（只保留键盘的有限支持，甚至可能完全禁用），也可能会禁用PS/2、串口、并口等老旧接口。缩短或跳过等待时间：取消“按某键进入BIOS/启动菜单”的提示和等待。这导致开机画面一闪而过，你几乎没有机会按 Del 或 F2。忽略启动错误：对一些非致命的硬件报错（如风扇转速警告）可能不予显示，直接继续启动流程。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766891343641.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;Security&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Administrator Password：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766891873209.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;User Password：&lt;/li&gt;
&lt;li&gt;Set Master Password:&lt;br&gt;
硬件级加密：此密码不是由BIOS管理，而是直接写入硬盘的固件控制器。即使你把这块硬盘拆下来装到另一台电脑上，密码依然有效，不输入正确密码就无法访问任何数据。&lt;/li&gt;
&lt;li&gt;IO Interface Security：&lt;br&gt;
IO Interface Security（I/O接口安全）是华硕及许多企业级主板BIOS/UEFI中一个高级的物理安全功能。它的核心思想是：在硬件层面，直接禁用主板上不必要的外部输入/输出接口，从物理根源上切断潜在的数据泄露或入侵通道。默认状态（如 Unlock）：所有接口均可使用。安全配置流程：你可以将总开关设置为 Lock（锁定），然后有选择性地将需要使用的接口单独设置为 Unlock（解锁）。&lt;/li&gt;
&lt;li&gt;Secure Boot menu：&lt;br&gt;
Secure Boot（安全启动）是一道“启动安检门”，它只允许被信任的、带有正确数字签名的软件（如操作系统引导程序）在电脑启动初期运行，从而从根源上阻止病毒、木马或未授权的操作系统篡改您的启动过程。&lt;/li&gt;
&lt;li&gt;Key Management&lt;br&gt;
“Key Management”（密钥管理）是 Secure Boot（安全启动） 功能中最核心、最底层的配置区域。它定义了 “信任的根源”。&lt;/li&gt;
&lt;/ul&gt;
">BIOS详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ddr3/"" data-c="
          &lt;ul&gt;
&lt;li&gt;H5TC4G63AFR&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766807878715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766807925564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走线分组：&lt;br&gt;
1、11根：DQ0-DQ7、LDQS、LDQS_N、LDM&lt;br&gt;
2、11根：DQ8-DQ15、UDQS、UDQS_N、UDM&lt;br&gt;
3、A1-A14、BA0-BA3、CK、CK_N、CKE0、CS0_N、ODT0、RAS_N、CAS_N、WE_N&lt;br&gt;
可以参考RK3399设计规范DDR3，要同组同层、过孔数量一样&lt;/li&gt;
&lt;/ul&gt;
">DDR3</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/gao-su-ceng-die-she-ji/"" data-c="
          &lt;p&gt;铜厚（copper）：1oz=1.35mil；&lt;br&gt;
在进行阻抗控制的时候，1oz铜厚，内层一般由于打磨蚀刻，1.2miL；表层铜厚由于电镀铜，1.8-2.1mil。&lt;br&gt;
半固化片(PP片)：Prepreg，用于在铜和Core之间，&lt;br&gt;
| 型号  | 厚度 | 介电常数 |&lt;br&gt;
|:1080:|:2.8mil:|:4.3:|&lt;br&gt;
|:3313:|:3.8mil:|:4.3:|&lt;br&gt;
|:2116:|:4.5mil:|:4.5:|&lt;br&gt;
|:7628:|:6.8mil:|:4.7:|&lt;br&gt;
嘉立创通用的叠层之一：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766751297568.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766751440772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
芯板（Core）：铜箔和半固化片通过压合形成。&lt;br&gt;
基材常见的性能指标：&lt;br&gt;
DK：材料的介电常数，越小越好。&lt;br&gt;
Df：材料的介质损耗角，越低信号传播损失最小。&lt;br&gt;
导线的横截面为梯形，一般以1oz铜厚，梯形上边比下边短1mil，内层0.5oz铜厚，短0.5mil。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766753398926.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假定信号线的相邻层有一块铜皮，铜皮的宽度只要满足D=3H（2D=6H），信号线90%的回流电流密度在这块铜皮上就呈现正态分布。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数模混合设计时对地的分割&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766753946884.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分割但是没有分区，走线跨分割，会带来严重的信号质量问题和EMC问题。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766754103732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分割同时搭桥：数模的地分开，单点连接，宽度视穿过分割区的网络数量定。保证信号从桥上过，不能跨分割。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766754334882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分割同时搭桥，存在AD器件，直接把AD器件作为桥。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766754487301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
多个AD器件存在，可以不进行分割，只对数模电路进行合理布局，一般情况下，不对数模的电源地进行分割。&lt;br&gt;
-双带线 dual-stripline&lt;br&gt;
指L6 L7两层之间没有任何平面层进行隔离&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766754816779.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766754904117.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看出，双带线之间的层厚明显比其他层厚。相邻布线层间距远远大于其到参考平面的距离。&lt;br&gt;
-6层板的层叠方案&lt;br&gt;
1、TOP-GND1-S1-S2-PWR1-BOT&lt;br&gt;
2、TOP-S1-GND1-PWR1-S2-BOT&lt;br&gt;
3、TOP-GND1-S1-PWR1-GND2-BOT&lt;br&gt;
4、TOP-GND1-S1-GND2-PWR1-BOT&lt;br&gt;
以上优选3，可用1，备选2、4；其中方案1 最常见&lt;/li&gt;
&lt;/ul&gt;
">高速层叠设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-chuan-rao/"" data-c="
          &lt;p&gt;DDR3信号，其接收端的电平通常为Uih=900mV，Uil=600mV，，如果输出为标准的0-1.5V信号，在通道上的噪声裕量达到了600mV，这些裕量将由反射、损耗、电源噪声、串扰等问题产生。&lt;br&gt;
信号在传输过程中与任何导体都可构成电容，而其与回流路径（地平面或者电源平面）组成的电容之间的能量就是我们要传输的信号；而储藏在信号路径与其他路径之间的能量，则是串扰。&lt;br&gt;
避免串扰：1、加大信号路径与回流路径的耦合；2、尽量减小信号路径与其他路径的耦合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;近端串扰、远端串扰&lt;br&gt;
对于串行总线，RX与RX走一组，TX与TX走一组。&lt;/li&gt;
&lt;li&gt;3W原则&lt;br&gt;
线的中心间距大于3倍线宽。严谨来说应该是3H原则，H指走线到参考平面的距离。&lt;/li&gt;
&lt;li&gt;差分线&lt;br&gt;
差分线传输的是两条单端总线电压的差值，Udiff=U1-U2；但是差分线还存在共模信号，Ucomm=0.5*（U1+U2）；在高速串行总线上一般会增加一个AC耦合电容以去除共模分量。&lt;br&gt;
对于差分信号，其电压幅度相等，互为相反数，电流大小相等，方向相反。因此，差分线的电压为单端电压的两倍，电流构成一个回路，因此其阻抗为单根传输线阻抗的两倍。&lt;/li&gt;
&lt;/ul&gt;
">硬件-串扰</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-chuan-shu-xian-de-fan-she-tuo-bu-yu-duan-jie/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传输线的反射&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764589263808.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764590497229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764594347982.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764594378092.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766496560895.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766496594479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766496629022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拓扑&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766498082697.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766498113314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端接&lt;br&gt;
增加端接目的在于抵消反射的影响，驱动端阻抗较小，可理解为粗水管，接收端阻抗较高，对应于细水管，为了抵消反射的影响，可在驱动端串电阻，接收端使用上下拉电阻。&lt;br&gt;
实际电路中，驱动端阻抗一般在17欧到40欧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源端串联端接&lt;br&gt;
靠近芯片的发送端串联一个电阻，使得该阻值和芯片内阻之和与传输线阻值尽量一致，常用于点对点拓扑，但是会增加RC时间常数，减缓负载端信号的上升时间。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766577564109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终端并联端接&lt;br&gt;
在末端并联一个和传输线阻抗特性一致的电阻到GND或者电源，可以在信号反射回源端之前在负载端消除反射，减小噪声、电磁干扰（EMI）、射频干扰（RFI）。但是会增加直流功耗，不适用于电池供电的产品。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766577589908.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766578614512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fly-by拓扑结构&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766579470045.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">硬件-传输线的反射拓扑与端接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-chuan-shu-xian-de-sun-hao/"" data-c="
          &lt;ul&gt;
&lt;li&gt;趋肤效应和导体损耗&lt;br&gt;
在一阶模型中，传输线由电容和电感组成，二者均不是耗能器件，所以一阶模型是一个无损的理想模型，而实际上传输线是有损耗的，其主要损耗来源于：导体损耗和介质损耗&lt;br&gt;
导体损耗：电阻产生的损耗。&lt;br&gt;
在信号传输时，信号会沿着阻抗最小的路径前进，而信号路径上的阻抗主要由电阻和电感产生的感抗组成。在低频时，感抗非常小，主要由电阻决定，在高频时，感抗占据主导地位，于是电流会沿着寻找一条电感最小的路径。导线中的电流会尽可能的延展开来使导线的自感最小，同时，导线中的电流会尽量接近回流路径，也会将回流路径上的电流拉到自己身边，使得信号路径和返回路径的互感增大，从而达到减小有效电感的目的，这就是趋肤效应。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764246028555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764246476763.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在趋肤效应下，导线的有效横截面积不再是导线的横截面积，而是电流流过的面积，其电阻计算公式为&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764246842235.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导体损耗还和材料表面的粗糙度有关，当发生趋肤效应的时候，若粗糙，电流流过的路径会变长。&lt;/li&gt;
&lt;li&gt;损耗正切角与介质损耗&lt;br&gt;
用耗散因素来表示介质的损耗性能，符号是tan（e），其真实的含义是复平面中材料复介电常数实部与虚部的比值。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764248176425.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
介电常数的实部就是我们看到的介电常数，表示材料储存电荷的能力，电容产生的电流是垂直于电压方向的，不做功。而介电常数的虚部，描述的是材料的漏电特性，其产生的电流与电压方向相同，也就是与电容所产生的电流方向垂直。&lt;br&gt;
耗散因素可以在材料手册里查到，除了以tan(e)表示，通常叫做dissipation factor（DF），耗散因素越低越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;材料&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;相对介电常数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;耗散因素&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FR-4玻璃纤维板&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.0-4.7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.02&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无卤FR-4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;常用高速材料&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.2-3.8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.003-0.008&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RogersRF35材料&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.0018&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;聚四氟乙烯PTFE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2.2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;空气&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">硬件-传输线的损耗</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-wei-dai-xian-he-dai-zhuang-xian/"" data-c="
          &lt;ul&gt;
&lt;li&gt;微带线：只有一个参考平面，上面盖一层绿油&lt;br&gt;
一般绿油厚度为0.5~1mil，W2是板上布线的宽度，由于加工后的线为梯形，所以W1&amp;lt;W2，一般当铜厚为1mil以上时，W2-W1=1mil，当铜厚为0.5mil时，W2-W1=0.5mil。&lt;/li&gt;
&lt;li&gt;带状线：位于两个参考平面之间的导线。&lt;br&gt;
计算阻抗参考博客内容 Si9000-阻抗设计&lt;/li&gt;
&lt;/ul&gt;
">硬件-微带线和带状线</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-chuan-shu-xian-de-ji-ben-te-xing/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1764240580638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764240605661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764240630143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764240661855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传输线零阶模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764242790562.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764242832699.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764242867144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输线一阶模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764244681005.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764334569387.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764334606347.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764334644049.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在要求传输线的总电感小于某个值时，实际上只是通过总电感的要求，来约束线长。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输线的二阶模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764335803230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R代表信号的串联电阻，其阻值由于趋肤效应的影响，与频率的二分之一次方正相关，其增速没有频率增速大。&lt;br&gt;
G代表并联的电导，也就是介质损耗，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764335992975.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
频率越高，电导越大，漏电流越大，介质损耗越大。&lt;br&gt;
因此，低频导体损耗大，高频介质损耗大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减小损耗&lt;br&gt;
加大线宽&lt;br&gt;
减少铜箔的粗糙度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">硬件-传输线的基本特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-zu-kang-xie-zhen-pin-lu/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168234360.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168278225.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ESR是等效串联电阻，ESL是等效串联电感，C为理想电容。因此实际电容的阻抗可以用数学公式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168804879.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168832908.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们画出这个公式的曲线，就得到一个曲线图。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168865621.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在频率很低的时候，可以看到，感抗远小于容抗，并且复阻抗的相位为负值，说明电流超前电压，这是典型的电容充电特性，所以说，电容在低频主要表现为容性。&lt;br&gt;
而在高频的时候，感抗远大于容抗，复阻抗的相位为正值，说明电压超前电流，是典型的电感施加电压时的行为特征，所以说，电容在高频时表现为电感特性。&lt;br&gt;
而在谐振时，容抗和感抗相抵为0，此时电容的总阻抗最小，复阻抗相位为0，表现为纯电阻特性，这个点就是电容的自谐振频率。在谐振频率左边，电容主要呈容性，在谐振频率右边，电容主要呈感性。&lt;br&gt;
电容最广泛的用途就是滤波，那么如何看曲线选电容呢？其实就是选阻抗最低的。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168995644.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们知道，整个阻抗曲线呈大V型，只有在谐振频率点附近的阻抗才比较低。所以，实际的去耦电容都有一定的工作频率范围，只有在谐振频率附近，电容才有很好的去耦作用。&lt;br&gt;
可能有人会觉得，在频率比谐振频率高一点的时候，电容都成感性了，都不是电容了，所以不能让噪声的频率大于电容的谐振频率。其实这是错误的，去耦就是要选阻抗低的，阻抗低，在电容上产生的电压波动就小，也就是噪声会小。&lt;br&gt;
来看下常规的MLCC陶瓷电容的曲线图。可以看出，不同的电容，曲线是不同的，容量大的ESR要小写，谐振频率低些，主要滤低频。容量小的ESR要大些，谐振频率要高些，主要滤高频。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764169851252.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实际电路中我们需要去耦的频率范围会比较宽，因此呢一个电容搞不定，那怎么办呢？我们经常有两种方法来解决，一种是使用一个大电容和一个小电容并联，还有一种是使用多个相同的电容并联。那么这两种方法达到的效果分别是怎样的呢？&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764169942705.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先来看大小电容并联。大小两个电容分别有各自的谐振频率f1和f2&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764169970274.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当频率比较低的时候，两个电容都成容性，在频率比较高的时候，两个电容都呈感性，并联后总体阻抗曲线都会保持原来的变化趋势，因此，数值上会比任意一个电容都小。&lt;br&gt;
但是，当频率大于f1并小于f2时，大电容呈感性小电容呈容性，两者并联，就像是一个电感和一个电容并联，构成了LC并联谐振电路，并在某一个频率点发生并联谐振，导致该处阻抗很大。如果负载芯片的电流需求正好落在这个频率，那么会导致电压波动超标。所以，我们需要选好电容的搭配情况。&lt;br&gt;
再来看看相同电容并联的情况，n个相同的电容并联，谐振频率和单个电容一样，但是在谐振点处的阻抗是原来的n分之一，因此，多个相同的电容并联后，阻抗曲线整体形状不变，但是各个频点的整体阻抗变小。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764170005359.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clear
clc

%求电容的谐振频率
c=0.1e-6;  %0.1uf
r=0.02;  %0.02oumu
l=0.0001e-6;  %0.0001uh
f=50e3:1e3:50e9;
w=2*pi*f;

f_resonant=1/(2*pi*sqrt(l*c));
fprintf(&#39;谐振频率：%.2e MHz\n&#39;,f_resonant/1e6);

Zc=(1./(1j*w*c))+r+1j*w*l;
Z_mag=abs(Zc);
subplot(2,1,1);
loglog(f,Z_mag);
title(&#39;用loglog绘制&#39;)
subplot(2,1,2);
fann=atan2((w*l-(1./(w*c))),r)*(180/pi);

semilogx(f,fann);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1764171256870.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个电容并联&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  clear
  clc

  %求电容的谐振频率
  c=10e-6;  %10uf
  r=0.002522;  %oumu
  l=0.001e-6;  %0.001uh
  f=50e3:1e3:50e9;
  w=2*pi*f;

  f_resonant=1/(2*pi*sqrt(l*c));
  fprintf(&#39;谐振频率：%.2e MHz\n&#39;,f_resonant/1e6);

  Zc=(1./(1j*w*c))+r+1j*w*l;
  Z_mag=abs(Zc);

  c1=0.1e-6;  %0.1uf
  r1=0.02;  %0.02oumu
  l1=0.0001e-6;  %0.0001uh


  f_resonant1=1/(2*pi*sqrt(l1*c1));
  fprintf(&#39;谐振频率：%.2e MHz\n&#39;,f_resonant1/1e6);

  Zc1=(1./(1j*w*c1))+r1+1j*w*l1;
  Z_mag1=abs(Zc1);

  for n=1:1:49999951

  Zc2(n)=(Zc(n) .* Zc1(n)) / (Zc(n)+Zc1(n));
  Z_mag2(n)=abs(Zc2(n));
  end

  loglog(f,Z_mag);
  hold on;
  loglog(f,Z_mag1);
  hold on;

  scatter(f,Z_mag2);

  hold on;
  title(&#39;用loglog绘制&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1767332909691.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
两种电容并联，会出现两个谐振频率点，同时还会出现一个反谐振频率点。&lt;/p&gt;
">硬件-阻抗、谐振频率</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-tao-ci-dian-rong-de-esr-xie-zhen-pin-lu/"" data-c="
          &lt;p&gt;https://ds.murata.co.jp/simsurfing/mlcc.html?lcid=zh-cn&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168048166.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
10uf_10V_X5R_0603的MLCC参数如下图：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168071632.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
谐振频率在2MHz左右；&lt;br&gt;
ESR并不是固定值，在500Khz左右达到最低，大概是2毫欧，在100hz的时候ESR是2Ω左右，差别还是很大的。&lt;br&gt;
各种电容ESR参数（注意不是阻抗）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168107843.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
各种电容的谐振频率&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764168133663.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">硬件-陶瓷电容的ESR-谐振频率</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-mlcc-dian-rong-de-zhi-liu-pian-ya-te-xing/"" data-c="
          &lt;p&gt;陶瓷电容MLCC有一个直流偏压特性：在电容上施加直流电压之后，电容容量会下降。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764167600591.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下图是村田的47uF/6.3V电容直流偏压特性&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764167633348.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实验条件，12V转3.3V的DCDC，开关频率800Khz的DCDC，输出滤波电容型号为47uF/6.3V，经查询ESR在800Khz时为2mΩ。&lt;br&gt;
计算公式：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764167770816.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一种纹波计算值：电容量按照满容量47uF计算。&lt;br&gt;
ESR造成的纹波=2.7mV&lt;br&gt;
电容量造成的纹波=4.5mV&lt;br&gt;
所以总纹波为：2.7mV+4.5mV = 7.2mV&lt;br&gt;
第二种纹波计算值：电容量按照电容偏压曲线在3.3V时容量大概为18.8uF。&lt;br&gt;
ESR造成的纹波=2.7mV&lt;br&gt;
电容量造成的纹波=11.3mV&lt;br&gt;
所以总纹波为：2.7mV+11.3mV=14mV&lt;br&gt;
电路板实测：&lt;br&gt;
电路板实测，纹波为15mV，与第二种方法算出来的值非常接近。&lt;br&gt;
所以，MLCC陶瓷电容的直流偏压特性的确是存在的&lt;/p&gt;
">硬件-MLCC电容的直流偏压特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-dian-zu-yu-zu-kang/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1764075396343.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764075431251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764076322250.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764076352908.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764078167340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764078196146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764078226300.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764078250295.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764079195146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在https://ds.murata.com/simsurfing/mlcc.html?lcid=zh-cn随机找到一个0402封装0.1uf的MLCC电容&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764161852510.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到其谐振频率为42MHz，此时阻抗约为0.02欧姆&lt;br&gt;
其电阻与频率的关系如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764162524404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其等效模型的电感量与频率的关系如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764162629387.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设一个0.1uf 0.02欧姆  0.001uh的电容，绘制其阻抗与频率的关系&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764165631157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在绘制其关系时，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;plot函数：&lt;/li&gt;
&lt;li&gt;使用线性坐标轴绘制数据。&lt;/li&gt;
&lt;li&gt;横轴和纵轴都是线性的。&lt;/li&gt;
&lt;li&gt;适用于数据变化不是特别大，或者想在线性尺度上观察数据的情况。&lt;/li&gt;
&lt;li&gt;loglog函数：&lt;/li&gt;
&lt;li&gt;使用对数坐标轴绘制数据（横轴和纵轴都是对数尺度）。&lt;/li&gt;
&lt;li&gt;适用于数据跨度很大，比如多个数量级，并且想观察幂律关系的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;matlab程序如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clear
clc

%求电容的谐振频率
c=0.1e-6;  %0.1uf
r=0.02;  %0.02oumu
l=0.0001e-6;  %0.0001uh
f=50e3:1e3:50e9;
w=2*pi*f;

f_resonant=1/(2*pi*sqrt(l*c));
fprintf(&#39;谐振频率：%.2e MHz\n&#39;,f_resonant/1e6);

Zc=(1./(1j*w*c))+r+1j*w*l;
Z_mag=abs(Zc);
subplot(2,1,1);
loglog(f,Z_mag);
title(&#39;用loglog绘制&#39;)
subplot(2,1,2);
semilogy(f,Z_mag);
title(&#39;用plot绘制&#39;);
&lt;/code&gt;&lt;/pre&gt;
">硬件-电阻、电容、电感等效模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/li-xiang-fang-bo/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763901776021.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;clear
clc

f=1e9;   %1GHz;
t=0:0.02e-9:5e-9;   %5ns

w1=2*pi*f;

f2=0:1e9:50e9;  %从0HZ到50ghz,每次增加1GHZ
w2=2*pi*f2;

ft=square(w1*t);
subplot(3,2,1);
plot(t*1e9,ft);
ylim([-1.5,1.5]);
xlabel(&#39;时间/ns&#39;);
ylabel(&#39;幅值/V&#39;);
title(&#39;理想1GHz方波（时域)&#39;);



for j=1:length(w2)-1


    s1=sin(w2(j)*t);      %sinwt

    subplot(3,2,3);
    plot(t*1e9,s1);
    xlim([0,5]);
    ylim([-1.5,1.5]);
    xlabel(&#39;时间/ns&#39;);
    ylabel(&#39;幅值/V&#39;);
    title(sprintf(&#39;sinwt f=%d GHz&#39;,(f2(j)/1e9)));

    pause(0.01);


    c2=cos(w2(j)*t);    %coswt
    subplot(3,2,5);
    plot(t*1e9,c2);
    xlim([0,5]);
    ylim([-1.5,1.5]);
    xlabel(&#39;时间/ns&#39;);
    ylabel(&#39;幅值/V&#39;);
    title(sprintf(&#39;coswt f=%d GHz&#39;,(f2(j)/1e9)));
    pause(0.01);


    im1=ft.*s1;  %虚部f(t)*sinwt

    re1=ft.*c2; %实部f(t)*coswt

    g1=@(t) square(w1*t).*sin(w2(j)*t); %虚部积分
    q1=integral(g1,0,1);
    subplot(3,2,4);
    hold on;
    scatter(((f2(j)/1e9)),q1,10,&#39;red&#39;,&#39;filled&#39;);
    yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
    xlabel(&#39;频率/GHz&#39;);
    ylabel(&#39;积分&#39;);
    title(&#39;虚部积分&#39;);

    g2=@(t) square(w1*t).*cos(w2(j)*t); %实部积分
    q2=integral(g2,0,1);
    subplot(3,2,6);
    hold on;
    scatter(((f2(j)/1e9)),q1,10,&#39;red&#39;,&#39;filled&#39;);
    yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
    xlabel(&#39;频率/GHz&#39;);
    ylabel(&#39;积分&#39;);
    title(&#39;实部积分&#39;);

    subplot(3,2,2);  %模
    s=sqrt(q1^2+q2^2);
    hold on;
    scatter(((f2(j)/1e9)+1),s,10,&#39;red&#39;,&#39;filled&#39;);
    yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
    xlabel(&#39;频率/GHz&#39;);
    ylabel(&#39;模&#39;);
    title(&#39;模&#39;);
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763902181076.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看出在目标频率1GHz处，存在峰值。&lt;br&gt;
理想方波只有奇次谐波，偶次谐波的谐波分量为0,0GHz的频率分量为0，也就是直流分量为0.&lt;/p&gt;
">理想方波-傅里叶变换、频谱</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ou-la-gong-shi-fu-li-xie-bian-huan/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763641172719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;欧拉公式-ejwtcoswtjsinwt&#34;&gt;欧拉公式 e^jwt=coswt+jsinwt&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;w=1;
t=0:0.1:20;
f=exp(1j*w*t);%语法问题，写代码最好用1j代替j
x=t;
y=imag(f);
z=real(f);
plot3(x,y,z);
xlabel(&#39;时间t&#39;);
ylabel(&#39;虚部jsinwt&#39;);
zlabel(&#39;实部coswt&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实部为cost图像，f(t)=cost&lt;br&gt;
虚部为sint图像，f(t)=sint&lt;br&gt;
实部和虚部为圆心为0 半径为1 的园&lt;br&gt;
filename=&#39;oula.gif&#39;;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% 创建数据
t = 0:0.1:20;
x = t;
y = sin(t);
z = cos(t);

% 初始化图形
figure;
h = plot3(x(1), y(1), z(1), &#39;b-&#39;, &#39;LineWidth&#39;, 1);
hold on;
scatter3(x(1), y(1), z(1), 50, &#39;r&#39;, &#39;filled&#39;);
xlabel(&#39;时间t&#39;);
ylabel(&#39;虚部&#39;);
zlabel(&#39;实部&#39;);
title(&#39;oula&#39;);
grid on;
axis([0 20 -1 1 -1 1]);

% 动态绘制
for i = 2:length(t)
set(h, &#39;XData&#39;, x(1:i), &#39;YData&#39;, y(1:i), &#39;ZData&#39;, z(1:i));
drawnow;

frame = getframe(gcf);
im = frame2im(frame);
[imind, cm] = rgb2ind(im, 256);

% 写入GIF文件

if i == 2
imwrite(imind, cm, filename, &#39;gif&#39;, &#39;Loopcount&#39;, inf, &#39;DelayTime&#39;, 0.1);
else
imwrite(imind, cm, filename, &#39;gif&#39;, &#39;WriteMode&#39;, &#39;append&#39;, &#39;DelayTime&#39;, 0.1);
end

% 控制速度
pause(0.05);
end
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763690475249.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;傅里叶变换&#34;&gt;傅里叶变换&lt;/h1&gt;
&lt;p&gt;核心思想是将复杂的波形分解成一系列简单的正弦波的叠加&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763698577773.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clear
clc

t=0:0.01:20;
w1=3;
w2=0.1:0.1:5;
clf;

for i=1:length(t)
clf;
f1=sin(w1*t);
for j=1:length(w2)
        f2=sin(w2(j)*t);
        subplot(3,1,1);
        plot(t,f2);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        legend(&#39;sin(5t)&#39;,&#39;sin(wt)&#39;);
        pause(0.01);
        cla

        subplot(3,1,1);
        plot(t,f1);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        hold on;
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;sinwt&#39;);
        title(sprintf(&#39;w2 = %d&#39;, w2(j)));
        
        subplot(3,1,2);
        f3=f1.*f2;
        plot(t,f3);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;f(t)&#39;);
        title(&#39;f(t)&#39;);

        subplot(3,1,3);
        axis([0 50 -5 10]);
        g=@(t) sin(w1*t).*sin(w2(j)*t);
        q=integral(g,0,20);
        disp(q);
    
        hold on;
        scatter(j,q,10,&#39;red&#39;,&#39;filled&#39;);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;积分&#39;);
        title(&#39;积分&#39;);
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763701367053.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若未知信号的初始相位为90°，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763701971901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
傅里叶变换的实部表示未知信号与cos信号的相关度，虚部表示未知信号与sin信号的相关度&lt;br&gt;
当未知信号与基信号频率相同时，他们乘积的积分达到了最大。而这个积分最终的图像是不是就很像信号经过傅里叶变换后的频域图像，就是用各种频率的基信号与未知信号做对比，看看哪个频率的基信号与未知信号最像！！！，而这个对比的方法，用数学来描述就是先相乘后积分&lt;br&gt;
左边为sin3t&lt;em&gt;sinwt，为傅里叶变换的虚部，右边为sin3t&lt;/em&gt;coswt,为傅里叶变换的实部&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763711926328.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当w提增到目标的w=3时，两个sin波形重合，想乘后均大于0，此时对其虚部的积分达到最大值&lt;br&gt;
其实部为sin3t*coswt，积分值则不同，当w遍历到3时，和未知信号w=3达到同频，上下半轴抵消，其积分为0&lt;br&gt;
clear&lt;br&gt;
clc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;filename=&#39;fly.gif&#39;;
t=0:0.01:20;
w1=3;
w2=0.1:0.1:5;

for i=1:length(t)
    clf;
    f1=sin(w1*t);
    p1=cos(w1*t);

    for j=1:length(w2)
        f2=sin(w2(j)*t);      %sinwt
        subplot(3,2,1);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        plot(t,f2);
        pause(0.001);
        cla

        subplot(3,2,1);     %sin3t
        plot(t,f1);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        hold on;
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;f(t)&#39;);
        title(sprintf(&#39;w2 = %d&#39;, w2(j)));

        p2=cos(w2(j)*t);    %coswt
        subplot(3,2,2);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        plot(t,p2);

        pause(0.001);
        cla

        subplot(3,2,2);    %sin3t
        plot(t,f1);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        hold on;
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;f(t)&#39;);
        title(sprintf(&#39;w2 = %d&#39;, w2(j)));


        subplot(3,2,3);  %虚部sin3t*sinwt
        f3=f1.*f2;
        plot(t,f3);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;Im&#39;);
        title(&#39;虚部&#39;);

        subplot(3,2,4);  %实部sin3t*coswt
        p3=f1.*p2;
        plot(t,p3);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;Re&#39;);
        title(&#39;实部&#39;);

        subplot(3,2,5);     %虚部积分
        axis([0 50 -10 10]);
        g=@(t) sin(w1*t).*sin(w2(j)*t);
        q=integral(g,0,20);
        disp(q);

        hold on;
        scatter(j,q,10,&#39;red&#39;,&#39;filled&#39;);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;积分&#39;);
        title(&#39;虚部积分&#39;);

        subplot(3,2,6);     %实部积分
        axis([0 50 -10 10]);
        g=@(t) sin(w1*t).*cos(w2(j)*t);
        q=integral(g,0,20);
        disp(q);

        hold on;
        scatter(j,q,10,&#39;red&#39;,&#39;filled&#39;);
        yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
        xlabel(&#39;时间t&#39;);
        ylabel(&#39;积分&#39;);
        title(&#39;实部积分&#39;);

    end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对实部和虚部积分后的值进行开根号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763712834683.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
subplot(4,2,7);     %实部积分&lt;br&gt;
axis([0 50 -10 10]);&lt;br&gt;
s=sqrt((q1&lt;sup&gt;2)+(q2&lt;/sup&gt;2));&lt;br&gt;
hold on;&lt;br&gt;
scatter(j,s,10,&#39;red&#39;,&#39;filled&#39;);&lt;br&gt;
yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5&lt;br&gt;
xlabel(&#39;w&#39;);&lt;br&gt;
ylabel(&#39;模&#39;);&lt;br&gt;
title(&#39;模&#39;);&lt;br&gt;
可以看出目标信号的频率成分&lt;/p&gt;
&lt;h1 id=&#34;傅里叶级数&#34;&gt;傅里叶级数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763907607433.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763907645069.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763907680668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763907709572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763907734806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clear
clc

T0=2*pi;
w0=(2*pi)/T0;

n=1:1:30;

% 基本方波绘制
t = 0:0.001:30;        % 时间向量，从0到4秒，步长0.001
g=square(t);

figure;
subplot(3,1,1);
plot(t, g, &#39;LineWidth&#39;, 2);
title(&#39;基本方波&#39;);
xlabel(&#39;时间 (s)&#39;);
ylabel(&#39;幅度&#39;);
ylim([-1.5 1.5]);
grid on;

for i= 1:length(n)
    y = @(t) square(t);   % 生成频率为1Hz的方波
    y2=@(t) square(t).*cos(i*t);
    y3=@(t) square(t).*sin(i*t);


    a0=(1/2*pi).*integral(y,-pi,pi);


    an=(1/pi).*integral(y2,-pi,pi);
    bn=(1/pi).*integral(y3,-pi,pi);

    An=sqrt(an^2+bn^2);

    fann=atan2(0,0);


    subplot(3,1,2);
    hold on
    scatter(n(i),An,10,&#39;red&#39;,&#39;filled&#39;);
    yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
    xlabel(&#39;n&#39;);
    ylabel(&#39;An&#39;);
    title(&#39;幅值&#39;);

    subplot(3,1,3);
    hold on
    scatter(n(i),fann,10,&#39;red&#39;,&#39;filled&#39;);
    yline(0, &#39;--&#39;, &#39;Color&#39;, &#39;black&#39;, &#39;LineWidth&#39;, 1); % 红色虚线，线宽1.5
    xlabel(&#39;n&#39;);
    ylabel(&#39;fann&#39;);
    title(&#39;相位&#39;);

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763913861570.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1768315826434.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- n次谐波
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763985644423.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;clear
clc

T0=2*pi;
w0=(2*pi)/T0;

n=1:2:29;

% 基本方波绘制
t = 0:0.001:10;        % 时间向量，从0到4秒，步长0.001
g=square(t);


figure;
plot(t, g, &#39;LineWidth&#39;, 2);
hold on;


title(&#39;基本方波&#39;);
xlabel(&#39;时间 (s)&#39;);
ylabel(&#39;幅度&#39;);
ylim([-1.5 1.5]);
for i=1:length(n)

    f=(4/(pi*n(i))*sin(n(i)*t));
    plot(t,f);

end
grid on;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763985691315.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;理想方波的1~29次谐波叠加&lt;/p&gt;
&lt;p&gt;clear&lt;br&gt;
clc&lt;/p&gt;
&lt;p&gt;T0=2&lt;em&gt;pi;&lt;br&gt;
w0=(2&lt;/em&gt;pi)/T0;&lt;/p&gt;
&lt;p&gt;n=1:2:29;&lt;/p&gt;
&lt;p&gt;% 基本方波绘制&lt;br&gt;
t = 0:0.001:10;        % 时间向量，从0到4秒，步长0.001&lt;br&gt;
g=square(t);&lt;/p&gt;
&lt;p&gt;figure;&lt;br&gt;
subplot(2,1,1);&lt;br&gt;
plot(t, g, &#39;LineWidth&#39;, 2);&lt;br&gt;
hold on;&lt;/p&gt;
&lt;p&gt;title(&#39;基本方波及其谐波&#39;);&lt;br&gt;
xlabel(&#39;时间 (s)&#39;);&lt;br&gt;
ylabel(&#39;幅度&#39;);&lt;br&gt;
ylim([-1.5 1.5]);&lt;br&gt;
for i=1:length(n)&lt;/p&gt;
&lt;p&gt;f(i,:)=(4/(pi*n(i))*sin(n(i)*t));&lt;br&gt;
plot(t,f);&lt;br&gt;
end&lt;/p&gt;
&lt;p&gt;for j=1:length(t)&lt;br&gt;
fs(:,j)=sum(f(:,j));&lt;br&gt;
end&lt;/p&gt;
&lt;p&gt;subplot(2,1,2);&lt;/p&gt;
&lt;p&gt;plot(t, g, &#39;LineWidth&#39;, 2);&lt;br&gt;
hold on;&lt;br&gt;
plot(t,fs);&lt;br&gt;
title(&#39;基本方波及谐波叠加&#39;);&lt;br&gt;
xlabel(&#39;时间 (s)&#39;);&lt;br&gt;
ylabel(&#39;幅度&#39;);&lt;br&gt;
ylim([-1.5 1.5]);&lt;br&gt;
grid on;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763987735422.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下图为叠加1、3、5次谐波的对比图&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763987924903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可知：高频分量越多（既是频率，也指幅度），信号的上升沿越陡，高频谐波主要影响信号边沿时间，低频的分量影响幅度。&lt;/p&gt;
">欧拉公式-傅里叶变换-傅里叶级数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/sipi-gai-shu/"" data-c="
          &lt;p&gt;SI：发送“1”接收“1”&lt;br&gt;
PI：发送“1V”接收“1V”&lt;br&gt;
高速信号的临界判断条件：Tr&amp;lt;=6TD(上升时间小于等于6倍传播延时)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBIS模型：&lt;br&gt;
IBIS是一个行为模型，通过V/I和V/T数据描述器件数字输&lt;br&gt;
入和输出的电气特性，不会透露任何专有信息。&lt;br&gt;
模型可以在三种不同条件下生成：典型、最小和最大。在&lt;br&gt;
典型模型中，使用标称电源电压、温度和工艺参数获取数&lt;br&gt;
据；在最小模型中，使用最低电源电压、较高温度和较弱&lt;br&gt;
工艺参数获取数据；对于最大模型，条件是最高电源电&lt;br&gt;
压、较低温度和较强的工艺参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562114395.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562155445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562180953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562209820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562277528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562812462.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若报错，根据日志.log文件修改文件名即可&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562879655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IBIS模型信息&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763562982339.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
信号传播延时：V=C/根号e&lt;br&gt;
e:空气相对介电常数&lt;br&gt;
C：3x108m/s&lt;br&gt;
FR4板材：e=3.5~4.5&lt;br&gt;
在FR4板材上，1ns的传播延时走过的长度为6inch=15.24cm=6000mil&lt;br&gt;
1inch=2.54cm=1000mil&lt;br&gt;
电路中，通常驱动端是低阻抗，接收端的高阻抗&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763635986632.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763636011268.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
一般：信号的上升时间为信号周期的十分之一&lt;br&gt;
信号带宽是指信号的最高有效频率（有效频率：某频率谐波的赋值大于理想方波幅值的70%（功率的50%））&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;s参数&#34;&gt;S参数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1764071829304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
《高速电路设计仿真实战》中定义S参数：S参数表征从DUT（device under test）某个特定端口散射出的正弦波与入射波到DUT某个端口上的正弦波的比值。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764072694658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764073535617.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764074580892.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1764074608609.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">SI、PI概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/si9000-zu-kang-she-ji/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552492874.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552533943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552667186.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552708873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552814845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552876685.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
P片：半固化片&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552948431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763552978919.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553387970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553421071.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553452942.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553554945.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553622510.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553653008.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553681959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553711578.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763553743152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Si9000-阻抗设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-dian-zu-zu-zhi-biao-ding/"" data-c="
          &lt;p&gt;电阻阻值不是非常整齐的数值&lt;br&gt;
电阻标准由IEC（国际电工委员会）制定，标准文件为IEC60063。&lt;br&gt;
我们常用的阻值标准由E24和E96两种。 E24是5%精度的，数量较少，E96是1%精度的，数量较多（当然，如果某种电阻阻值是5%精度的，肯定能找到同阻值1%的，反之则不一定）。&lt;br&gt;
看一个公式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763390507962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
24或96就是公式中的字母n的值，m的范围为0≤m≤n-1，这样代入公式计算会得到n个基准值。&lt;br&gt;
所以，E24有24个基准值，E96有96个基准值，这些基准值再乘以10的x次方，就可以得到各种各样的电阻值了。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763390553614.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">硬件-电阻阻值标定</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ying-jian-0-ou-mu-dian-zu/"" data-c="
          &lt;p&gt;0欧姆电阻：根据EN60115-2电阻标准文件，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763390135470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
0Ω最大电阻偏差有三种可以选择，分别是10毫欧，20毫欧，和50毫欧。&lt;br&gt;
常用的普通0Ω电阻阻值最大不超过 50mΩ。&lt;br&gt;
几大厂家的普通0Ω电阻额定电流如下：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763390263886.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
额定电流综合可以参考：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1763390310044.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们看到，常规的电阻的电流都不大，按照综合后的最小值，最大的也就2A，如果设计电路时发现，我要用3A或4A的0Ω电阻，那怎么办呢？其实很简单，可以用2个0Ω电阻并联起来就行了。&lt;/p&gt;
">硬件-0欧姆电阻</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-kuai-jie-jian-ding-yi-she-zhi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1761990764697.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先备份&lt;br&gt;
用文本打开&lt;br&gt;
修改快捷键主要两个命令：funckey和alias&lt;br&gt;
alias ~N new 是ctrl+N新建文件（alias定义快捷键有加 ~ 号。那就是要 ctrl+定义的按键才有效)&lt;br&gt;
alias N new 是输入单个N ，然后回车才有效。&lt;br&gt;
funckey n new 按n键即可实现(不用回车)&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761991428000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761991559679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
重启软件发现功能旁边显示定义的快捷键按键&lt;/p&gt;
">Cadence-快捷键定义设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ddr/"" data-c="
          &lt;h1 id=&#34;区分&#34;&gt;区分：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;---DDR1：大片+圆口。&lt;/li&gt;
&lt;li&gt;---DDR2：小片+圆口。&lt;/li&gt;
&lt;li&gt;---DDR3：小片+方口。  1.5 V&lt;/li&gt;
&lt;li&gt;---DDR4：小片+方口、从有贴纸的方向看：DDR3的缺口在左边、DDR4的缺口在右边、DDR4将内存金手指设计为中间稍突出、边缘收矮。  1.2V&lt;/li&gt;
&lt;li&gt;---DDR5：1.1V&lt;/li&gt;
&lt;li&gt;从频率区分：&lt;/li&gt;
&lt;li&gt;---频率在400MHz以下 DDR1&lt;/li&gt;
&lt;li&gt;---频率在400到800MHz以内  DDR2&lt;/li&gt;
&lt;li&gt;---频率大于1000MHz  DDR3&lt;/li&gt;
&lt;li&gt;从PC区分：&lt;/li&gt;
&lt;li&gt;---PC：一代&lt;/li&gt;
&lt;li&gt;---PC2：二代&lt;/li&gt;
&lt;li&gt;---PC3：三代&lt;/li&gt;
&lt;li&gt;Kingston:金士顿&lt;/li&gt;
&lt;li&gt;---标签：KVR400K64C3A/512&lt;/li&gt;
&lt;li&gt;------频率为400MHz，容量为512M，DDR1&lt;/li&gt;
&lt;li&gt;------一代内存条有266MHz、333MHz、400MHz。&lt;/li&gt;
&lt;li&gt;---标签：KVR800D2N6/1G-SP&lt;/li&gt;
&lt;li&gt;------频率为800MHz，容量为1G，DDR2&lt;/li&gt;
&lt;li&gt;------二代内存条有533MHz、667MHz、800MHz。&lt;/li&gt;
&lt;li&gt;---标签：KVR1333D3N9/2G&lt;/li&gt;
&lt;li&gt;------频率为1333MHz，容量为2G，DDR3&lt;/li&gt;
&lt;li&gt;------三代内存条有1333MHz、1600MHz、2133MHz。&lt;/li&gt;
&lt;li&gt;---DDR4:2133MHz、2400MHz、2666MHz，2933MHz、最高可达3200MHz&lt;/li&gt;
&lt;li&gt;---DDR5:4800MHz、6000MHz、6400MHz、6600MHz、6800MHz、7200MHz、7600MHz、7800MHz、8400MHz。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;读内存条信息&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760535995272.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存条大小为8GB&lt;/li&gt;
&lt;li&gt;1R就是1个rank，x8就是一个颗粒提供8bit，1个rank64bit，64bit除于8bit就是8个颗粒，所以1r x8就是8颗粒的条&lt;/li&gt;
&lt;li&gt;PC4 DDR4&lt;/li&gt;
&lt;li&gt;2666MHz&lt;/li&gt;
&lt;li&gt;CPU数据总线的位宽，一般是64bit，这个位宽就称之为物理Bank。那么内存1RX4则表示1个64bit，X4则表示memory每颗内存颗粒的位数，&lt;br&gt;
从这里我们就可以很容易知道memory内存颗粒的个数为：64/4=16颗。&lt;br&gt;
如果是2rx8的话内存颗粒就是：64x2/8=16颗。&lt;br&gt;
如果是2rx4的话内存颗粒就是：64x2/4=8颗。&lt;br&gt;
如果是1rx8的话内存颗粒就是：64/4x2=8颗。&lt;br&gt;
知道了内存颗粒编码主要数位的含义，拿到一个内存条后就非常容易计算出它的容量。例如一条三星ddr内存，使用16片samsungk4h280838b-tcb0颗粒封装。&lt;br&gt;
颗粒编号第4、5位“28”代表该颗粒是128mbits，第6、7位“08”代表该颗粒是8位数据带宽，这样我们可以计算出该内存条的容量是128mbits(兆数位)×16片/8bits=256mb(兆字节)。&lt;br&gt;
注：“bit”为“数位”，“b”即字节“byte”，一个字节为8位则计算时除以8。关于内存容量的计算，文中所举的例子中有两种情况：一种是非ecc内存，每8片8位数据宽度的颗粒就可以组成一条内存；另一种ecc内存，在每64位数据之后，还增加了8位的ecc校验码。&lt;br&gt;
通过校验码，可以检测出内存数据中的两位错误，纠正一位错误。所以在实际计算容量的过程中，不计算校验位，具有ecc功能的18片颗粒的内存条实际容量按16乘。在购买时也可以据此判定18片或者9片内存颗粒贴片的内存条是ecc内存。&lt;br&gt;
原文链接：https://blog.csdn.net/weixin_33454551/article/details/112923766&lt;/li&gt;
&lt;li&gt;K4A4G085WD&lt;/li&gt;
&lt;li&gt;DDR颗粒&lt;br&gt;
先来讲讲逻辑BANK。芯片的内部，内存的数据是以位(bit)为单位写入一张大的矩阵中，每个单元格我们称为CELL，只要指定一个行(Row)，再指定一个列(Column)，就可以准确地定位到某个CELL，这就是内存芯片寻址的基本原理。这样的一个阵列我们就叫它内存的逻辑BANK(Logical BANK)。&lt;br&gt;
由于工艺上的原因，这个阵列不可能做得太大，所以一般内存颗粒中都是将内存容量分成几个阵列来制造，也就是说在内存颗粒中存在多个逻辑BANK，随着芯片容量的不断增加，逻辑BANK数量也在不断增加，目前从32MB到1GB的芯片基本都是4个,只有早期的16Mbit和32Mbit的芯片采用的还是2个逻辑BANK的设计，譬如三星的两种16MB芯片：K4S161622D （512K x 16Bit x 2 BANK）和K4S160822DT（1M x 8Bit x 2 BANK）。芯片组本身设计时在一个时钟周期内只允许对一个逻辑BANK进行操作，而不是芯片组对内存芯片内所有逻辑BANK同时操作。逻辑BANK的地址线是通用的，只要再有一个逻辑BANK编号加以区别就可以了（BANK0到BANK3）。一个逻辑BANK有8M个单元格（CELL），一些厂商（比如现代/三星）就把每个逻辑BANK的单元格数称为数据深度（Data Depth），每个单元格由8bit组成，那么一个逻辑BANK的总容量就是64Mbit（8M×8bit），4个逻辑BANK就是256Mbit，因此这颗芯片的总容量就是256Mbit（32MB）。&lt;br&gt;
原文链接：https://blog.csdn.net/jiajinkui1988/article/details/101904740&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760536989563.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778586679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4G：容量为4GBit，除以8等于512MB，&lt;br&gt;
08表示x8,8位数据带宽，64/8=8,8颗&lt;br&gt;
16Banks：16个逻辑Banks，每个单元格8bit，8 x bank数:16 x 芯片位宽:8 x bankgroup:4=4Gbit&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ddr1&#34;&gt;DDR1：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HY57V561620&lt;/li&gt;
&lt;li&gt;原理图封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742911439377.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;PCB封装（SOP+BGA)&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742912253572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742913904104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ddr2&#34;&gt;DDR2：&lt;/h1&gt;
&lt;p&gt;-H5PS1G63EFR&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742991202494.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-原理图封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742992601224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-PCB封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742993667401.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;ddr3&#34;&gt;DDR3：&lt;/h1&gt;
&lt;p&gt;-H5TC8G63CMR&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742993934485.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742993989950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-PCB封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742994322193.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;ddr4&#34;&gt;DDR4:&lt;/h1&gt;
&lt;p&gt;-K4A4G165WE-BCRC&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742994780978.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742994820096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-PCB封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742995085719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
################################################################&lt;/p&gt;
&lt;h1 id=&#34;ddr1和ddr2设计要点&#34;&gt;DDR1和DDR2设计要点：&lt;/h1&gt;
&lt;p&gt;1、所有信号连线过孔数为2，线宽一样，走线方向一致，平行走线不得交叉，弯线平滑处理，不得有直角、锐角；3W原则：线距要为线宽的2倍。&lt;br&gt;
2、等长差分线要先布好，例如时钟线。&lt;br&gt;
---地址线：CK、CK#、CK+、CK-&lt;br&gt;
---数据线：DQS&lt;br&gt;
3、以时钟线长度为基准，等长布其它信号线。&lt;br&gt;
忽略电源、地网络。&lt;br&gt;
4、DDR2可以分为三类：&lt;br&gt;
------差分时钟信号：CLK_N;CLK_P&lt;br&gt;
------数据线DQ0-DQ15,数据掩码信号DQM0,DQM1,数据选通信号DQS*_N,DQS*_P&lt;br&gt;
------地址线/控制线：除数据、时钟外的其他信号，如A0A12,WE,CS,BA02,CKE&lt;br&gt;
------Class规则设置：&lt;br&gt;
---------1、DATA_L_BUS：DQ0-DQ7、DQM0（数据掩码）、DQS0_N、DQS0_P（数据锁存）&lt;br&gt;
---------2、DATA_H_BUS：DQ8-DQ15、DQM1(数据掩码)、DQS1_N、DQS1_P（数据锁存）&lt;br&gt;
---------3、ADDR_BUS：除数据线外的其他信号&lt;br&gt;
---------4、CLK_DIFF：CLK_N,CLK_P&lt;br&gt;
------等长设计：&lt;br&gt;
---------1、所有信号线参考差分时钟的长度作等长&lt;br&gt;
---------2、DATA_L_BUS共11根走在同层，与差分时钟的长度误差在25mil&lt;br&gt;
---------3、DATA_H_BUS共11根走在同层，与差分时钟的长度误差在25mil&lt;br&gt;
---------4、ADDR_BUS:与差分时钟的长度误差200-300mil&lt;br&gt;
------其他要求：&lt;br&gt;
---------1、特性阻抗：单端50欧，差分100欧&lt;br&gt;
---------2、保证完整参考平面&lt;br&gt;
---------3、VREF电容要靠近相关的电源管脚，线宽尽量在40mil以上&lt;br&gt;
---------4、信号线不能跨分割&lt;br&gt;
---------5、DDR2走线区域不允许有其他信号穿过&lt;br&gt;
---------6、去耦电容要靠近相关IC的电源管脚&lt;br&gt;
---------7、尽量采用多层板&lt;br&gt;
5、DDR3、DDR4设计要点：&lt;br&gt;
------DDR信号线分组：&lt;br&gt;
将DDR布线的信号进行分组，可以分为时钟线、地址线、命令控制线、数据线四部分。&lt;br&gt;
(1)、时钟线的布线规则：为高速差分信号线，按照差分布线规则进行布线，而且需要在接收端进行阻抗匹配。&lt;br&gt;
(2)、地址线与命令控制线布线规则：地址和命令信号线要进行端接匹配，通过匹配电阻接端接电源VTT。&lt;br&gt;
(3)、数据线布线规则：数据线由于采用了ODT技术，因此不需要外部进行端接匹配。另外需要注意的是：对于时钟线、地址线、命令控制线和数据线，对等长布线要求较高，除了每一组信号线内部要求等长布线以外，还要保持时钟线、地址线和数据线等组间信号线尽量保持等长。尽量保持同组信号线保持在同层，避免跨层布线。对于差分信号线，为了避免信号间的串扰，要使用3W原则进行布线。除此之外，为了使DDR电路具备完整的参考地平面和电源平面，因此在DDR保护区内不得出现与DDR无关的信号且信号走线的参考平面不能中断。DDR的PCB单端走线阻抗一般控制为50欧，差分走线阻抗一般控制为100欧。对于多块DDR芯片的布局布线，根据菊花链的拓扑结构进行布置即可。&lt;br&gt;
------DDR时序同步：&lt;br&gt;
作为源同步系统的DDR电路设计来说，时序控制至关重要，共有三组时序设计要求如下：&lt;br&gt;
(1)、DQ和DQS的等长关系：所有数据线DQ参考DQS的差分线等长，DQS差分线误差控制在5mil，所有数据线误差控制在DQS目标长度的15mil。&lt;br&gt;
(2)、时钟CLK和地址线、命令控制线的等长关系：所有地址和命令控制线参考差分时钟线CLK等长，所有地址和命令控制线误差控制在时钟CLK目标长度的50mil。&lt;br&gt;
(3)、时钟CLK和DQS线的等长关系：对于DDR2来说，时钟CLK和DQS线的时序关系是松散的时序关系，它们之间的时序参数为，一般控制在100mil即可，但是在DDR3中，时钟CLK和DQS线的时序没有严格要求。&lt;br&gt;
------DDR终端匹配：&lt;br&gt;
ODT为内部核心终结引脚，从DDR2开始内存内部集成了终结电阻器，把原来在主板上的终结电路移植到了内存芯片内部。当内存芯片处于写数据状态时，此时内存颗粒是接收端，需要端接匹配电阻，因此需要打开ODT功能；同理当内存芯片处于读数据状态时，此时内存颗粒是发送端，不需要端接电阻，因此需要关闭ODT功能。正是有了ODT功能，DDR内存在PCB布线的时候数据线不需要进行端接匹配处理，因为内存芯片内部集成了端接电阻。&lt;br&gt;
------DDR电源：&lt;br&gt;
DDR一般需要3种电源，分别为：VDDQ、VREF、VTT。其中VTT和VREF的电平是一样的，为VDDQ电平的一半。VREF消耗的电流很小，可以通过分压电阻网络从VDDQ分压得到；而VTT是端接电源，电流会比较大，能达到百毫安级别，如果使用分压电阻功耗消耗过大，因此需要单独的DDR电源调节器芯片来生成VTT。VTT端接电源线的过流能力需要考虑周到，尽量加粗VTT的电源线以增强其载流能力。&lt;br&gt;
------等长的目的就是为了等时，绕等长时需要注意以下几点：&lt;br&gt;
1.确认芯片是否有Pin-delay,绕线时要确保Pin-delay开关已经打开；&lt;br&gt;
2.同组信号走在同层，保证不会因换层影响实际的等时；同样的换层结构，换层前后的等长要匹配，即时等长；不同层的传播延时需要考虑，如走在表层与走在内层，其传播速度是不一样的，所以在走线的时候需要考虑，表层走线尽量短，让其差别尽量小（这也是为什么Intel的很多GUIDE上面要求，表层的走线长度不超过250MIL等要求的原因）；&lt;br&gt;
3.蛇形绕线时单线按3W，差分按5W绕线（W为线宽）。且保证各BUS信号组内间距按3H， 不同组组间间距为5H （H为到主参考平面间距），DQS和CLK 距离其他信号间距做到5H以上。&lt;/p&gt;
&lt;h1 id=&#34;ddr4引脚&#34;&gt;&lt;strong&gt;DDR4引脚&lt;/strong&gt;&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760777012118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;电源：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778328615.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;控制信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778633477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;时钟信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778687584.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;地址信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778722292.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;数据信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760778752543.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
参考博客：https://blog.csdn.net/huibei_wuhan/article/details/119945655&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760779115574.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可知K4A4G085WD有16个Banks，分为4个Bank Group，A[0:16]17根地址线，2个BA，2个BG，2个BG可选择四个Bank Group，每个Bank Group又分为4个Bank，2个BA可选择四个Bank，分配了四个地址线BA0\BA1\BG0\BG1，还有17根地址线，选择其中1根表示传输地址是否为行地址。按照参考博客，1个BANK可分为67108854个=64M个地址编号，每个地址空间，使用8个数据线，一次存储8bit数据。&lt;br&gt;
所以1个BANK可以分为65536行，每行1024列，每个存储单元16bit。&lt;br&gt;
每行可以存储1024x8bit=8192B=1KB，每行的存储容量成为Page Size。&lt;br&gt;
单个BANK共65536行，所以每个BANK存储容量为65536x1KB=64MB。&lt;br&gt;
一个BANK GROUP有四个BANK，一个BANK GROUP可存储256MB。&lt;br&gt;
每个DDR4颗粒有4个BANK GROUP，每颗存储容量为1GB。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;layout-guide&#34;&gt;Layout Guide：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;数据线最大长度不要超过2500mil，组内长度误差控制在+-5mil以内，DQS和时钟线无长度误差要求&lt;/li&gt;
&lt;li&gt;地址线误差控制在+-20mil&lt;/li&gt;
&lt;li&gt;DQS、时钟查分对误差控制在+-3mil，设计阻抗时，使本对内间距不超过2倍线宽（4-5mil）&lt;/li&gt;
&lt;li&gt;DQS是数据的同步信号，走线时要和DQ放到一起&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9片DDR4颗粒，每片8位数据带宽，1R为64位，共8片组成一条内存，外加一片ECC，共9片组成一条内存&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760783081608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760783984997.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信号分组：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760784543341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760784926688.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760784990703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
地址信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760785189344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
数据信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760785527511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
电源&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760786061673.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
差分信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760786747637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760787046499.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布局&lt;br&gt;
采用Fly-by的拓扑结构，不可使用T型，拓扑过孔到管脚的长度尽量短，长度在150mil左右&lt;br&gt;
先走出DQS_P和DQS_N差分&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">DDR</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ddr-sodimm/"" data-c="
          &lt;p&gt;颗粒位宽：X8&lt;br&gt;
每通道RANK数：2&lt;br&gt;
每通道位宽：16&lt;br&gt;
含ECC&lt;br&gt;
两个RANK正反贴，TOP面为RANK0，BOT面为RANK1，DQ、ADDR等信号共用过孔，为了缩短颗粒表层焊盘和走线，需对信号进行调整，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765711640732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765711682428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765711769081.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765711800363.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DDR扇出&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765712220149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765712252432.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DM和DQS信号不可调整，因此DM、DQS信号fanout走线略长。但在3200速率及以下，这种长度不会对信号质量产生影响。&lt;br&gt;
控制信号和地址信号，RANK0和RANK1有各自的CLK、CS、CKE、ODT信号，为了方便走线，需对RANK1 进行镜像，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765712784728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对应上图原理图中已进行镜像，如果使用地址镜像，在BIOS下需对应勾选MIRROR选项&lt;br&gt;
每组DQ信号以DQS信号为target，误差控制在+-5ps内（+-30mil），1ns走线长度一般为6000mil。&lt;br&gt;
在每组末端，需对控制信号和地址信号进行VTT上拉，通过接33欧姆电阻上拉到VTT，末端匹配的目的是为了减少信号的反射和回波&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765713464556.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1765713486610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1761459764033.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761459827708.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761459860835.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761744907000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图为18片DDR4，其中2片为实现ECC检查功能，组成260Pin内存条&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;电源参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761744951372.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电源滤波电容值&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745013592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VPP-GND&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745070901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VDD-GND&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745111349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VDD-VREFCA&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745197972.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZQ下拉电阻&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745233556.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VPP-GND&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745299214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;据线DQ阻抗匹配电阻&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745332696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
滤波电容尽量靠近管脚放置，走线应先通过电容再连接到颗粒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VTT上拉电阻应尽量靠近最后一个DRAM，每一个上拉电阻至少要有一个VDD去耦电容器&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745379151.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有信号组采用Fly-by拓扑&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745411558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号线分组&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745488886.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POWER&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745521153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745569700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745629118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745656294.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745693482.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;差分&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745719787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Physical规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745749215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Space规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745778234.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;创建等长&#34;&gt;创建等长&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;先创建PPr&lt;br&gt;
ECC的数据线CB、DMI、DQ数据信号、DQS差分信号，先创建Xnet，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745851065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745870295.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745890244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761745973224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761746016306.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建MGrp，每一组信号由8位数据线、DMI数据掩码、DQS差分走线组成&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761746326401.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761746403285.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所有数据线DQ参考DQS的差分线等长，DQS差分线误差控制在5mil，所有数据线误差控制在DQS目标长度的15mil。&lt;br&gt;
地址线走菊花链，分段设置等长&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913224848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913309783.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913394160.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置260PIN到U4、U4-U2、U2-U3、U3-U5、U5-U18、U18-U6、U6-U8、U8-U9、U9-U7的等长组&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913678863.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
等长组包括：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913726581.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913790486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加CLK信号&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762692414567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同理底层9颗DRAM也是一样&lt;br&gt;
ALERT_N要从第一个到最后一个再回到金手指&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761913870322.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;DQ走线&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761919357456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DQS差分组内等长误差控制在5mil左右，即0.127mm，DQ数据线误差控制在DQS长度的15mil，即0.381mm&lt;br&gt;
其中Actual+Margin=Delta&lt;br&gt;
把每一组数据线等长组设置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761920371500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761920416769.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761920454061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走出每一组，选择其中最长的作为目标长度&lt;/li&gt;
&lt;li&gt;第一组DDR数据线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761926848952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同组走同层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761926896133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761932515713.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同层等长&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761932566846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;ADDR走线&lt;/strong&gt;&lt;br&gt;
所有地址和命令控制线参考差分时钟线CLK等长，所有地址和命令控制线误差控制在时钟CLK目标长度的50mil&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762008625173.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走完两组数据线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762008679910.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
前两组数据线走第10层&lt;/li&gt;
&lt;li&gt;ALERT和RESET信号不需要做等长&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762525792968.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762525860281.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762525900669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在第三层和第10层走数据信号&lt;/li&gt;
&lt;li&gt;ALERT信号要先从最后一个DRAM开始&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762526866611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;时钟CLK和地址线、命令控制线的等长关系：所有地址和命令控制线参考差分时钟线CLK等长，所有地址和命令控制线误差控制在时钟CLK目标长度的50mil。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1762563092948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">DDR-SODIMM（DDR4）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-die-ceng-zhi-shi/"" data-c="
          &lt;h1 id=&#34;叠层菜单&#34;&gt;叠层菜单&lt;/h1&gt;
&lt;p&gt;叠层在SETUP-&amp;gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761314771231.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761448363815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761448429383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Layer&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Surface&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Conductor&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般电气层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Dielectric&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;绝缘层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Plane&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;平面层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Thickness&lt;br&gt;
厚度&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449005039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Physical&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449053320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Physical&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Material&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;叠层材质&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Negative Artwork&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;No fillet&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无圆角&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Unused Pin Suppression&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;去掉没有使用的焊盘外盘，无盘孔，做封装焊盘时需勾选&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Unused Via Suppression&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;去掉没有使用的过孔外盘，无盘孔，做封装焊盘时需勾选&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Embedded&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449377031.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
允许元件嵌入板子内层，国内没有做的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Signal Integrity&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761449571958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Signal Integrity&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Conductivity&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;层的电导率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Dielectric Constant&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;介电常数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Width&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;层的布线线宽定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Impedance&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置叠层上的走线阻抗，线宽会自动计算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Loss Tangent&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;介电损耗值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Shield&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将当前层改成屏蔽层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Freq. Dep. File&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;频率相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Etch Factor&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;层角度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Diff Coupling Type&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指定差分线耦合类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Diff Space&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;差分线线距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Diff Z0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;差分线阻抗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SI Ignore&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;忽略SI，SI分析时不考虑这一层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">Cadence-叠层知识</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-orcad-tian-jia-chi-ye-lian-jie-fu-mei-you-zuo-yong/"" data-c="
          &lt;p&gt;在绘制原理图的时候，想采用Bus总线连接，却发现有些能直接用，今天怎么连都没有连上，查找网络永远只有一个，下班回家发现加了Bus入口依旧一样，苦思终于发现原因在于DQ[63:00]中把DQ00检测为DQ0，而我的Net是DQ00，自然而然采用Bus总线会连不上了😓😓😓&lt;br&gt;
把前缀的0去掉就好了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761138057235.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761138664791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1761138694500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不是一个了&lt;/p&gt;
">Cadence-ORCAD添加离页连接符没有作用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/github-la-qu-wen-jian/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760973780230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Github-拉取文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/github-shang-chuan-xiang-mu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新建仓库&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760965761831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定用户&lt;br&gt;
git config --global user.name &amp;quot;mygithubma&amp;quot;&lt;br&gt;
git config --global user.email &amp;quot;1207748726@qq.com&amp;quot;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966177349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加文件到仓库&lt;br&gt;
git add .    添加所有文件&lt;br&gt;
git add DDR4_SODIMM_SPEC.pdf  添加单个文件至仓库&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966315038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加注释&lt;br&gt;
git commit -m &amp;quot;XXX&amp;quot;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966369974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程连接&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966420275.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push&lt;br&gt;
git push origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966894349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966923453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
-报错error: remote origin already exists.&lt;br&gt;
删除名为origin的远程仓库&lt;br&gt;
git remote rm origin&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966742155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760966818794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除已经add到缓存区的某个文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760967406867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里我之前已经将PDF里面的文件添加到远程仓库了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760967478801.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
git reset XXX  可以将添加到缓存区的文件恢复出来&lt;br&gt;
git reset可以返回已经添加的所有文件，撤销git add .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前分支&lt;br&gt;
git branch&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760969788163.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-创建新分支&lt;br&gt;
git checkout -b lib&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766818971903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;切换分支&lt;br&gt;
git checkout master1&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760969838840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除分支&lt;br&gt;
git branch -d lib&lt;br&gt;
git branch -D lib 强制删除lib分支&lt;br&gt;
这样删除只是删除了本地分支&lt;br&gt;
删除远程分支&lt;br&gt;
git push origin --delete lib&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766821042570.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-显示分支&lt;br&gt;
git branch -a&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766820174020.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我有两个lib main的本地分支和两个remotes/origin/lib和remote/origin/main的远程分支&lt;/p&gt;
&lt;p&gt;gitbranch -r&lt;br&gt;
显示远程分支&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看当前状态&lt;br&gt;
git status&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760969890873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970335471.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pull时报错fatal: couldn&#39;t find remote ref master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970723173.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
github仓库默认分支为main，git init默认为master&lt;br&gt;
git fetch&lt;br&gt;
git branch -r  查看远程分支&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970824897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
远程分支为main，本地分支为master&lt;br&gt;
git branch -m master main  重新命名本地分支&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760970900013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git add .空白文件夹无法添加&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760971314461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git push报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760972742841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
git push origin main --force&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git提交文件到暂存区后commit后不会显示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1766831339696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
大功告成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Github-上传项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-wu-pan-kong-she-ji/"" data-c="
          &lt;p&gt;如果BGA间距非常小，可以采用无盘孔设计&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448656504.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在叠层设置勾选，发现报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448791051.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设勾选&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448960753.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
效果&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448974690.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在第二层没有连线的via会不显示外框&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760449073883.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个间距受规则控制（一般用8mil以上，建议最小大于6.5mil）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760449148441.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-无盘孔设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-guang-hui-she-zhi-bao-cun-xia-ci-zhi-jie-diao-yong/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447749291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加光绘所需要的class后，选中全部&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447806279.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447856805.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下次出文件时，可以直接调用&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447889321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-光绘设置保存，下次直接调用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-kai-cao/"" data-c="
          &lt;p&gt;开槽前必须拦截所有层的铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363844526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363937818.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760364085195.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760364108970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-开槽</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-hui-fu-shan-chu-de-wei-hao/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760362724069.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760362752350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
切换回General Edit模式，更新symbols&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760362818471.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种方法会更新所有该封装的器件&lt;br&gt;
第二种方法&lt;br&gt;
切换回布局模式Placement edit&lt;br&gt;
选中器件右击&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363042593.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760363078993.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种方法只会更新选中的器件&lt;/p&gt;
">Cadence-恢复删除的位号</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-6-ceng-fpga-he-xin-ban-chu-gerber/"" data-c="
          &lt;h1 id=&#34;etch层&#34;&gt;ETCH层&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TOP&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760443699077.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
CUTOUT：若有开槽添加&lt;br&gt;
OUTLINE：旧版本Allegro的板框层&lt;br&gt;
DESIGN_OUTLINE：新版本Allegro板框层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BOTTOM&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760443800515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L2_GND&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760443962846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L3_SIG&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444023620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L4_VCC&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444066087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L5_GND&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444138410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;silkscreen&#34;&gt;SILKSCREEN&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444497454.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;soldermask&#34;&gt;SOLDERMASK&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760444716915.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;pastemask&#34;&gt;PASTEMASK&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445343137.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;生成钻孔表&#34;&gt;生成钻孔表&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445443941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
钻孔较少时，随便输入一个不重复的符号，给定个大小即可&lt;br&gt;
若有很多钻孔且重复了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445532526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760445784789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其他默认&lt;br&gt;
钻孔表&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760446013748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760446147219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加完后在光绘叠层里面添加&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760447492010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改未定义的线宽&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448149993.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
绘制光绘文件出的框&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448288186.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448345982.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
确认铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760448404868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检查&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452439869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452206833.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
生成钻孔文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452578442.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
出槽孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452652600.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
板子没有槽孔因此没有.rou文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760452707840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;出项目生产文件&#34;&gt;出项目生产文件&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新建文件夹&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451335074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加装配class，焊接加工文件&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451393970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导出顶层装配图&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451606901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451636866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
底层装配图需先镜像PCB&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451788382.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451928348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760451976002.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还需添加坐标文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453958131.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Ctrl+A全选，复制粘贴到Excel表格里面&lt;br&gt;
可以进行筛选在顶层还是底层（做封装时把原点设置在器件中心）这种方法是器件以每个封装的原点为中心的坐标&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454118643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
另一种方法&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454340468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若封装的原点未在中心，可以选择Body center，缺点这样是txt文本格式，但是板厂会处理&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454481622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;导出DXF&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453191580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453286035.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工艺文件&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453512410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;钢网文件&lt;/strong&gt;&lt;br&gt;
从导出的GERBER里面复制出这两层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760453794047.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;导出bom&#34;&gt;导出BOM&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454711619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Header:   Item\tQuantity\tReference\tPart\tPCB Footprint&lt;br&gt;
Combined property string:   {Item}\t{Quantity}\t{Reference}\t{Value}\t{PCB Footprint}&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760454950149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760455071825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
整理&lt;/p&gt;
">Cadence-6层FPGA核心板系统性出Gerber、生产文件、BOM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-jing-zhen-bao-di-wa-kong-tong-pi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760361325767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760361525169.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-晶振包地、挖空铜皮</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-bga-feng-zhuang-zheng-mian-bu-jian-yi-pu-tong/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355438491.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
BGA封装正面顶层不建议铺铜，焊接时容易导致受热不均&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355626474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
切换到顶层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355700253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760355900746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356095440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
或者采用&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356175934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意:&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356351801.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
采用菜单里面的shape虽然也能挖空铜皮，但是会报出很多DRC错误&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356430613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走线距routekeepout区域报错，相当于把走线也拦截了&lt;br&gt;
这种情况下，选中这个区域，右键属性里面添加&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356601474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错没了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760356730787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而用另一种添加的会自动添加允许走线过孔的属性&lt;/p&gt;
">Cadence-BGA封装正面不建议铺铜</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-unassigned-shapes/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760279557844.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Z-COPY多次铺铜铺到同一层，删除重新铺&lt;/p&gt;
">Cadence-unassigned shapes</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-status-bao-cuo-out-of-date-shape/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270113896.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
有个黄色报警&lt;br&gt;
该报警为有一块铜皮没删干净或一块铜皮被另一块铜皮包围&lt;br&gt;
点击黄色小方块，会弹出窗口，点击其中的坐标会自动跳转到报错的地方&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270375466.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
也可以通过这里&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270708757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270486055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改一下铜皮显示效果，更容易看到报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270547850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760270908726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开颜色设置，勾选对应层的bound层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760271096776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到这里多出一块没有删除干净的&lt;br&gt;
但是选择shape发现无法选中这一块&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760271589837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过菜单栏选中，Edit一下，放大点铜皮区域。然后就可以选择shape进行删除重新铺铜了&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760272252096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-Status报错Out of date  shape</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-tong-pi-nei-suo/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760268861877.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
铺铜皮时通过ROUTE KEEPIN层Z-COPY&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760268958574.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错&lt;br&gt;
将铜皮内缩&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760269025339.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
切换为铜皮编辑模式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760269104252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760269161277.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-铜皮内缩</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-duo-gen-zou-xian-jian-ju-zi-dong-dui-qi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760012918868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
多根走线让其间距自动对齐&lt;br&gt;
复制两个过孔放在两边&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760013007115.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760013046381.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先点击菜单栏，然后点击两个过孔&lt;/p&gt;
">Cadence-多根走线间距自动对齐</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-bga-zou-xian-ju-zhong-chu-xian-bao-hu-dai/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1760012614456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
BGA出线在两个焊盘之间，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1760012772684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-BGA走线居中出线、保护带</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-yin-cang-mou-ge-wang-luo-de-fei-xian-bu-xian-shi/"" data-c="
          &lt;p&gt;隐藏某个网络的飞线，不管怎样都不显示出来&lt;/p&gt;
&lt;h1 id=&#34;1-分配属性&#34;&gt;1 分配属性&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910850705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分配一个属性给Net&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910918440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
需要显示时删除这个分配的属性&lt;/p&gt;
&lt;h1 id=&#34;2-规则设置&#34;&gt;2 规则设置&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759911042739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Cadence-隐藏某个网络的飞线不显示</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-fei-xian-lian-jie-fang-shi-geng-gai/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910535183.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认最近的飞线连接方式显示为这样&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910600214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
改变该选项&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759910664150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-飞线连接方式更改</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-si-yin-wei-zhi-tong-yi-diao-zheng/"" data-c="
          &lt;p&gt;布线完成后统一修改REF位置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759834858837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开PCB文件时勾选&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759834925621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选后才会有此选项&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835007098.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835037881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Limit layers后显示如图&lt;br&gt;
保持此界面不退出&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835126520.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在PCB界面设置如图，选中整个板子&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759835171432.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
会发现所有丝印都恢复到器件中心，Dx Dy偏移也可以设置&lt;/p&gt;
">Cadence-丝印位置统一调整</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-guang-hui-ceng-de-she-zhi/"" data-c="
          &lt;h1 id=&#34;1-添加光绘层叠的内容&#34;&gt;1、添加光绘层叠的内容&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;线路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BOARD GEOMETRY/OUTLINE：板框&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/DESIGN_OUTLINE：新版本的板框&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/CUTOUT：板内挖槽孔&lt;/li&gt;
&lt;li&gt;ETCH/TOP：走线&lt;/li&gt;
&lt;li&gt;PIN/TOP：焊盘&lt;/li&gt;
&lt;li&gt;VIA CLASS/TOP：过孔&lt;br&gt;
&lt;em&gt;其他层按TOP设置&lt;/em&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416389969.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416427107.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;丝印&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/OUTLINE：板框&lt;/li&gt;
&lt;li&gt;BOARD GEOMETRY/SILKSCREEN_TOP：顶层丝印&lt;/li&gt;
&lt;li&gt;PACKAGE GEOMETRY/SILKSCREEN_TOP：顶层丝印&lt;/li&gt;
&lt;li&gt;REF DES/SILKSCREEN_TOP：顶层位号丝印&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416498240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759416527932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;阻焊（绿油层）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
">Cadence-光绘层的设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-mang-mai-kong-de-she-zhi-fang-fa/"" data-c="
          &lt;p&gt;对于板子比较密集的情况会用到盲埋孔&lt;br&gt;
盲埋孔只需要做两种孔：激光孔、通孔&lt;br&gt;
盲孔：表层到表层的下一层（不打穿的孔），属于激光钻孔，采用4-10过孔（钻孔4mil，焊盘10mil）&lt;br&gt;
埋孔：8-16过孔（钻孔8mil，焊盘16mil）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759413682894.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759414665041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BBVia Padstack：命名盲埋孔&lt;/li&gt;
&lt;li&gt;Padstack to copy：选择过孔封装&lt;/li&gt;
&lt;li&gt;Start Layer：起始层&lt;/li&gt;
&lt;li&gt;End Layer：结束层&lt;/li&gt;
&lt;li&gt;Add BBvia：新增盲埋孔&lt;br&gt;
在规则设置VIA中添加新增的盲埋孔&lt;br&gt;
BB VIA命名：VIA1_2  VIA5_6  VIA2_5&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759414931141.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
走线时Options处须为盲埋孔起始层和结束层，否则会找不到添加的盲埋孔&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759415017741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759415039771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加的盲埋孔会显示起始层 和结束层，Visibility处Via选择其它层会看不到盲埋孔&lt;/li&gt;
&lt;/ul&gt;
">Cadence-盲埋孔的设置方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-shu-chu-zheng-fan-qi-jian-fen-chi-qing-dan/"" data-c="
          &lt;p&gt;输出正反器件BOM&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759412854586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Tools-&amp;gt;Quick Reports-&amp;gt;Component Reports&lt;br&gt;
点击报告内页，Ctrl+A全选，Ctrl+C复制全部，粘贴到Excel表格中，筛选出SYM_MIRROR为NO是表层的元器件，YES是底层元器件&lt;/p&gt;
">Cadence-输出正反器件分离清单</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-xian-shi-yu-yin-cang-tong-pi/"" data-c="
          &lt;p&gt;铜皮显示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759412579961.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no_etch_shape_display：不显示铜皮&lt;/li&gt;
&lt;li&gt;no_shape_fill：不填充铜皮&lt;/li&gt;
&lt;li&gt;no_shape_fill_dyn_ood：铜皮完全填充&lt;/li&gt;
&lt;li&gt;old_shape_fill_style：旧的铜皮效果&lt;/li&gt;
&lt;/ul&gt;
">Cadence-显示与隐藏铜皮</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-she-zhi-dan-du-guan-jiao-de-tong-pi-lian-jie-fang-shi/"" data-c="
          &lt;p&gt;铺铜时设置某个管脚与铜皮的连接方式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410696326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Edit-&amp;gt;Properties-&amp;gt;Find面板选择Pins&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410778577.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410809653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759411778832.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759411857582.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
改为对角线连接和8路连接&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759411930890.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Orthogonal：十字连接&lt;/li&gt;
&lt;li&gt;Diagonal：对角线连接&lt;/li&gt;
&lt;li&gt;Full_contact：全连接&lt;/li&gt;
&lt;li&gt;8_way：8路连接&lt;/li&gt;
&lt;li&gt;None：无&lt;/li&gt;
&lt;/ul&gt;
">Cadence-设置单独管脚的铜皮连接方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-xi-tong-fei-mo-ren-subclass-tian-jia-yu-shan-chu/"" data-c="
          &lt;h1 id=&#34;添加子层&#34;&gt;&lt;strong&gt;添加子层&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410275421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410329001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入DXFF，点击ok&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410380922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到在Board Geometry下多出Dxff层&lt;/p&gt;
&lt;h1 id=&#34;删除子层&#34;&gt;&lt;strong&gt;删除子层&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;删除子层时要先删除子层上的所有，否则会报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759410499883.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
删除后在Options下看不到Dxff层了&lt;/p&gt;
">Cadence-系统非默认Subclass添加与删除</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-jian-bian-xian-tian-jia/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759408520259.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在箭头处添加渐变&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759408570130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759408903125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选箭头处，否则会报错，如果报错，检查是否勾选&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759409061553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Add Tapered trace后点击要添加的Cline处&lt;br&gt;
删除渐变线如上菜单中选择Delete&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759409884741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选Run后会整板添加&lt;/p&gt;
">Cadence-渐变线添加</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zi-dong-dao-chu-yan-se-she-zhi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759407188586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759407231990.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
.prm文件为颜色设置文件，在新的pcb文件中导入Parameters文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Design Setting：设计参数&lt;/li&gt;
&lt;li&gt;Artwork：光绘叠层&lt;/li&gt;
&lt;li&gt;Color Layer：层的颜色&lt;/li&gt;
&lt;li&gt;Color Palette：调色板的颜色&lt;/li&gt;
&lt;li&gt;Color Net：网络颜色&lt;/li&gt;
&lt;li&gt;Text Size：文本大小&lt;/li&gt;
&lt;li&gt;Application or Command Parameters：应用程序或命令参数&lt;/li&gt;
&lt;/ul&gt;
">Cadence-自动导出颜色设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zi-dong-bao-cun/"" data-c="
          &lt;p&gt;&lt;strong&gt;1、Allegro自动保存&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759407046333.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-自动保存</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zou-xian-kuan-du-ji-yi-gong-neng/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759058674065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
allegro走线时改变options中的line width后会保留下次走线时的宽度，不想保留，按照规则设置的宽度走线&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759058788032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759058837555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选acon_no_width_override_retain&lt;br&gt;
后续走线会按照规则默认设置的宽度&lt;/p&gt;
">Cadence-走线宽度记忆功能</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-bga-feng-zhuang-guo-kong-shan-chu/"" data-c="
          &lt;p&gt;Route-&amp;gt;create fanout&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758552719453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择top-&amp;gt;bottom&lt;br&gt;
选择过孔类型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758552825736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择扇出方向&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758552982501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Find选中Pin给单个焊盘扇出，选中器件给整个器件进行扇出&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553043159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若是要删除扇出的过孔和走线，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553284680.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
会发现无法删除&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553319486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553349437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
已删除的Pin会高亮，点击之后就可以进行删除&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758553405757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-BGA封装过孔扇出</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-qu-yu-gui-ze/"" data-c="
          &lt;p&gt;在BGA封装器件下走线，间距采用区域规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758200897903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758200929579.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758200974593.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择区域规则&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1758201041229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置间距&lt;/p&gt;
">Cadence-区域规则</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-jing-tai-tong-pi-bi-rang-guo-kong/"" data-c="
          &lt;p&gt;在铺静态铜皮后，添加过孔会报短路的错误&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941123163.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941248564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
铜皮避让&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941309728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中铜皮&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941348192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941400313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941425022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若显示异常&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941496567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757941527290.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-静态铜皮避让过孔</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-she-xing-zou-xian/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751671155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751707430.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751779673.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757751822371.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757752401954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
规则设置打开等长和差分显示&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757753327585.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757753389768.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757753434269.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757754494110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757754659842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Total Etch Length: 这个net 上面已经绕线的长度。&lt;/li&gt;
&lt;li&gt;Total Path Length: 这个net 上面已经绕线的长度加上尚未完成部分的Manhattan&lt;br&gt;
长度。&lt;/li&gt;
&lt;li&gt;Total Manhattan Length:走直角绕线的长度 (水平绕线加上垂直绕线长度)&lt;/li&gt;
&lt;/ul&gt;
">Cadence-蛇形走线</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-she-zhi-zou-xian-de-gui-ze/"" data-c="
          &lt;h1 id=&#34;创建差分对&#34;&gt;创建差分对&lt;/h1&gt;
&lt;p&gt;在规则管理中，Electrical-&amp;gt;Net-&amp;gt;Differential Pair中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343686996.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343703237.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343719869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343738712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建class&#34;&gt;创建Class&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343765933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343783387.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建ngrp&#34;&gt;创建NGrp&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343818226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343827608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343923690.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343932650.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建xnet&#34;&gt;创建Xnet&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343971671.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击OK-&amp;gt;YES&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757344165055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建C642两端的Net为XNet&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757344266187.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757344194193.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757342874349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在Ref中填写C642，按一下Tab键，选中器件，点击Create Model&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343071109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击ok&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343115125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击ok&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343373951.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757343408927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建等长&#34;&gt;创建等长&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1757678848146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757679752320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757679861035.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建PPr&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757680569671.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757680829170.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;PPr需要在Bus下才会显示&lt;/p&gt;
">Cadence-设置走线规则</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-li-mian-fang-zhi-yuan-li-tu-li-mian-mei-you-de-feng-zhuang/"" data-c="
          &lt;p&gt;1、在菜单Setup-&amp;gt;User Preference&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757258592837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使能这个&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261199288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261228880.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择合适的symbols，打钩&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261251605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261336669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-PCB里面放置原理图里面没有的封装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-geng-xin-yi-fang-zhi-qi-jian-de-pcb-feng-zhuang/"" data-c="
          &lt;p&gt;如图，将箭头所指的pcb封装替换为另一种，选中封装查看为C0805，将其更新为另一种小的C0805封装&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756990991840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在Setup-&amp;gt;User Preference中PATH下，将新封装所在路径调到前面&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756991168048.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756991217500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意，已锁定的器件需勾选额外的&lt;br&gt;
点击Refresh&lt;/p&gt;
">Cadence-更新已放置器件的PCB封装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-fu-yong-mo-kuai/"" data-c="
          &lt;p&gt;首先布局好其中一个模块，将另一个模块的所有器件都集中到一起，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561259343.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
框选布局好的器件，右击&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561318810.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
右键Done，然后再单击一下，弹出界面‘&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561451312.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择未布局的器件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561512042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756561619923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Unmatched的需要手动对应，取消选择Device name，依次选择器件在右侧对应好，单击OK&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756564455160.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756564540144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加了复用模块属性的器件无法自由移动，若要移动&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261784309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，该器件无法移动，首先切换至placement edit模式，在super filter下选择Module&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261848027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757261917848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
框选要移动的器件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757262216592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1757262369332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样即可移动&lt;/p&gt;
">Cadence-复用模块</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zhi-zuo-flash-symbol/"" data-c="
          &lt;p&gt;打开PCB Editor，File-&amp;gt;New&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756385402942.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ADD-&amp;gt;Flash&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756385959644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置内径、外径、连接宽度&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386167393.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386251688.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
制作焊盘&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386795657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756386852192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-制作Flash symbol</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-zhi-zuo-bu-gui-ze-han-pan/"" data-c="
          &lt;p&gt;打开PCB Editor，选择File-&amp;gt;New&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756382395564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756382474062.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
依次输入坐标&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756382895061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
继续新建一个symbol，外扩5mil用于制作Soldermask层&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756383839924.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开PAD STACK&lt;br&gt;
File-&amp;gt;New&lt;br&gt;
BEGIN LAYER设置如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756384149352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MASK LAYER设置如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756384267076.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Save&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756384492304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-制作不规则焊盘</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-orcad-xin-jian-titleblock/"" data-c="
          &lt;p&gt;在olb库下新建symbol&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756305249842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设计自己的TitleBlock&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756305612341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756306161361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以在这里点击添加属性&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756306235551.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
place选择Title Block，Add Library，放置即可&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756306273590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-Orcad新建TitleBlock</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-feng-zhuang-dao-step-mo-xing/"" data-c="
          &lt;h1 id=&#34;1-添加默认黑盒子模型&#34;&gt;1、添加默认黑盒子模型&lt;/h1&gt;
&lt;p&gt;Cadence在制作封装时可以添加3D模型&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125171167.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在使用Allegro制作pcb封装时会添加PLACE_BOUND_TOP来生成默认的模型，该模型可以通过设置来改变其高度&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125266958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125314567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
观察一下此时的模型效果图&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125405444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若添加了PLACE_BOUND_TOP但是没有显示，可能是没打开&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125478635.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125534923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里其他几项也可以根据理解知道是什么意思&lt;/p&gt;
&lt;p&gt;2、添加真实STEP模型&lt;br&gt;
推荐一个可以下载模型的网站：&lt;br&gt;
https://componentsearchengine.com/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756125842991.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不仅可以下载STEP模型，还可以下载Cadence、AD等软件的pcb封装等等&lt;br&gt;
找到step后缀的文件，可以使用SW打开看看&lt;br&gt;
首先要在软件中设置steppath&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126039379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126101293.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在这里设置好step所在路径&lt;br&gt;
在setup下选择&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126156888.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击path可查看当前设置的step路径，发现和前面设置的为同一个路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126245039.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为封装选择对应的step模型，右侧窗口可预览&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;view ：观察视角，有十种观察视角可以进行选择&lt;/li&gt;
&lt;li&gt;Transparent ：可选择None、Symbol、STEP、Both，显示设置&lt;/li&gt;
&lt;li&gt;Overlay，选中表示默认黑盒子和导入的step封装同时显示，取消选中预览窗口会分成两部分分别显示&lt;/li&gt;
&lt;li&gt;Hide board ：隐藏板子&lt;/li&gt;
&lt;li&gt;STEP color ：选中表示STEP颜色设置为黑色&lt;/li&gt;
&lt;li&gt;Primary/Secondary STEP Model ：两种STEP模型，即同一个PCB封装可以分配两种模型，使用时可以进行选择来分别显示&lt;/li&gt;
&lt;li&gt;Map STEP Model ：模型坐标及旋转角度&lt;/li&gt;
&lt;li&gt;Arrow key increment ：前后左右调整&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置好后点击save&lt;br&gt;
点击3D预览，若发现依旧是默认的黑盒子模型，别急，只是显示效果还没调整，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756126964838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在上图中选择only the step model，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756127029595.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样即为pcb封装添加了3D模型&lt;/p&gt;
">Cadence-PCB封装导STEP模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-dao-ru-zi-ding-yi-tu-pian-si-yin-logo/"" data-c="
          &lt;p&gt;工具介绍：RATA Raster (BMP) To Allegro (IPF)&lt;br&gt;
可将位图BMP转换为IPF格式&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756040568974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击左下角Select BMP file导入黑白图片&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756041563158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Pick color选择阴阳模式，选择白色图中黑色线条不加丝印，白色部分加丝印，选择黑色，黑色部分为丝印&lt;br&gt;
点击Make out plt输出，在bmp文件同名文件夹下，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756041722400.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756041802631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种显示方式为那个工具选择黑色，选择白色即为反色&lt;br&gt;
Scale为大小&lt;br&gt;
https://gitee.com/ma-zhenchun/allegro-logo-tool&lt;/p&gt;
">Cadence-导入自定义图片丝印logo</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-dao-chu-gerber/"" data-c="
          &lt;h1 id=&#34;1-检查drc&#34;&gt;1、检查DRC&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020172972.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Display，选择Status，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020237511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检查相关DRC错误，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020299227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可通过Tools工具下的Quick Reports找到DRC报错位置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020388258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-更改gerber导出路径&#34;&gt;2、更改Gerber导出路径&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020699404.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在菜单栏Setup-&amp;gt;User Preferences下找到File_management目录，设定ads_sdart为gerber，在导出gerber的时候会自动在pcb文件目录下创建名为gerber的文件夹&lt;/p&gt;
&lt;h1 id=&#34;3-生成钻孔表&#34;&gt;3、生成钻孔表&lt;/h1&gt;
&lt;p&gt;给不同尺寸的孔分配不同的符号symbols&lt;br&gt;
选择Manufacture-&amp;gt;NC-&amp;gt;Drill Customization&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033592436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033875301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择Manufacture-&amp;gt;NC-&amp;gt;Drill Legend&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756020498262.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756021109940.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认设置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756021361994.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
钻孔表位于Manufacturing下的Nclegend-1-2层&lt;/p&gt;
&lt;h1 id=&#34;4-光绘文件的输出&#34;&gt;4、光绘文件的输出&lt;/h1&gt;
&lt;p&gt;菜单选择Manufacture-&amp;gt;Artwork&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756021501976.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;Film Control选项&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756022788018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Film name ：目前底片的名称&lt;/li&gt;
&lt;li&gt;Rotation ：旋转角度，一般默认0&lt;/li&gt;
&lt;li&gt;Offset ：底片的偏移量，一般默认为0&lt;/li&gt;
&lt;li&gt;Undefined line width：未定义宽度的走线，常规设置为6mil&lt;/li&gt;
&lt;li&gt;Shape bounding box ：默认为100，表示当“Plot mode”为“Negative”时，由Shape的边缘处往外需要画100mil的黑色区域&lt;/li&gt;
&lt;li&gt;Plot mode ：表示采用正片还是负片&lt;/li&gt;
&lt;li&gt;Film mirrored ：底片是否镜像&lt;/li&gt;
&lt;li&gt;Full contact thermal-reliefs ： 当底片设置为负片时，相同网络的铜皮和pin、via之间进行全连接，而不是花连接&lt;/li&gt;
&lt;li&gt;Supress unconnected pads ： 若勾选，表示无盘化设计。假设一个多层板，一通孔在其中某两层未连接任何走线铜皮，那么可以在这两层将焊盘去掉&lt;/li&gt;
&lt;li&gt;Draw missing pad apertures ： 若勾选，表示当一个pad没有相应的&amp;quot;Flash D-Code&amp;quot;时，系统采用较小宽度的Line D-Code填充此pad&lt;/li&gt;
&lt;li&gt;Use aperture rotation ：Gerber数据能使用镜头列表中的镜头来旋转定义的信息&lt;/li&gt;
&lt;li&gt;Supress shape fill ：选择此项表示shape的外形不画出，使用者必须自行加入分割线作为shape的外形，，只有为负片时此项才可以进行设置&lt;/li&gt;
&lt;li&gt;Vector based pad behavior ：默认选择勾选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;General Parameters&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756022829230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Device type ： 底片生成格式&lt;/li&gt;
&lt;li&gt;Coordinate type ：选择 Gerber 6x00 或 Gerber 4x00 时才可以设置&lt;/li&gt;
&lt;li&gt;Absolute ：表示采用绝对坐标&lt;/li&gt;
&lt;li&gt;Incremental ：相对坐标&lt;/li&gt;
&lt;li&gt;Output units ：输出文件单位&lt;/li&gt;
&lt;li&gt;Error action ：输出过程中发生错误的处理方法，默认&lt;/li&gt;
&lt;li&gt;Abort film ：表示终止生成当前底片，继续生成下一张底片&lt;/li&gt;
&lt;li&gt;Abort all ：终止生成所有底片&lt;/li&gt;
&lt;li&gt;Format ：表示输出坐标的精度&lt;/li&gt;
&lt;li&gt;Integer places ：整数部分&lt;/li&gt;
&lt;li&gt;Decimal places ：小数部分&lt;/li&gt;
&lt;li&gt;Output options ：输出选项，选择 Gerber 6x00 或 Gerber 4x00 时才可以设置&lt;/li&gt;
&lt;li&gt;Optimize data ：表示资料需要最佳化的输出&lt;/li&gt;
&lt;li&gt;Use &#39;G&#39; codes ：指定Gerber数据的G码，Gerber使用G码来描述预定处理，Gerber4x00需要G码，Gerber6x00不需要G码&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;添加目录&#34;&gt;添加目录&lt;/h1&gt;
&lt;p&gt;选中TOP或者BOTTOM鼠标右击选择Add&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756027926515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Add的subclass会包含所有的层，我们可以复制已有的TOP或者BOTTOM然后双击重命名&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756028969462.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加如下subclass：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029357036.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加subclass后，在下拉箭头里面随机选中一个class然后右击add&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029718340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029786114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打钩即可&lt;br&gt;
为每一个subclass下添加对应的class&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029840680.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756029872992.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030068240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030344072.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030382114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030432398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加完subclass和class后，单击每一个film，如图设置：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030615906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030732192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
铜皮的连接方式要与上图的设置一致&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756030899530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
返回Film Control界面，点击select all，然后点击Create Artwork，在.brd的文件下会生成gerber文件夹，点击进去就可以看到.art的文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031036340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;生成钻孔文件&#34;&gt;生成钻孔文件&lt;/h1&gt;
&lt;p&gt;菜单-&amp;gt;Manufacture-&amp;gt;NC-&amp;gt;Nc Parameters&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031518402.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
勾选最后一项&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031600561.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在gerber文件夹下多出nc_param.txt，该文件下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756031773512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
菜单-&amp;gt;Manufacture-&amp;gt;NC-&amp;gt;Nc Drill&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756032807127.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756032865329.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击drill&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756032943394.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Drill生成的只是规则的圆形钻孔文件&lt;br&gt;
菜单-&amp;gt;Manufacture-&amp;gt;NC-&amp;gt;Nc Route&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033019199.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033040594.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击route&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1756033141943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注：PASTE_TOP和PASTE_BOTTOM为制作钢网的文件，无需发给制版厂&lt;/p&gt;
&lt;h1 id=&#34;报错photoplot-outline-rectangle-not-found&#34;&gt;报错Photoplot outline rectangle not found&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1759850965216.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导出gerber文件弹出报错&lt;br&gt;
新版本软件需要绘制一个区域&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759851024000.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1759851108812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Cadence-导出Gerber</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-dao-ru-wang-biao/"" data-c="
          &lt;p&gt;1、Setup-&amp;gt;User Preference&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755529663380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置padpath、psmpath&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dra:可编辑的pcb封装文件&lt;/li&gt;
&lt;li&gt;psm:被调用的pcb封装文件，不可编辑&lt;/li&gt;
&lt;li&gt;pad：焊盘文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、导入网表&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755529820661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755529897419.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、点击import&lt;/p&gt;
">Cadence-PCB导入网表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-dao-ru-dxf/"" data-c="
          &lt;p&gt;File-&amp;gt;import-&amp;gt;dxf&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755526731449.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755526740013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上设置后导入&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755526925462.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样导入的图形只是在自己新建的DXFclass下，并不能当做真正的板框，选中外侧框，将其改变层到OUTLINE中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755527303951.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
底层丝印忘记导了，重新导出底层丝印&lt;/p&gt;
">Cadence-PCB导入DXF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-pcb-dao-chu-dxf/"" data-c="
          &lt;p&gt;1、查看需要导出的线条属性&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525400539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525432649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525458616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525485506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2、导出DXF&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525526916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525622436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525710267.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、查看DXF&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525924005.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到板框和元器件丝印框成功导出，其它层同理也可以进行选择性导出。&lt;/p&gt;
">Cadence-PCB导出DXF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-yuan-li-tu-drc-bao-cuo-tong-yi-ge-feng-zhuang-xia-cun-zai-duo-ge-xiang-tong-ming-cheng-de-gndvcc-guan-jiao-dao-zhi/"" data-c="
          &lt;p&gt;制作原理图封装时，GND/VCC电源管脚类型设置为Power&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755525140112.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意：Cadence在设置管脚为电源Power类型后，会在全局网络Net下创建该名称的一个Net，因此，若NC管脚不进行电气连接，不能设置为Power来避免同一个原理图封装存在多个名称相同的管脚错误，否则会创建出一个名称为NC的Net，正确做法是创建NCX，设置为Passive属性的管脚。&lt;/p&gt;
">Cadence-原理图DRC报错同一个封装下存在多个相同名称的GND、VCC管脚导致</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/cadence-dao-chu-wang-biao-netlist-bao-cuo-zhao-bu-dao-footprint/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1755524744618.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
没有设置pcb封装路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755524807354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开orcad默认该路径下存在一个Capture.ini的文件，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1755524903876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图所示添加路径。&lt;/p&gt;
">Cadence-导出网表Netlist报错找不到footprint</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/3d-mo-xing/"" data-c="
          &lt;p&gt;https://www.3dcontentcentral.com.cn/&lt;br&gt;
https://grabcad.com/library&lt;br&gt;
https://componentsearchengine.com/&lt;br&gt;
https://www.snapeda.com/home/&lt;br&gt;
https://componentsearchengine.com/&lt;br&gt;
https://www.ultralibrarian.com/&lt;br&gt;
https://www.datasheet5.com/&lt;/p&gt;
">3D模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/esd/"" data-c="
          &lt;p&gt;PACDN006MR&lt;/p&gt;
">ESD</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dian-ping/"" data-c="
          &lt;p&gt;LVPECL&lt;/p&gt;
">电平</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/linux-ming-ling-xing/"" data-c="
          &lt;ul&gt;
&lt;li&gt;lsblk 列出磁盘列表&lt;/li&gt;
&lt;li&gt;blkid 列出设备的UUID&lt;/li&gt;
&lt;li&gt;parted /dev/mmcblk0 print 列出dev/mmcblk0磁盘的相关信息&lt;/li&gt;
&lt;li&gt;磁盘分区：MBR格式-fdisk  GPT格式-gdisk&lt;/li&gt;
&lt;li&gt;partprobe 分区后更新Linux内核的分区表信息&lt;/li&gt;
&lt;li&gt;mkfs.xfs 格式化磁盘，创建xfs文件系统&lt;/li&gt;
&lt;li&gt;mkfs.ext4 格式化磁盘，创建ext4文件系统&lt;/li&gt;
&lt;li&gt;xfs_repair /dev/vda4  检验/修复文件系统&lt;/li&gt;
&lt;li&gt;fsck.ext4 处理ext4文件系统&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
">Linux命令行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/pcie-dai-kuan-su-lu/"" data-c="
          &lt;h1 id=&#34;pcie&#34;&gt;PCIE:&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;PCIE接口速率&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1754307801157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PCIe是PCI Express的缩写，已经发展和定义了六代，每一代常用Gen来表示。两个PCIe装置之间的连接称为连结（Link）, 每个连结可以有多条通道（Lane），常见的通道数量为x1，x4，x8以及x16, 若某个PCIe连结为Gen2x4，则表示第二代、&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;PCIE版本&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;行代码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;传输速率&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x8&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8b/10b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2.5GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;250MB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8b/10b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;500MB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128b/130b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;984.6MB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.938GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7.877GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15.754GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128b/130b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.969GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7.877GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15.754GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;31.508GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5.0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128b/130b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32/25GT/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.9 or 3.08GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15.8 or 12.3GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;31.5 or 24.6GB/s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;63 or 49.2GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;传输速率GT/s&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传输速率为每秒传输量GT/s，而不是每秒位数Gbps。传输量包括额外的位，传输8b的数据需要占用10b的位数。&lt;br&gt;
GT/s：每秒传输的次数。&lt;br&gt;
Gbps：每秒传输的位数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带宽&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1754309505971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">PCIE带宽、速率</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/git-shang-chuan-bao-cuo-fatal-unable-to-access-httpsgithubcommygithubmagridea_imagesgit-failed-to-connect-to-githubcom-port-443-after-21093-ms-could-not-connect-to-server/"" data-c="
          &lt;p&gt;unable to access &#39;https://github.com/mygithubma/gridea_images.git/&#39;: Failed to connect to github.com port 443 after 21093 ms: Could not connect to server&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753795029009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由于网络连接问题或代理设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global --unset http.proxy 
git config --global --unset https.proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753795886628.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;git config  --global http.proxy 127.0.0.1:7897
git config  --global https.proxy 127.0.0.1:7897
&lt;/code&gt;&lt;/pre&gt;
">Git上传报错fatal: </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-chuan-kou/"" data-c="
          &lt;h1 id=&#34;通信方式&#34;&gt;通信方式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;并行通信&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;串行通信&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异步串行通信&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753709982892.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;同步串行通信&lt;br&gt;
&lt;strong&gt;串行通信制式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;单工&lt;/li&gt;
&lt;li&gt;半双工&lt;/li&gt;
&lt;li&gt;全双工&lt;br&gt;
&lt;strong&gt;串行通信的错误校验&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;奇偶校验：在发送数据时，数据位尾随的1位为奇偶校验位。奇校验时，数据中的1的个数和校验位1的个数之和应为奇数；偶校验时，数据中的1的个数和校验位1的个数之和应为偶数。&lt;/li&gt;
&lt;li&gt;代码和校验&lt;/li&gt;
&lt;li&gt;循环冗余校验&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;rs232-ttl&#34;&gt;RS232-TTL&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753709505964.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;波特率&lt;/strong&gt;&lt;br&gt;
每秒传输二进制代码的位数，1波特=1位/秒，单位为bps。&lt;br&gt;
如每秒传输240个字符，每个字符有10位，波特率为2400bps。&lt;br&gt;
&lt;strong&gt;波特率计算：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;波特率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fosc/12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(2^SMOD/32)*(T1溢出率)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(2^SMOD/64)*fosc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(2^SMOD/32)*(T1溢出率)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;#电源管理寄存器PCON&lt;br&gt;
字节地址为87H，不能位寻址。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMOD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMOD0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;LVDF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;P0F&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GF1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GF0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IDL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;SMOD：串行口波特率&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SMOD=0：串行口方式1,2,3，波特率正常。&lt;/li&gt;
&lt;li&gt;SMOD=1：串行口方式1,2,3，波特率加倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;T1溢出率：T1定时器溢出的频率&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752904618128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752904651883.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;串行口结构&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753717191436.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;串行口控制寄存器scon&#34;&gt;串行口控制寄存器SCON&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SM0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SM1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SM2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;REN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TB8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RB8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TI&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RI&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;SM0 、SM1：工作方式选择位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行口有四种工作方式，由SM0 、SM1设定&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;SM0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;SM1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方式说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;同步移位寄存器方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10位异步收发器（8位数据），波特率可变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11位异步收发器（9位数据），波特率固定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11位异步收发器（9位数据），波特率可变&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;SM2：多机通信控制位&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;REN：允许串行接收位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REN=1：允许串行口接收数据。&lt;/li&gt;
&lt;li&gt;REN=0：禁止串行口接收数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TB8：方式2,3中发送数据的第9位。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;RB8：方式2,3中接收数据的第9位。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;TI：发送中断标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在方式0时，当串行发送第8位数据结束时，或在串行发送停止位的开始时，由内部硬件置1，向CPU发送中断申请。在中断服务程序中，必须用软件将其清0，取消此中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RI：接收中断标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在方式0时，当串行接收第8位数据结束时，或在串行接收停止位的中间时，由内部硬件置1，向CPU发送中断申请。在中断服务程序中，必须用软件将其清0，取消此中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;串口设置&#34;&gt;串口设置：&lt;/h1&gt;
&lt;p&gt;1、确定定时器T1的工作方式（编程TMOD寄存器）&lt;br&gt;
2、计算T1的初值，装载TH1,TL1&lt;br&gt;
3、启动T1（编程TCON中的TR1位）&lt;br&gt;
4、确定串行口工作方式（编程SCON寄存器）&lt;br&gt;
5、串行口工作在中断方式下时，要进行中断设置（编程IE,IP寄存器）&lt;br&gt;
&lt;strong&gt;设置虚拟仿真串口如下：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797404278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797456590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开虚拟串口软件Configure Virtual Serial Port Driver：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797503656.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加COM1、COM2，打开XCOM软件：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797597451.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
运行仿真：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753797633810.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;

#define uchar unsigned char
#define uint unsigned int
uchar flag,a,i;
uchar code table[]=&amp;quot;I get &amp;quot;;

void init()
{
	TMOD=0x20;  //0010 0000 定时器T1工作方式2:8位初值自动重装的定时器/计数器
	TH1=0xfd;  //253,波特率为9600，SMOD置0
	TL1=0xfd;  //与TH1一样
	TR1=1;  //启动定时器
	REN=1;  //串行口控制寄存器SCON，允许串行接收位
	SM0=0;
	SM1=1;  //串行口工作方式为1
	EA=1;  //串行口工作在中断方式，编程中断允许IE寄存器，允许全局中断
	ES=1;  //打开串行口中断
}

void main()
{
	init();
	while(1)
	{
		if(flag==1)
		{
			ES=0;
			for(i=0;i&amp;lt;6;i++)
			{
				SBUF=table[i];
				while(!TI);
				TI=0;
			}
			SBUF=a;
			while(!TI);
			TI=0;
			ES=1;
			flag=0;
		}
	}
}

void ser() interrupt 4
{
	RI=0;
	a=SBUF;
	flag=1;
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-串口</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-led/"" data-c="
          &lt;h1 id=&#34;移位操作&#34;&gt;移位操作&lt;/h1&gt;
&lt;p&gt;&amp;lt;&amp;lt;：左移指令。被操作数的最高位移入单片机PSW寄存器的CY位，CY位中的数丢弃，最低位补0。&lt;br&gt;
&amp;gt;&amp;gt;：右移指令。被操作数的最低位移入单片机PSW寄存器的CY位，CY位中的数丢弃，最高位补0。&lt;br&gt;
循环左移：最高位移入最低位。_crol_实现。&lt;br&gt;
循环右移：最低位移入最高位。_cror_函数实现。&lt;/p&gt;
&lt;h1 id=&#34;psw寄存器&#34;&gt;PSW寄存器&lt;/h1&gt;
&lt;p&gt;程序状态字标志寄存器。8位寄存器，字节地址D0H。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sfr PSW         =   0xD0;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CY&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AC&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;F0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RS1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;RS0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;OV&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;P&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;CY：进位标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示运算是否有进位，如果操作结果在最高位有进位或者借位，则该位为1，否则为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AC：辅助进位标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半进位标志，指两个8位数运算低四位是否有半进位，即低四位相加或相减是否进位，如有AC为1，否则为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;F0：用户使用的状态标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可用软件来置1或清0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RS1、RS0:4组工作寄存器区选择控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在汇编语言中，这两位用来选择4组工作寄存器区中的哪一组为当前工作寄存区。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;OV：溢出标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反映带符号数的运算结果是否有溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P：奇偶标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反映累加器ACC内容的奇偶性，如果ACC中的运算结果有偶数个1，则P为0，否则为1。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;流水灯程序&#34;&gt;流水灯程序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;    //包含头文件
#include &amp;lt;intrins.h&amp;gt;  //包含_crol_函数所在的文件
#define uint unsigned int   //宏定义
#define uchar unsigned char
	
//sbit led1=P2^0;    单个led延时
//void delayms(uint xms)
//{
//	uint i,j;
//	for(i=xms;i&amp;gt;0;i--)
//	{
//		for(j=110;j&amp;gt;0;j--);
//	}
//}

//void main()
//{
//	while(1)
//	{
//		led1=0;
//		delayms(2000);
//		led1=1;
//		delayms(2000);
//	}
//}

void delayms(uint);
uchar aa;

void main()
{
	aa=0xfe;   //赋初值1111 1110
	while(1)
	{
		P2=aa;   //点亮一个led
		delayms(500);
		aa=_crol_(aa,1);   //循环左移
	}
}

void delayms(uint xms)
{
	uint i,j;
	for(i=xms;i&amp;gt;0;i--)   //延时xms
	{
		for(j=110;j&amp;gt;0;j--);
	}
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-Led</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-ru-men-1/"" data-c="
          &lt;h1 id=&#34;数码管显示原理&#34;&gt;数码管显示原理&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1752758348337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选用共阳极数码管，IO输出0表示亮，输出1表示不亮。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752758451827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
推导出共阳极显示0-9的十六进制如下：&lt;/p&gt;
&lt;h1 id=&#34;数字显示-共阳&#34;&gt;数字显示-共阳&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#include &amp;lt;intrins.h&amp;gt;
#define uint unsigned int
#define uchar unsigned char
	
sbit dula=P2^6;  //定义段选信号
sbit wela=P2^7;  //定义位选信号

void main()
{
	wela=1;  //位选为高电平，选择某个数码管
	P0=0x01;  //P0=0000 0001,打开第一个数码管
	wela=0;  //关闭位选锁存器
	
//显示0
//	dula=1;  //段选锁存器打开
//	P0=0x40;  //P0=0100 0000，0表示亮
//	dula=0;  //段选锁存器关闭；
	
//显示1
//	dula=1;  //段选锁存器打开
//	P0=0xf9;  //P0=1111 1001，
//	dula=0;  //段选锁存器关闭；
	
//显示2
//	dula=1;  //段选锁存器打开
//	P0=0x24;  //P0=0010 0100，
//	dula=0;  //段选锁存器关闭；
	
//显示3
//	dula=1;  //段选锁存器打开
//	P0=0x30;  //P0=0011 0000，
//	dula=0;  //段选锁存器关闭；
	
//显示4
//	dula=1;  //段选锁存器打开
//	P0=0x19;  //P0=0001 1001，
//	dula=0;  //段选锁存器关闭；
	
//显示5
//	dula=1;  //段选锁存器打开
//	P0=0x12;  //P0=0001 0011，
//	dula=0;  //段选锁存器关闭；
	
//显示6
//	dula=1;  //段选锁存器打开
//	P0=0x02;  //P0=0000 0010，
//	dula=0;  //段选锁存器关闭；
	
//	//显示7
//	dula=1;  //段选锁存器打开
//	P0=0xf8;  //P0=1111 1000，
//	dula=0;  //段选锁存器关闭；
	
//	//显示8
//	dula=1;  //段选锁存器打开
//	P0=0x00;  //P0=0000 0000，
//	dula=0;  //段选锁存器关闭；
	
//	//显示9
	 dula=1;  //段选锁存器打开
	 P0=0x10;  //P0=0001 0000，
 	dula=0;  //段选锁存器关闭；
	 while(1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应共阴极的数码管&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned char code table[]={
     0x3f,0x06，0x5b,0x4f,
     0x66,0x6d,0x7d,0x07,
     0x7f,0x6f,0x77,0x7c,
     0x39,0x5e,0x79,0x71,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注：code关键字表示编码，在单片机c语言中，定义数组是占用内存空间的，定义编码是直接分配到程序空间中，编译后编码占用的是程序存储空间而非内存空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;数字显示-延时从1-f显示-共阴&#34;&gt;数字显示 延时从1-f显示 共阴&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#include &amp;lt;intrins.h&amp;gt;
#define uint unsigned int
#define uchar unsigned char
	
sbit dula=P2^6;  //定义段选信号
sbit wela=P2^7;  //定义位选信号

unsigned char code tableK[]={
	  0x3f,0x06,0x5b,0x4f,
      0x66,0x6d,0x7d,0x07,
      0x7f,0x6f,0x77,0x7c,
      0x39,0x5e,0x79,0x71,
};

uint num;
void delayms(uint);

void main()
{
 	wela=1;  //位选为低电平，选择某个数码管
  	P0=0xfe;  //P0=1111 1110,打开第一个数码管，延时从1-f显示
	wela=0;  //关闭位选锁存器
	
//	dula=1;
//	P0=tableK[1];
//	dula=0;
 	while(1)
 	{
	 	for(num=0;num&amp;lt;16;num++)
	 	{
	 		dula=1;
		 	P0=tableK[num];
			dula=0;
			delayms(500);
		}
	};
}

void delayms(uint xms)
{
	uint i,j;
	for(i=xms;i&amp;gt;0;i--)
 	{
 		for(j=110;j&amp;gt;0;j--);
 	}
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-数码管；</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-zhong-duan/"" data-c="
          &lt;h1 id=&#34;52单片机&#34;&gt;52单片机&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;52单片机共有6个中断源：&lt;br&gt;
&lt;strong&gt;INT0-外部中断0，P3.2端口，低电平或者下降沿引起。&lt;br&gt;
INT1-外部中断1，P3.3端口，低电平或者下降沿引起。&lt;br&gt;
T0-定时器0/计数器0中断，T0计数器计满回零引起。&lt;br&gt;
T1-定时器1/计数器1中断，T1计数器计满回零引起。&lt;br&gt;
T2-定时器2/计数器2中断，T2计数器计满回零引起。&lt;br&gt;
TI/RI-串行口中断，串行端口完成一帧字符发送/接收引起。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753624895792.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;中断允许寄存器ie&#34;&gt;中断允许寄存器IE&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;中断允许寄存器IE用于设定各个中断源的打开和关闭，IE在特殊功能寄存器中，字节地址为A8H，位地址分别为A8H-AFH，可进行位寻址，即可以对寄存器的每一位进行单独操作。单片机复位时IE全部被清0。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ET2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ES&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ET1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EX1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ET0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EX0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AFH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ADH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ACH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ABH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AAH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;A9H&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;A8H&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;EA:全局中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EA=1：打开全局中断控制。&lt;/li&gt;
&lt;li&gt;EA=0：关闭全部中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ET2：定时器/计数器2中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ET2=1：打开T2中断。&lt;/li&gt;
&lt;li&gt;ET2=0：关闭T2中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ES：串行口中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES=1：打开串行口中断。&lt;/li&gt;
&lt;li&gt;ES=0：关闭串行口中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ET1：定时器/计数器1中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ET1=1：打开T1中断。&lt;/li&gt;
&lt;li&gt;ET1=0：关闭T1中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EX1：外部中断1中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EX1=1：打开外部中断1中断。&lt;/li&gt;
&lt;li&gt;EX1=0：关闭外部中断1中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ET0：定时器/计数器0中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ET1=1：打开T0中断。&lt;/li&gt;
&lt;li&gt;ET1=0：关闭T0中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;EX0：外部中断0中断允许位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EX0=1：打开外部中断0中断。&lt;/li&gt;
&lt;li&gt;EX0=0：关闭外部中断0中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;中断优先级寄存器ip&#34;&gt;中断优先级寄存器IP&lt;/h1&gt;
&lt;p&gt;中断优先级寄存器IP在特殊功能寄存器中，字节地址为B8H，位地址为B8H-BFH，IP用来设定各个中断源属于两级中断中的哪一级，该寄存器可以进行位寻址。单片机复位时IP全部被清0.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PT1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PT0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PX0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BCH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BBH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BAH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B9H&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B8H&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;PS：串行口中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PS=1：串行口中断定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PS=0：串行口中断定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PT1：定时器/计数器1中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PT1=1：定时器/计数器1中断定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PT1=0：定时器/计数器1中断定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PX1：外部中断1中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PX1=1：外部中断1定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PX1=0：外部中断1定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PT0：定时器/计数器0中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PT0=1：定时器/计数器0中断定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PT0=0：定时器/计数器0中断定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PX0：外部中断1中断优先级控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PX0=1：外部中断0定义为高优先级中断。&lt;/li&gt;
&lt;li&gt;PX0=0：外部中断0定义为低优先级中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;定时器计数器工作方式寄存器tmod&#34;&gt;定时器/计数器工作方式寄存器TMOD&lt;/h1&gt;
&lt;p&gt;字节地址为89H，不能位寻址，单片机复位时全被清0。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GATE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C/T&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GATE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C/T&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;M0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TMOD的高四位用于设定定时器1，低四位用于设定定时器0。&lt;br&gt;
&lt;strong&gt;GATE：门控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GATE=0：定时器/计数器启动与停止仅受TCON寄存器中TRX来控制&lt;/li&gt;
&lt;li&gt;GATE=1：定时器/计数器启动与停止仅受TCON寄存器中TRX和外部中断INTX上的电平状态控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;C/T：定时器/计数器模式选择位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C/T=1：计数器模式。&lt;/li&gt;
&lt;li&gt;C/T=0：定时器模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;M1M0：工作方式选择&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;M1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;M0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;-----&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式0:13位定时器/计数器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式1:16位定时器/计数器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式2:8位初值自动重装的定时器/计数器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;方式3:仅用于T0，分成两个8位计数器，T1停止计数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;定时器计数器控制寄存器tcon&#34;&gt;定时器/计数器控制寄存器TCON&lt;/h1&gt;
&lt;p&gt;字节地址为88H，位地址为88H-8FH，可进行位寻址，单片机复位全部清0。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位符号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TF1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TR1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TF0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TR0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IE1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IT1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IE0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IT0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;位地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8FH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8EH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8DH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8CH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8BH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8AH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;89H&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;88H&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;TF1：定时器1溢出标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TF=1：定时器计数溢出后，由硬件使TF1置1，并且申请中断，进入中断服务程序后，由硬件自动清0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TR1：定时器1运行控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由软件清0关闭定时器1，当GATE=1时，且INT1为高电平时，TR1置1启动定时器1；当GATE=0时，TR1置1，启动定时器1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;IE1：外部中断1请求标志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;置1表示外部中断1向CPU申请中断。&lt;br&gt;
&lt;strong&gt;IT1：外部中断1触发方式选择位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IT1=0：电平触发模式。&lt;/li&gt;
&lt;li&gt;IT1=1：跳变沿触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#定时器0-工作方式1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑结构图：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753708175871.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753709084503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;定时器初始化过程：&lt;br&gt;
1、对TMOD赋值：（定时器/计数器工作方式寄存器)&lt;br&gt;
2、计算初值，给THX TLX赋值&lt;br&gt;
3、对中断允许寄存器IE进行赋值，开放中断&lt;br&gt;
4、使定时器/计数器控制寄存器TCON中的TRX置位，启动定时器/计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#define uchar unsigned char
#define uint unsigned int

sbit led1=P1^0;

uchar num;

void main()
{
	TMOD=0x01;      //定时器0，工作方式1,0000 0001
	TH0=(65536-45872)/256;	//定时50ms=50000us,50000/1.09=45872
	TL0=(65536-45872)%256;
	EA=1;  //中断允许寄存器打开全局中断允许位
	ET0=1;  //中断允许寄存器打开T0中断允许位
	TR0=1;  //定时器/计数器控制寄存器TCON启动定时器T0
	while(1)		//程序停止在这里等待中断发生
	{
		if(num==20)
		{
			num=0;
			led1=~led1;
		}
	}
}

void T0_time() interrupt 1
{
	TH0=(65536-45872)/256;	//定时50ms=50000us,50000/1.09=45872
	TL0=(65536-45872)%256;
	num++;
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-中断</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-ji-chu-zhi-shi-stc89c52/"" data-c="
          &lt;h1 id=&#34;-引脚分类&#34;&gt;- &lt;em&gt;引脚分类&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;1、电源和时钟引脚：Vcc、GND、XTAL1、XTAL2。&lt;br&gt;
2、编程控制引脚：RST、PSEN、ALE/PROG、EA/Vpp。&lt;br&gt;
3、IO口：P0、P1、P2、P3,。共四组8位IO口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电源-Vcc（40脚）、GND(20脚)。&lt;/li&gt;
&lt;li&gt;外接时钟-XTAL1(19脚)、XTAL2（18脚）。&lt;br&gt;
XTAL1为片内震荡电路的输入端，XTAL2为片内震荡电路的输出端。&lt;/li&gt;
&lt;li&gt;8051的时钟有两种方式：&lt;br&gt;
片内时钟震荡：在XTAL引脚外接石英晶体和震荡电容，电容取值10p-30pf。&lt;br&gt;
外部时钟方式：XTAL1接地，XTAL2接入外部时钟信号。&lt;/li&gt;
&lt;li&gt;RST(9脚）&lt;br&gt;
单片机复位脚，输入连续两个机器周期以上的高电平时有效。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753506486252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;PSEN（29脚）&lt;br&gt;
程序存储器允许输出控制端，在读外部程序存储器时PSEN低电平有效。&lt;/li&gt;
&lt;li&gt;ALE/PROG（30脚）&lt;br&gt;
单片机扩展外部RAM时，ALE用于控制把P0口的输出低8位地址送锁存器锁存起来，实现低位地址和数据的隔离。&lt;/li&gt;
&lt;li&gt;EA/Vpp（31脚）&lt;br&gt;
EA接高电平时，单片机读取内部程序存储器。当扩展有外部ROM时，先读取内部ROM后自动读取外部ROM。&lt;/li&gt;
&lt;li&gt;IO口&lt;br&gt;
P0口（39-32脚）：双向8位三态IO口，每个口可独立控制，P0口没有上拉电阻，为高阻状态，不能正常的输出高低电平，使用时接10k上拉电阻。&lt;br&gt;
P1口（1-8脚）：准双向8位IO口，可独立控制，内带上拉电阻，输出没有锁存状态，输入也不能锁存。不是真正的双向IO口，该口在使用前，要先进行写1操作。&lt;br&gt;
P2口（21-28脚）：准双向8位IO口，可独立控制，内带上拉电阻。&lt;br&gt;
P3口（10-17脚）：准双向8位IO口，可独立控制，内带上拉电阻。有第二功能。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753507122703.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;电平特性&#34;&gt;电平特性&lt;/h1&gt;
&lt;p&gt;常用电平：TTL、CMOS、RS232、RS422、RS485.&lt;br&gt;
TTL：+5V为高电平，0V为低电平。&lt;br&gt;
RS232：+12V为低电平，-12V为高电平。&lt;/p&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753617708021.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单片机中存储的最小单位：位（bit） 0/1&lt;br&gt;
1字节（Byte）=8位（bit）  1B=8b&lt;/p&gt;
&lt;h1 id=&#34;reg51h&#34;&gt;&amp;lt;reg51.h&amp;gt;&lt;/h1&gt;
&lt;p&gt;sfr：特殊功能寄存器的数据声明，声明一个8位的寄存器。&lt;br&gt;
sfr16：16位特殊功能寄存器的数据声明。&lt;br&gt;
sbit：特殊功能位声明，声明一个特殊功能寄存器的某一位。&lt;br&gt;
bit：位变量声明。&lt;/p&gt;
">单片机-基础知识（STC89C52）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-ds18b20/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753017960198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">单片机-DS18B20</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-iic/"" data-c="
          &lt;p&gt;&lt;strong&gt;IIC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inter IC Bus&lt;/li&gt;
&lt;li&gt;由数据线SDA和时钟线SCL构成，采用漏记开路结构和总线连接，因此SCL和SDA均需接上拉电阻，总线在空闲状态为高电平，任一器件输出低电平都可拉低总线。&lt;/li&gt;
&lt;li&gt;IIC在数据传输时，时钟信号为高电平期间，数据线上的数据必须保持稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送启动信号，在SCL高电平期间，SDA出现下降沿。&lt;/li&gt;
&lt;li&gt;发送寻址信号，7位地址寻址时，高7位为地址位，最低位为方向位，0表示主机对从机进行写操作，1表示主机对从机进行读操作。主机发送地址时，总线上的从机都根据7位地址码与自己的地址进行比较，相同即认为自己正被主机寻址，根据R/W确定自己为发送器或者接收器。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位序号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;7&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;6&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;5&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:----:&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;:R/W:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;应答信号，应答信号由接收设备产生，在SCL信号为高电平期间，接收设备将SDA拉为低电平，表示数据传输正确，产生应答。&lt;/li&gt;
&lt;li&gt;停止信号，在SCL为高电平期间，SDA出现上升沿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延时&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void delay()  //延时4-5us
{;;}
void delay1ms(uint z)
{
	uint x,y;
	for(x=z;x&amp;gt;0;x--)
	{
		for(y=110;y&amp;gt;0;y--);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//总线初始化
void init()  //总线在初始状态下保持高电平
{
	SCL=1;
	delay();
	SDA=1;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动信号&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//启动信号
void start() //SCL在高电平期间，SDA出现下降沿
{
	SDA=1;
	delay();
	SCL=1;
	delay();
	SDA=0;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;应答信号&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//应答信号
void respon()  //SCL为高电平期间，SDA被从设备拉低
{
	uchar i=0;
	SCL=1;
	delay();
	while((SDA==1)&amp;amp;&amp;amp;(i&amp;lt;255))
	{
		i++;
	}
	SCL=0;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;停止信号&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//停止信号
void stop()  //SCL在高电平期间，SDA出现上升沿信号
{
	SDA=0;
	delay();
	SCL=1;
	delay();
	SDA=1;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;写一个字节&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//写一个字节
void write_byte(uchar date)
{
	uchar i,temp;
	temp=date;
	for(i=0;i&amp;lt;8;i++)
	{
		temp=temp&amp;lt;&amp;lt;1;   //temp左移一位，最高位移入寄存器PSW的CY位，赋值给SDA
		SCL=0;  //IIC在进行数据传送时，SCL为高电平期间，SDA需保持稳定，因此拉低SCL
		delay();
		SDA=CY;
		delay();
		SCL=1;
		delay();
	}
	SCL=0;   
	delay();
	SDA=1;
	delay();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;读一个字节&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//读一个字节
uchar read_byte()
{
	uchar i,k;
	SCL=0;
	delay();
	SDA=1;
	for(i=0;i&amp;lt;8;i++)
	{
		SCL=1;
		delay();
		k=(k&amp;lt;&amp;lt;1)|SDA;
		SCL=0;
		delay();
	}
	delay();
	return k;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;EEPROM-AT24C02&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752914063901.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WP:写保护输入端，用于硬件数据保护，当其为低电平时，可以对整个存储器进行正常的读写操作，当其为高电平时，存储器具有写保护功能，读操作不受影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//例程：
#include &amp;lt;reg52.h&amp;gt;

#define uchar unsigned char
#define uint unsigned int
bit write=0;  //写24C02的标志
sbit SDA=P2^0;
sbit SCL=P2^1;
sbit dula=P2^6;
sbit wela=P2^7;
uchar sec,tcnt;

unsigned char code table[]={
	 0x3f,0x06,0x5b,0x4f,
     0x66,0x6d,0x7d,0x07,
   0x7f,0x6f,0x77,0x7c,
     0x39,0x5e,0x79,0x71,
};

void delay()  //延时4-5us
{;;}
	
void delay1ms(uint z)
{
	uint x,y;
	for(x=z;x&amp;gt;0;x--)
	{
		for(y=110;y&amp;gt;0;y--);
	}
}

//总线初始化
void init()  //总线在初始状态下保持高电平
{
	SCL=1;
	delay();
	SDA=1;
	delay();
}

//启动信号
void start() //SCL在高电平期间，SDA出现下降沿
{
	SDA=1;
	delay();
	SCL=1;
	delay();
	SDA=0;
	delay();
}

//应答信号
void respon()  //SCL为高电平期间，SDA被从设备拉低
{
	uchar i=0;
	SCL=1;
	delay();
	while((SDA==1)&amp;amp;&amp;amp;(i&amp;lt;255))
	{
		i++;
	}
	SCL=0;
	delay();
}

//停止信号
void stop()  //SCL在高电平期间，SDA出现上升沿信号
{
	SDA=0;
	delay();
	SCL=1;
	delay();
	SDA=1;
	delay();
}

//写一个字节
void write_byte(uchar date)
{
	uchar i,temp;
	temp=date;
	for(i=0;i&amp;lt;8;i++)
	{
		temp=temp&amp;lt;&amp;lt;1;   //temp左移一位，最高位移入寄存器PSW的CY位，赋值给SDA
		SCL=0;  //IIC在进行数据传送时，SCL为高电平期间，SDA需保持稳定，因此拉低SCL
		delay();
		SDA=CY;
		delay();
		SCL=1;
		delay();
	}
	SCL=0;   
	delay();
	SDA=1;
	delay();
}

//读一个字节
uchar read_byte()
{
	uchar i,k;
	SCL=0;
	delay();
	SDA=1;
	for(i=0;i&amp;lt;8;i++)
	{
		SCL=1;
		delay();
		k=(k&amp;lt;&amp;lt;1)|SDA;
		SCL=0;
		delay();
	}
	delay();
	return k;
}

void write_add(uchar address,uchar date)
{
	start();
	write_byte(0xa0);  //1010 0000  AT24C02的芯片地址1010 A2 A1 A0 R/W 
	respon();
	write_byte(address);  //器件内部地址
	respon();
	write_byte(date);  //数据
	respon();
	stop();
}

uchar read_add(uchar address)
{
	uchar date;
	start();
	write_byte(0xa0);
	respon();
	write_byte(address);
	respon();
	start();
	write_byte(0xa1);
	respon();
	date=read_byte();
	stop();
	return date;
}
	
void display(uchar bai_c,uchar sh_c)  //显示程序
{
	wela=0;
	dula=0;  //关闭段选锁存器
	wela=1;  //选中位选锁存器
  P0=0x7e;  //0111 1110 第一位数码管使能
	wela=0;  //关闭位选锁存
	P0=0xff;
	
	dula=1;  //打开段选锁存器
	P0=table[bai_c];  //显示第一位数据
	dula=0;  //关闭段选锁存器
	delay1ms(5);
	
	wela=1;  //选中位选锁存器
	P0=0x7d;  //0111 1101 第二位数码管使能
	wela=0;  //关闭位选锁存
	P0=0xff;
	
	dula=1;  //打开段选锁存器
	P0=table[sh_c]; //显示第二位数据
	dula=0;  //关闭段选锁存器
	delay1ms(5);
}

void main()
{
	init();  //初始化，拉高IIC总线
	sec=read_add(2);   //读出保存的数据赋值给sec
	if(sec&amp;gt;100)  //防止读出数据为3位造成两位数码管显示乱码
	{
		sec=0;
	}
	TMOD=0x01;  //0000 0001 定时器T0，工作方式1:16为定时器/计数器
	ET0=1;  //中断允许寄存器IE 定时器/计数器0中断允许位
	EA=1;  //中断允许寄存器IE 全局中断打开
	TH0=(65536-45872)/256;
	TL0=(65536-45872)%256;  //50ms中断一次
	TR0=1;  //定时器控制寄存器TCON 启动定时器1
	while(1)
	{
		display(sec/10,sec%10);
		if(write==1)  //判断计时器是否计时1s
		{
			write=0;  //清0
			write_add(2,sec);  //在24C02的地址2写入数据sec
		}
	}
}

void t0() interrupt 1
{
	TH0=(65536-45872)/256;
	TL0=(65536-45872)%256;
	tcnt++;  //0.05sx20=1s
	if(tcnt==20)  //1s写一次24C02
	{
		tcnt=0;  //清0
		sec++;  //每隔1s，sec加1，定时1s
		write=1;  //写24C02
		if(sec==100)  //到100s后归零
		{ 
			sec=0;
		}
	}
	
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-IIC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dan-pian-ji-adda/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753802270097.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1752903439273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;
#include &amp;lt;intrins.h&amp;gt;
#define uchar unsigned char
#define uint unsigned int
	
sbit dula=P2^6;   //定义锁存器的锁存端
sbit wela=P2^7;   //定义锁存器的锁存端
sbit adwr=P3^6;   //定义AD转换器的WR端口
sbit adrd=P3^7;   //定义AD转换器的RD端口

//共阴数码管
unsigned char code table[]={
     0x3f,0x06,0x5b,0x4f,
     0x66,0x6d,0x7d,0x07,
     0x7f,0x6f,0x77,0x7c,
     0x39,0x5e,0x79,0x71,
};

void delayms(uint xms)  //延时函数
{
	 uint i,j;
	 for(i=xms;i&amp;gt;0;i--)
	 {
	 	for(j=110;j&amp;gt;0;j--);
	 }
}

void display(uchar bai,uchar shi,uchar ge)  //显示函数
{
	wela=1;
	P0=0x7d;  //0111 1101 显示第2位和选中AD转换器
	wela=0;
	P0=0xff;  //送位选数据时关闭所有显示；防止打开位选锁存；
	dula=1;  //数码管显示
	P0=table[bai];
	dula=0;
	delayms(5);
	
	wela=1;
	P0=0x7b;   //0111 1011 显示第3位数码管并选中AD转换器
	wela=0;
	P0=0xff;
	dula=1;
	P0=table[shi];
	dula=0;
	delayms(5);
	
	wela=1;
	P0=0x77;   //0111 0111 显示第4位数码管并选中AD转换器
	wela=0;
	P0=0xff;
	dula=1;
	P0=table[ge];
	dula=0;
	delayms(5);
	
}

void main()
{
	
	uchar a,A1,A2,A3,adval;
	A1=1;
	A2=2;
	A3=3;
	wela=1;
	P0=0x7f;  //0111 1111 选通CSAD
	wela=0;
	while(1)
	{
		adwr=1;
		_nop_();
		adwr=0;  //启动AD转换；
		_nop_();  //延时一个机器周期
		adwr=1;
		for(a=10;a&amp;gt;0;a--)
		{
			display(A1,A2,A3);
		}
		P1=0xff;  //1111 1111 读取P1之前先全给1
		adrd=1;  //选通ADCS
		_nop_();
		adrd=0;  //AD读使能；
		_nop_();
		adval=P1;  //AD数据读取赋值给P1
		A1=adval/100;
		A2=adval%100/10;
		A3=adval%10;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1753887219105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;DAC0832引脚：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1753887903411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CS：片选信号输入端，低电平有效。&lt;/li&gt;
&lt;li&gt;WR1：输入寄存器的写选通输入端，负脉冲有效。当CS为0，ILE为1，WR1有效时，DI0-DI7状态被锁存到输入寄存器。&lt;/li&gt;
&lt;li&gt;DI0-DI7：数据输入端，TTL电平。&lt;/li&gt;
&lt;li&gt;Vref：基准电压输入端，电压范围为-10V-+10V。&lt;/li&gt;
&lt;li&gt;Rfb：反馈电阻端，芯片内部此端与IOUT1接有一个15K的电阻。&lt;/li&gt;
&lt;li&gt;IOUT1：电流输出端，当输入全为1，电流最大。&lt;/li&gt;
&lt;li&gt;IOUT2：电流输出端，其值与IOUT1电流之和为一常数。&lt;/li&gt;
&lt;li&gt;XFER：数据传输控制信号输入端，低电平有效。&lt;/li&gt;
&lt;li&gt;WR2：DAC寄存器的写选通输入端，负脉冲有效。当XFER为0且WR2有效时，输入寄存器的状态被传到DAC寄存器中。&lt;/li&gt;
&lt;li&gt;ILE：数据锁存允许信号输入端，高电平有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DAC0832工作方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双缓冲&lt;/li&gt;
&lt;li&gt;单缓冲&lt;/li&gt;
&lt;li&gt;直通：片选、写信号、传送控制都接地。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;

#define uchar unsigned char
#define uint unsigned int
	
sbit dula=P2^6;  //段选
sbit wela=P2^7;  //位选
sbit dawr=P3^6;  //DA的WR端口
sbit dacs=P3^2;  //DA的CS端口
sbit beep=P2^3;  //蜂鸣器端口

void delayms(uint xms)  //延时xms
{
	uint i,j;
	for(i=xms;i&amp;gt;0;i--)
	{
		for(j=110;j&amp;gt;0;j--);
	}
}

void main()
{
	uchar val,flag;
	dula=0;  //关闭段选
	wela=0;  //关闭位选
	dacs=0;  //片选信号，选中DAC
	dawr=0;  //输入寄存器的写信号选通端
	P0=0;
	while(1)
	{
		if(flag==0)
		{
			val+=5;
			P0=val;
			if(val==255)
			{
				flag=1;
				beep=1;
				delayms(100);
				beep=0;
			}
			delayms(50);
		}
		else
		{
			val-=5;
			P0=val;
			if(val==0)
			{
				flag=0;
				beep=1;
				delayms(100);
				beep=0;
			}
			delayms(50);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
">单片机-ADDA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-ui-she-ji/"" data-c="
          &lt;ul&gt;
&lt;li&gt;PyQt5：&lt;br&gt;
总界面：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749191239648.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
QLabel：主题：基于Yolov5+Deepsort的单目标跟踪器设计&lt;br&gt;
QLabel：显示：label_video，作为识别显示区域&lt;br&gt;
QTextBrowser：模拟终端：显示识别数据&lt;br&gt;
QHBoxLayout：布局：COM、Start、Close、Stop四个按键水平布局&lt;br&gt;
Spacer：水平分割符&lt;br&gt;
QPushButton：按键&lt;br&gt;
QRadioButton：Stop可选择按键&lt;br&gt;
Line：边框线&lt;/li&gt;
&lt;li&gt;优化&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749191562232.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中mainWindow，在属性栏中的windowTitle中更改显示界面左上角名称；windowIcon可选择图片文件更改显示框左上角标识。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749191701398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中label_theme，右击鼠标，选择改变样式表，添加颜色中选择添加background-color可改变背景颜色，选择添加字体可改变字体。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192006897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中QLabel，在右侧属性栏里找到alignment，选择AlignHCenter水平居中，AlignVCenter垂直居中。&lt;br&gt;
其他窗口通过调整大小放置在合适的位置。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192181192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中PushButton，在属性栏中找到cursor，可修改选中按钮后鼠标箭头的显示状态，同理，将Start、Close按键的显示状态均改为指向手势。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192304483.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Edit，选中编辑信号部件，选择Close按键，拖动出来。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192390185.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选中下面显示从QWidget继承的信号和槽。左边选择clicked（），右边选择close（）&lt;br&gt;
右边最下面的信号、槽编辑器会显示一个pushButton_close（）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192554344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编辑完后可按键F3退出信号槽编辑状态。&lt;br&gt;
点击左上角窗体预览可进行预览界面。&lt;br&gt;
保存.ui文件，回到pycharm，选中.ui文件，右击鼠标，选择外部工具，点击PYUIC，会在本地目录生成与.ui同名的.py文件。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192708868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新建run_ui.py文件，导入.ui同名的.py文件，下图为显示程序。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192792397.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
运行run_ui.py文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749192901932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在.py文件中class Ui_mainWindow类下，&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193163996.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可用connect（）进行按键功能的写定。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193236349.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，将def open_com（）函数写在class Ui_mainWindow类下，即可设定按键按下的功能。&lt;br&gt;
&lt;code&gt;self.textBrowser_terminal.append(&#39;OPEN COM: &#39;)&lt;/code&gt;可换行并且刷新到最新显示&lt;br&gt;
在模拟终端添加数据输出，textBrowser添加输出的程序有多种：&lt;br&gt;
&lt;code&gt;self.textBrowser_terminal.setText(&#39;OPEN COM: &#39;)&lt;/code&gt;添加文字但不换行不刷新&lt;br&gt;
&lt;code&gt;self.textBrowser_terminal.insertPlainText(&#39;OPEN COM: &#39;)&lt;/code&gt;插入文字不换行&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193703149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;if not self.radioButton.isChecked():&lt;/code&gt;如果radioButton没有选中，执行下述程序，若选中则停止。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749193790104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
执行label_video显示程序，并且可调整显示大小至适合label_video框大小。&lt;br&gt;
最终效果图：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749194229147.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计UI设计：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/deepsort-xiong-ya-li-suan-fa/"" data-c="
          &lt;p&gt;参考博客：https://blog.csdn.net/lemonxiaoxiao/article/details/108672039&lt;br&gt;
https://www.cnblogs.com/pprp/articles/12736831.html&lt;/p&gt;
">DeepSort-匈牙利算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/deepsort-qia-er-man-lu-bo/"" data-c="
          &lt;p&gt;&lt;code&gt;import numpy as np&lt;/code&gt;&lt;br&gt;
导入numpy库，并命名为np。Numpy是Python的核心计算库，提供多维数组对象ndarray，数学函数，随机数生成等。&lt;br&gt;
如：a=np.array([1,2,3])   b=np.sum(a)&lt;br&gt;
&lt;code&gt;import scipy.linalg&lt;/code&gt;&lt;br&gt;
导入Scipy库的linalg（线性代数）子模块。该模块包含线性代数运算，如矩阵求逆，求解方程组等。&lt;br&gt;
&lt;code&gt;chi2inv95 = {                 1: 3.8415,                 2: 5.9915,                 3: 7.8147,                 4: 9.4877,                 5: 11.070,                 6: 12.592,                 7: 14.067,                 8: 15.507,                 9: 16.919}&lt;/code&gt;&lt;br&gt;
定义一个名为chi2inv95的字典，存储了卡方分布的95%置信度临界值，用于统计学中的假设检验或不确定性分析。&lt;br&gt;
&lt;code&gt;class KalmanFilter(object):&lt;/code&gt;&lt;br&gt;
卡尔曼滤波器&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749109790837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ndim状态维度为4，dt为时间步长，每次预测时长为1s。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110057596.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
motion_mat为状态转移矩阵&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110220938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
update_mat为更新矩阵，从8维状态向量中提取4维观测值&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110356441.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;std_weight_position = 1. / 20&lt;/code&gt;&lt;br&gt;
&lt;code&gt;std_weight_velocity = 1. / 160&lt;/code&gt;&lt;br&gt;
不确定性权重，位置标准差权重和速度标准差权重&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749110571382.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
初始化新轨迹，将检测到的目标（未关联到现有轨迹的测量值）转换为卡尔曼滤波的初始状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：检测框的测量值measurement，为[x,y,a,h]形式，中心坐标x/yx，宽高比a，高度h。&lt;/li&gt;
&lt;li&gt;输出：mean：8维状态向量，如上图所示；covariance：8X8协方差矩阵，表示状态的不确定性。&lt;br&gt;
&lt;code&gt;mean_pos=measurement&lt;/code&gt;， [x,y,a,h]，4X1的矩阵&lt;br&gt;
&lt;code&gt;mean_vel = np.zeros_like(mean_pos)&lt;/code&gt;， [0,0,0,0]，4X1的零向量&lt;br&gt;
&lt;code&gt;mean = np.r_[mean_pos, mean_vel]&lt;/code&gt;， [x,y,a,h,0,0,0,0]&lt;br&gt;
std：初始化标准差&lt;br&gt;
&lt;code&gt;std = [&lt;/code&gt;&lt;br&gt;
&lt;code&gt; 2 * self._std_weight_position * measurement[3],&lt;/code&gt;       x=2*(1/20)*h&lt;br&gt;
&lt;code&gt;2 * self._std_weight_position * measurement[3],&lt;/code&gt;       y&lt;br&gt;
&lt;code&gt; 1e-2,&lt;/code&gt;        a&lt;br&gt;
&lt;code&gt; 2 * self._std_weight_position * measurement[3],&lt;/code&gt;      h&lt;br&gt;
&lt;code&gt;  10 * self._std_weight_velocity * measurement[3],&lt;/code&gt;    vx&lt;br&gt;
&lt;code&gt; 10 * self._std_weight_velocity * measurement[3],&lt;/code&gt;     vy&lt;br&gt;
&lt;code&gt;1e-5,&lt;/code&gt;        va&lt;br&gt;
&lt;code&gt;10 * self._std_weight_velocity * measurement[3]]&lt;/code&gt;      vh&lt;br&gt;
&lt;code&gt;covariance = np.diag(np.square(std))&lt;/code&gt; 协方差矩阵初始化为对角矩阵&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749111869918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
预测步骤：根据目标的当前状态和运动模型，预测其在下一时刻的状态均值和协方差。&lt;/li&gt;
&lt;li&gt;输入：mean：8维状态向量；covariance：8X8协方差矩阵。&lt;/li&gt;
&lt;li&gt;输出：预测后的mean和covariance。&lt;br&gt;
std_pos、std_vel位置噪声和速度噪声，宽高比固定值。&lt;br&gt;
&lt;code&gt;motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))&lt;/code&gt;&lt;br&gt;
过程噪声协方差：将位置和速度噪声拼接为8维向量，平方后转为对角矩阵。&lt;br&gt;
&lt;code&gt;mean = np.dot(self._motion_mat, mean)&lt;/code&gt;&lt;br&gt;
计算两个数组的点积。&lt;br&gt;
&lt;code&gt;covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov&lt;/code&gt;&lt;br&gt;
更新协方差矩阵。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749121834548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
观测空间投影：用于将状态空间的均值和协方差映射到测量空间，同时添加观测噪声。&lt;/li&gt;
&lt;li&gt;输入：mean：8维状态均值向量；covariance：8X8状态协方差矩阵。&lt;/li&gt;
&lt;li&gt;输出：投影后的4维测量均值[x,y,a,h]和4X4测量协方差矩阵。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749122179128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
更新步骤，根据实际测量值修正预测状态。&lt;/li&gt;
&lt;li&gt;输入：mean：预测的8维状态均值；covariance：预测的8X8状态协方差矩阵；measurement：4维测量值[x,y,a,h]。&lt;/li&gt;
&lt;li&gt;输出：new_mean：新的状态均值；new_covariance：新的协方差矩阵。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1749122751445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Gating Distance：用于在目标跟踪中衡量预测轨迹与检测框之间的匹配程度。&lt;/li&gt;
&lt;li&gt;输入：mean：8维状态均值向量；covariance：8X8状态协方差矩阵；measurements：NX4的矩阵。每行是一个检测框[x,y,a,h]；only_position：若为True，则仅计算中心坐标(x,y)的距离。&lt;/li&gt;
&lt;li&gt;输出：长度为N的数组，每个元素是对应检测框与预测状态的平方马氏距离。&lt;br&gt;
&lt;code&gt;cholesky_factor = np.linalg.cholesky(covariance)&lt;/code&gt;&lt;br&gt;
对协方差矩阵进行Cholesky分解，避免直接求逆矩阵，提升数值稳定性。&lt;br&gt;
&lt;code&gt;d = measurements - mean&lt;/code&gt;&lt;br&gt;
计算残差检测框坐标-预测坐标。&lt;br&gt;
&lt;code&gt;z = scipy.linalg.solve_triangular(cholesky_factor, d.T, lower=True, check_finite=False,overwrite_b=True)&lt;/code&gt;&lt;br&gt;
解方程组，对残差进行白化处理。&lt;br&gt;
马氏距离求解：https://zhuanlan.zhihu.com/p/520757659&lt;br&gt;
余弦距离参考：https://blog.csdn.net/DeepCBW/article/details/124650876&lt;br&gt;
参考博客：https://blog.csdn.net/qq_45266796/article/details/134775492&lt;br&gt;
https://blog.csdn.net/weixin_39910711/article/details/113985520#commentBox&lt;/li&gt;
&lt;/ul&gt;
">DeepSort-卡尔曼滤波</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/opencv-du-qu-tu-pian/"" data-c="
          &lt;ul&gt;
&lt;li&gt;#python&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748771024615.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;#C++&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748771770050.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748771796101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">Opencv-读取图片</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/opencv-1-an-zhuang-opencv/"" data-c="
          &lt;ul&gt;
&lt;li&gt;安装-基于Python&lt;br&gt;
&lt;code&gt;conda create -n opencv python=3.12&lt;/code&gt; 使用conda创建名为opencv的环境，python版本为3.12&lt;br&gt;
&lt;code&gt;conda activate opencv&lt;/code&gt; 激活opencv环境&lt;br&gt;
&lt;code&gt;conda env list&lt;/code&gt; 查看创建的环境&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489479425.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;conda install -c conda-forge opencv&lt;/code&gt; 安装opencv&lt;br&gt;
安装好检测是否成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489529762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;安装-基于C++&lt;br&gt;
1、访问Opencv的官方下载页面：https://opencv.org/releases/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489940154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
选择opencv-4.11.0的windows版本&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747489972481.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
解压&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747490331641.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置环境变量&lt;br&gt;
将D:\Opencv\opencv\build\x64\vc16\bin添加到系统的环境变量中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747490598040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747490568639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2、安装MinGW-w64&lt;br&gt;
3、CMake&lt;br&gt;
在官网下载CMake，选择二进制文件&lt;br&gt;
https://cmake.org/download/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491005571.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
解压&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491214352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将cmake的bin文件路径添加到系统环境变量中&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491773065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491851776.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检测cmake是否安装成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747491907678.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4、生成MakeFiles&lt;br&gt;
在D:\Opencv\opencv\build\x64下新建一个MinGW文件夹&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492401805.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进入D:\Opencv\cmake-4.0.2-windows-x86_64 (1)\cmake-4.0.2-windows-x86_64\bin，打开cmake-gui。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492454143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击configure，配置如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492530080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
路径C:\msys64\ucrt64\bin下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747492800252.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
等待&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747493149028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
显示Configure done，勾选BUILD_opencv_world、WITH_OPENGL和BUILD EXAMPLES，不勾选WITH_IPP、WITH_MSMF和ENABLE_PRECOMPILED_HEADERS，CPU_DISPATCH选空，再次点击Configure&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747493471534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
手动下载未下载的文件&lt;br&gt;
https://raw.githubusercontent.com/opencv/opencv_3rdparty/d63d7c154c57242bf2283be61166be2bd30ec47e/ffmpeg/opencv_videoio_ffmpeg.dll&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494166907.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494174939.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
https://raw.githubusercontent.com/opencv/opencv_3rdparty/d63d7c154c57242bf2283be61166be2bd30ec47e/ffmpeg/opencv_videoio_ffmpeg_64.dll&lt;br&gt;
同上&lt;br&gt;
再次点击Configure，出现Configure done后，点击Generate&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494436549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如MakeFiles文件成功生成，CMakeDownloadLog.txt显示如下&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494536906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5、编译Opencv(先激活opencv环境)&lt;br&gt;
使用cmake确保安装python3，且python配好环境变量&lt;br&gt;
cmd到makefile所在文件夹&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494805786.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
键入mingw32-make -j 8&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747494894040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747495801216.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747538192757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
c++版本低于c++14&lt;br&gt;
在powershell中查看c++版本&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747538942930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747538990348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为c++17，Anaconda的mingw编译器版本过低，环境变量优先级高&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747539719911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将msys上移后，无效，还是报错&lt;br&gt;
键入mingw32-make clean清除后，重新mingw32-make -j4&lt;br&gt;
无效，继续报错。😵😵😵&lt;br&gt;
猜测激活环境后，还是继续使用anaconda的编译器，conda deactivate退出opencv环境试试。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747542655268.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
🤡🤡🤡&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747547073309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
升级conda的c++编译器&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747547723531.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
无效，待续。&lt;br&gt;
重新安装mingw64&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747734865352.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加到系统环境变量&lt;br&gt;
在vscode里面重新配置g++,测试成功后。删除原来的makefile&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747736131803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747736315089.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
重新按上述步骤操作&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747737230891.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还是报同样的错&lt;br&gt;
删除E盘Library/include，重新运行，然后报错无avif/avif/h，再将include恢复到E盘library下，继续重新运行&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747742794786.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
继续报错，运行mingw32-make单线程编译&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747743151148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
到99%报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747745421775.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
关闭下图这个&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747745704938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747752339448.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747755472659.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编译成功，开始装载&lt;br&gt;
mingw-make install&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747755544527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加系统环境变量D:\Opencv\opencv\build\x64\MinGW\bin&lt;br&gt;
6、VS Code配置&lt;br&gt;
launch.json配置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747756193337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
c_cpp_properties配置（ctrl+shift+p)&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747756572998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
task.json配置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747756834975.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
setting配置&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747757386578.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
setting.json看博客。&lt;br&gt;
7、测试&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747757512038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错，修改setting.json中的cpp项路径。&lt;br&gt;
tasks.json添加程序如下图&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748056879144.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748056887645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748056961505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
按照第二篇博客配置，成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1748058852986.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
参考博客：https://blog.csdn.net/weixin_43101257/article/details/124472866&lt;br&gt;
https://blog.csdn.net/qq_41171302/article/details/146435360&lt;/li&gt;
&lt;/ul&gt;
">Opencv-(1)-安装opencv</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/vs-code-pei-zhi-gcc/"" data-c="
          &lt;ul&gt;
&lt;li&gt;在vs code官网下载安装vs code&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747463277123.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;下载msys2-installer&lt;br&gt;
https://www.mingw-w64.org/&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464185379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击msys2&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464233168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击Github&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464303869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464334016.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击msys2-x86_64-20250221.exe，下载&lt;/li&gt;
&lt;li&gt;安装msys2&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464520698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击下一步&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464571166.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464607311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464643428.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进度条走完，继续默认下一步&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747464979561.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认勾选，点击Finishe&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465030412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
键入pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain&lt;br&gt;
按回车，输入y&lt;br&gt;
等待下载完成，关闭终端&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465448602.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
打开安装msys2的目录，找到ucrt64文件夹并进入，找到bin文件，复制路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465614698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
搜索框搜索编辑环境变量，打开&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465686709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击环境变量&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465746403.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在打开的界面中找到用户变量的Path&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465832295.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双击打开&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465873286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击新建，粘贴复制的路径，点击确定&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747465943698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
退出即可&lt;/li&gt;
&lt;li&gt;测试gcc&lt;br&gt;
按win+r，输入cmd&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466056132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
依次输入回车，如图即配置环境成功&lt;/li&gt;
&lt;li&gt;汉化vs code&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466168736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466243642.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
安装完成后，点击右下角改变语言并重启&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466288143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466340999.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;安装C/C++扩展包&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747466478165.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">vs code配置gcc</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/gitee/"" data-c="
          &lt;ul&gt;
&lt;li&gt;新建仓库&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374716051.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;填写路径名称&lt;/li&gt;
&lt;li&gt;创建成功&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374809675.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;打开git bash&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374909560.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;git init&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1747374947541.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现文件夹下面多一个.git文件夹&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375008241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击进去，编辑config文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375063497.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375644863.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
编辑好保存，回到gitee，点击克隆/下载&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375308908.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
复制，在bash界面输入git remote add origin + 链接&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375400900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git pull origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375837196.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git add .&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747375957872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git commit -m &#39;说明&#39;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747376050341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入命令git push origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747376171705.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报错如图&lt;br&gt;
输入命令git push -f origin master&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1747376215344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;刷新gitee&lt;/li&gt;
&lt;/ul&gt;
">gitee上传代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-trackpy/"" data-c="
          &lt;h1 id=&#34;import&#34;&gt;import&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743770558767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sys.path.insert(0, &#39;./yolov5&#39;)&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743770809662.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;sys.path=E:\Yolov5\DeepSort\Yolov5_DeepSort\Yolov5_DeepSort&lt;/li&gt;
&lt;li&gt;track.py是 YOLOv5 的目标跟踪脚本，通常需要调用 yolov5 目录下的模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;串口&#34;&gt;串口&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743770990492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;port_list = list(serial.tools.list_ports.comports())&lt;/code&gt;获取当前计算机上所有可用的串口设备列表，并转换为 Python 列表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if len(port_list) == 0:&lt;/code&gt;如果 port_list 为空（len(port_list) == 0），打印 &#39;none&#39;，表示未检测到任何串口设备。&lt;br&gt;
否则，遍历列表并逐个打印每个串口的详细信息（如名称、描述、制造商等）。&lt;br&gt;
&lt;code&gt;portName = &amp;quot;COM3&amp;quot;  # 端口名&lt;/code&gt;&lt;br&gt;
&lt;code&gt;baudRate = 9600  # 波特率&lt;/code&gt;&lt;br&gt;
&lt;code&gt;timeOut = 3&lt;/code&gt;&lt;br&gt;
portName：指定要使用的串口名称（如 COM3 是 Windows 下的典型串口名，Linux/Mac 下可能是 /dev/ttyUSB0）。&lt;br&gt;
baudRate：设置通信波特率（常见值如 9600、115200 等），需与设备端配置一致。&lt;br&gt;
timeOut：设置串口读取超时时间（秒），超过该时间未收到数据则抛出异常。&lt;/li&gt;
&lt;li&gt;作用：&lt;br&gt;
硬件交互：与 Arduino、传感器或其他通过串口通信的设备连接。&lt;br&gt;
调试：确认系统中可用的串口设备，避免手动输入错误端口名。&lt;br&gt;
初始化配置：为后续的串口通信（如 serial.Serial(portName, baudRate, timeout=timeOut)）提供参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;palette&#34;&gt;palette&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;palette = (2 ** 11 - 1, 2 ** 15 - 1, 2 ** 20 - 1)&lt;/code&gt;生成一个包含三个整数的元组，用于表示某种颜色或ID的调色板（Palette）。&lt;br&gt;
2 ** 11 - 1 = 2047&lt;br&gt;
（二进制：11111111111，11位全1）&lt;br&gt;
2 ** 15 - 1 = 32767&lt;br&gt;
（二进制：111111111111111，15位全1）&lt;br&gt;
2 ** 20 - 1 = 1048575&lt;br&gt;
（二进制：11111111111111111111，20位全1）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743771523431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;datect&#34;&gt;datect&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743827853930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;initialize-deepsort&#34;&gt;initialize deepsort&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743828065304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cfg = get_config()&lt;/code&gt;调用 get_config() 函数获取一个默认的配置对象（通常是一个 Config 或 EasyDict 类型的对象）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743828190043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfg.merge_from_file(opt.config_deepsort)&lt;/code&gt;从文件 opt.config_deepsort（路径由命令行参数 opt 提供）加载 DeepSort 的配置文件，并合并到 cfg 中。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743828328772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
REID_CKPT:指定 ReID（重识别）模型的权重文件路径。&lt;br&gt;
MAX_DIST: 特征匹配的最大余弦距离阈值。当两个目标的特征向量距离超过 0.2 时，认为它们不匹配。值越小，匹配越严格。&lt;br&gt;
MIN_CONFIDENCE:检测结果的最小置信度阈值。忽略置信度低于 0.3 的检测框.&lt;br&gt;
NMS_MAX_OVERLAP:非极大值抑制（NMS）的重叠阈值。若两个检测框的 IoU（交并比）超过 0.5，则保留置信度更高的框，抑制另一个。&lt;br&gt;
MAX_IOU_DISTANCE:ioU 距离的最大阈值，用于关联检测框和跟踪轨迹。当检测框与预测轨迹的 IoU 距离 ≤ 0.7 时，认为它们可能属于同一目标。&lt;br&gt;
MAX_AGE:轨迹的最大存活帧数,若轨迹连续 70 帧未被匹配到检测框，则删除该轨迹。&lt;br&gt;
N_INIT:新检测目标需连续 3 帧成功匹配，才确认为有效轨迹&lt;br&gt;
NN_BUDGET: 每个轨迹最多保留 100 个历史特征，用于后续匹配，平衡内存和跟踪精度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if os.path.exists(out):&lt;/code&gt;检查输出目录 out 是否已存在。如果目录存在，可能需要先删除旧数据以避免冲突。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.rmtree(out)&lt;/code&gt;递归删除输出目录 out 及其所有内容.确保每次运行时输出目录是空的，避免旧结果干扰新结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.makedirs(out)&lt;/code&gt;重新创建输出目录 out。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;half = device.type != &#39;cpu&#39;&lt;/code&gt;根据设备类型决定是否启用半精度（FP16）计算。&lt;br&gt;
evice.type 是运行设备（如 &#39;cuda&#39; 或 &#39;cpu&#39;）。&lt;br&gt;
半精度（half=True）仅支持 GPU（CUDA），可加速计算并减少显存占用。&lt;br&gt;
如果是 CPU 运行，则强制使用全精度（half=False）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;load-model&#34;&gt;load model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743829011354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;model = attempt_load(yolo_weights, map_location=device)&lt;/code&gt;&lt;br&gt;
加载预训练的 YOLO 模型。&lt;br&gt;
yolo_weights：YOLO 模型权重文件的路径（如 yolov5s.pt）。&lt;br&gt;
map_location=device：指定模型加载的设备（如 &#39;cuda:0&#39; 或 &#39;cpu&#39;）。&lt;br&gt;
默认加载全精度（FP32）模型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stride = int(model.stride.max())&lt;/code&gt;&lt;br&gt;
获取模型的最大步长（stride）。stride 是 YOLO 模型下采样的倍数（如 8、16、32），影响输入图像的尺寸要求。YOLOv5 的 stride 通常是 32（最终特征图的缩放比例）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgsz = check_img_size(imgsz, s=stride)&lt;/code&gt;check_img_size 确保 imgsz 是 stride 的整数倍（避免尺寸对齐问题）。&lt;br&gt;
例如，若 stride=32，imgsz=640 会被接受，而 imgsz=641 会被调整为 640。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;names = model.module.names if hasattr(model, &#39;module&#39;) else model.names&lt;/code&gt;&lt;br&gt;
获取模型训练的类别名称列表&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743829338242.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if half: model.half()&lt;/code&gt;将模型转换为半精度（FP16）模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vid_path, vid_writer = None, None&lt;/code&gt;初始化视频路径和视频写入器变量为 None。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show_vid = check_imshow()&lt;/code&gt;检查当前环境是否支持图像显示&lt;br&gt;
check_imshow()：通常尝试创建一个测试窗口，验证是否支持 cv2.imshow()。&lt;br&gt;
如果环境不支持（如无 GUI 的服务器），则 show_vid 会被设为 False，避免显示报错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cudnn.benchmark = True&lt;/code&gt;启用 cuDNN 的自动优化模式，加速固定尺寸图像的推理（适用于摄像头输入分辨率不变的情况）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;run-inference&#34;&gt;Run inference&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743829837311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;model(torch.zeros(1, 3, imgsz, imgsz).to(device).type_as(next(model.parameters())))&lt;/code&gt;模型预热（Warm-up）。&lt;br&gt;
生成一个全零的虚拟输入张量，形状为 (1, 3, imgsz, imgsz)（批大小 1，3 通道，尺寸 imgsz x imgsz）。&lt;br&gt;
to(device)：将张量移动到指定设备（GPU/CPU）。&lt;br&gt;
type_as(...)：确保张量数据类型与模型参数一致（如 FP16/FP32）。&lt;br&gt;
执行一次前向推理（model(...)）。&lt;br&gt;
初始化 GPU 的 CUDA 上下文，避免首次正式推理时的延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;模型推理-nmsprocessdetections&#34;&gt;模型推理 NMS/process/detections&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743830448793.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for frame_idx, (path, img, im0s, vid_cap) in enumerate(dataset):&lt;/code&gt;&lt;br&gt;
从数据加载器 dataset 中逐帧读取数据，返回：&lt;br&gt;
path：当前帧的路径（如视频文件路径或摄像头索引）。&lt;br&gt;
img：预处理后的图像（尺寸调整、归一化等，形状为 [H, W, C] 或 [B, H, W, C]）。&lt;br&gt;
im0s：原始图像（未缩放的 OpenCV 格式，用于可视化或保存结果）。&lt;br&gt;
vid_cap：视频捕获对象（仅视频文件有效）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = torch.from_numpy(img).to(device)&lt;/code&gt;将 img 转换为 PyTorch 张量并移动到指定设备（GPU/CPU）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = img.half() if half else img.float()  # uint8 to fp16/32&lt;/code&gt;根据 half 参数选择半精度（FP16）或全精度（FP32）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img /= 255.0  # 0 - 255 to 0.0 - 1.0&lt;/code&gt;归一化像素值到 [0.0, 1.0] 范围。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if img.ndimension() == 3:img = img.unsqueeze(0)&lt;/code&gt;如果输入是单张图像（ndimension() == 3），增加批次维度（unsqueeze(0)）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t1 = time_synchronized()&lt;/code&gt;time_synchronized()：同步 GPU 操作并记录时间戳 t1（用于计算推理耗时）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pred = model(img, augment=opt.augment)[0]&lt;/code&gt;&lt;br&gt;
执行模型推理：augment：是否启用数据增强（如多尺度测试）。&lt;br&gt;
pred：模型的原始输出（未处理的检测框，形状为 [N, 6]，其中 6 为 [x1, y1, x2, y2, conf, cls]）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;non_max_suppression&lt;/code&gt;过滤冗余检测框：&lt;br&gt;
opt.conf_thres：置信度阈值（低于此值的检测框被丢弃）。&lt;br&gt;
opt.iou_thres：IoU 阈值（重叠高于此值的框会被合并）。&lt;br&gt;
classes：指定保留的类别（如只检测行人）。&lt;br&gt;
agnostic：是否跨类别进行 NMS（如合并不同类别的重叠框）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p, s, im0 = path[i], &#39;%g: &#39; % i, im0s[i].copy()&lt;/code&gt;webcam 为 True 时，处理多路视频流（path[i] 和 im0s[i]）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p, s, im0 = path, &#39;&#39;, im0s&lt;/code&gt;webcam 为 False 时，处理单路输入（path 和 im0s）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s += &#39;%gx%g &#39; % img.shape[2:]  # print string&lt;/code&gt;构建日志字符串（如 &amp;quot;640x480 &amp;quot;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;boxes&#34;&gt;boxes&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743831544299.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;det[:, :4] = scale_coords(img.shape[2:], det[:, :4], im0.shape).round()&lt;/code&gt;&lt;br&gt;
将检测框坐标从模型输入尺寸（img.shape[2:]，如 640x640）缩放到原始图像尺寸（im0.shape，如 1920x1080）。输出：det 的坐标变为 [x1, y1, x2, y2]（原始图像尺度）。&lt;br&gt;
scale_coords：线性缩放坐标（保持宽高比）。&lt;br&gt;
.round()：将坐标四舍五入为整数（便于后续绘制或处理）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s += &#39;%g %ss, &#39; % (n, names[int(c)])&lt;/code&gt;&lt;br&gt;
示例输出：若检测到 2 人和 1 车，s 变为 &amp;quot;2 persons, 1 cars, &amp;quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x_c, y_c, bbox_w, bbox_h = xyxy_to_xywh(*xyxy)&lt;/code&gt;将 YOLO 的 xyxy 格式转换为 DeepSort 所需的 [x_center, y_center, width, height] 格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;outputs = deepsort.update(xywhs, confss, im0)&lt;/code&gt;&lt;br&gt;
输入：&lt;br&gt;
xywhs：检测框的中心坐标和宽高。&lt;br&gt;
confss：检测置信度。&lt;br&gt;
im0：原始图像（用于视觉特征提取）。&lt;br&gt;
输出：outputs 形状为 [M, 5]，每行为 [x1, y1, x2, y2, track_id]（跟踪后的目标框和 ID）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743835223285.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743835539421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;stream-results&#34;&gt;Stream results&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743835635489.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;xyxy-to-xywh&#34;&gt;xyxy to xywh&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743836706336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入：*xyxy&lt;br&gt;
可变参数，接受 4 个值（x1, y1, x2, y2），表示检测框的左上角和右下角坐标。&lt;br&gt;
输出：返回 4 个值（x_c, y_c, w, h），即中心点坐标和宽高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bbox_left = min([xyxy[0].item(), xyxy[2].item()])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bbox_top = min([xyxy[1].item(), xyxy[3].item()])&lt;/code&gt;&lt;br&gt;
确保 bbox_left 和 bbox_top 是左上角坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bbox_w = abs(xyxy[0].item() - xyxy[2].item())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bbox_h = abs(xyxy[1].item() - xyxy[3].item())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;.item() 的作用：&lt;br&gt;
如果输入是 PyTorch 张量，.item() 将其转换为 Python 标量（数值）。&lt;br&gt;
使用绝对值保证宽高为正数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x_c = (bbox_left + bbox_w / 2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y_c = (bbox_top + bbox_h / 2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;xyxy-to-tlwh&#34;&gt;xyxy to tlwh&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837084243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
用于将目标检测框的坐标从 [x1, y1, x2, y2]（左上角和右下角坐标）格式转换为 [top_left_x, top_left_y, width, height]（左上角坐标 + 宽高）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for i, box in enumerate(bbox_xyxy):&lt;/code&gt;遍历每个检测框&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x1, y1, x2, y2 = [int(i) for i in box]&lt;/code&gt;将坐标值强制转换为整数（适用于浮点数输入或张量）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;label-color&#34;&gt;label color&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837282041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据目标类别标签（label）生成一个固定的颜色值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def compute_color_for_labels(label):&lt;/code&gt;&lt;br&gt;
输入：label&lt;br&gt;
目标的类别标签（整数，如 0 表示 &amp;quot;person&amp;quot;，1 表示 &amp;quot;car&amp;quot;）。&lt;br&gt;
输出：一个 RGB 颜色元组（如 (255, 128, 0)），用于可视化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color = [int((p * (label ** 2 - label + 1)) % 255) for p in palette]&lt;/code&gt;&lt;br&gt;
公式 label ** 2 - label + 1 是一个简单的哈希函数，确保不同 label 映射到不同的颜色值。&lt;br&gt;
% 255 保证结果在 [0, 255] 范围内（RGB 值的合法区间）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return tuple(color)&lt;/code&gt;&lt;br&gt;
将列表 color 转换为元组（如 (R, G, B)），便于 OpenCV 等库使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;draw-boxes&#34;&gt;draw boxes&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837478158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837658670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837691869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837743841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837781892.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837833620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743837878782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id = int(identities[i]) if identities is not None else 0&lt;/code&gt;&lt;br&gt;
若未提供 identities，默认 ID 为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color = compute_color_for_labels(id)&lt;/code&gt;&lt;br&gt;
调用 compute_color_for_labels根据 ID 生成唯一颜色（用于框和文本）。&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计track.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-trainpy/"" data-c="
          &lt;h1 id=&#34;set-ddp-variables设置分布式训练参数&#34;&gt;Set DDP variables设置分布式训练参数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743430632740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
world_size：表示参与分布式训练的进程总数（GPU 数量）。从环境变量 WORLD_SIZE 中读取（由分布式框架如 torch.distributed 自动设置），若未设置则默认为 1（单机单卡）。&lt;br&gt;
global_rank：表示当前进程的全局排名（从 0 到 world_size-1）。从环境变量 RANK 中读取，若未设置则默认为 -1（非分布式模式）.&lt;/p&gt;
&lt;h1 id=&#34;resume-恢复&#34;&gt;resume 恢复&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743430973122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;opt.data, opt.cfg, opt.hyp = check_file(opt.data), check_file(opt.cfg), check_file(opt.hyp)  # check files&lt;/code&gt;&lt;br&gt;
检查文件路径：check_file() 确保 opt.data（数据集配置）、opt.cfg（模型配置）、opt.hyp（超参数文件）存在。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assert len(opt.cfg) or len(opt.weights), &#39;either --cfg or --weights must be specified&#39;&lt;/code&gt;&lt;br&gt;
assert len(opt.cfg) or len(opt.weights) 确保必须指定 --cfg（模型结构）或 --weights（预训练权重）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opt.img_size.extend([opt.img_size[-1]] * (2 - len(opt.img_size)))&lt;/code&gt;&lt;br&gt;
opt.img_size.extend(...) 将 img_size 扩展为 2 个值（训练和测试尺寸相同），例如 [640] → [640, 640]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ddp-model&#34;&gt;DDP Model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743431434703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if opt.local_rank != -1:&lt;/code&gt;如果 opt.local_rank 不是 -1，表示启用分布式训练&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(opt.hyp) as f:&lt;/code&gt;从 opt.hyp 指定的 YAML 文件中加载超参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hyp = yaml.load(f, Loader=yaml.FullLoader)  # load hyps&lt;/code&gt; 使用 yaml.FullLoader 解析 YAML 文件为字典（hyp）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if &#39;box&#39; not in hyp:&lt;/code&gt;检查超参数中是否存在 &#39;box&#39; 键（用于边界框损失计算）。如果不存在，则假设旧版参数 &#39;giou&#39; 存在，并将其重命名为 &#39;box&#39;，同时输出兼容性警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;train&#34;&gt;Train&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743432009952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logger.info(opt&lt;/code&gt;)使用 logger 打印 opt（训练配置参数），方便用户查看当前的训练设置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if not opt.evolve:&lt;/code&gt;检查是否处于超参数进化模式（evolve）。如果不是，则执行后续的 TensorBoard 初始化逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tb_writer = None  # init loggers&lt;/code&gt; 初始化 tb_writer（TensorBoard 写入器）为 None，后续会根据条件重新赋值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if opt.global_rank in [-1, 0]:&lt;/code&gt;检查当前进程的全局排名（global_rank），通常用于分布式训练。-1 表示单机训练，0 表示主进程（在多机多卡训练中）。只有主进程或单机训练时才执行以下操作，避免重复记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(f&#39;Start Tensorboard with &amp;quot;tensorboard --logdir {opt.project}&amp;quot;, view at http://localhost:6006/&#39;)&lt;/code&gt;&lt;br&gt;
打印提示信息，告诉用户如何启动 TensorBoard 服务，并指定日志目录为 opt.project（训练结果保存路径）。用户可以通过访问 http://localhost:6006/ 查看训练过程的可视化结果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tb_writer = SummaryWriter(opt.save_dir)  # Tensorboard&lt;/code&gt;初始化 SummaryWriter（TensorBoard 的日志写入器），日志将保存到 opt.save_dir（模型和日志的保存目录）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;train(hyp, opt, device, tb_writer, wandb)&lt;/code&gt;调用&lt;br&gt;
train函数开始训练，传入以下参数：&lt;br&gt;
hyp：超参数配置（如学习率、权重衰减等）。&lt;br&gt;
opt：训练选项（如数据集路径、批次大小等）。&lt;br&gt;
device：训练设备（如 cuda:0 或 cpu）。&lt;br&gt;
tb_writer：TensorBoard 写入器，用于记录训练指标。&lt;br&gt;
wandb：可选参数，用于 Weights &amp;amp; Biases 日志记录（如果启用）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743509985474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;def train(hyp, opt, device, tb_writer=None, wandb=None):&lt;/code&gt;&lt;br&gt;
定义训练函数 train，接收以下参数：&lt;br&gt;
hyp：超参数配置（如学习率、权重衰减等）。&lt;br&gt;
opt：训练选项（如数据集路径、批次大小等）。&lt;br&gt;
device：训练设备（如 cuda:0 或 cpu）。&lt;br&gt;
tb_writer（可选）：TensorBoard 日志写入器，默认为 None。&lt;br&gt;
wandb（可选）：Weights &amp;amp; Biases 日志工具，默认为 None。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(f&#39;Hyperparameters {hyp}&#39;)&lt;/code&gt;&lt;br&gt;
使用 logger 打印当前的超参数配置 hyp，方便调试和记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wdir = save_dir / &#39;weights&#39;&lt;/code&gt;定义权重文件的保存目录（save_dir/weights）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wdir.mkdir(parents=True, exist_ok=True)  # make dir&lt;/code&gt;&lt;br&gt;
parents=True：自动创建父目录（如果不存在）。&lt;br&gt;
exist_ok=True：如果目录已存在，不报错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last = wdir / &#39;last.pt&#39;&lt;/code&gt;保存最后一轮的模型权重。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;best = wdir / &#39;best.pt&#39;&lt;/code&gt;保存验证集上性能最好的模型权重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;results_file = save_dir / &#39;results.txt&#39;&lt;/code&gt;保存训练过程中的指标（如损失、精度等）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743510469538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(save_dir / &#39;hyp.yaml&#39;, &#39;w&#39;) as f:&lt;/code&gt;将超参数 hyp 保存到 save_dir/hyp.yaml 文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(save_dir / &#39;opt.yaml&#39;, &#39;w&#39;) as f:&lt;/code&gt;将训练选项 opt（通过 vars(opt) 转换为字典）保存到 save_dir/opt.yaml 文件。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743510713288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yaml.dump(hyp, f, sort_keys=False)&lt;/code&gt;&lt;br&gt;
sort_keys=False 保持参数原始顺序，不按字母排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plots = not opt.evolve&lt;/code&gt;plots：是否生成训练曲线图（如果是超参数进化模式 evolve，则不生成）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cuda = device.type != &#39;cpu&#39;&lt;/code&gt;检查当前设备是否为 GPU&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data_dict = yaml.load(f, Loader=yaml.FullLoader)&lt;/code&gt;&lt;br&gt;
从 opt.data（数据集配置文件路径，如 data/coco.yaml）加载 YAML 文件，解析为字典 data_dict。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743511070491.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;train_path = data_dict[&#39;train&#39;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test_path = data_dict[&#39;val&#39;]&lt;/code&gt;&lt;br&gt;
从 data_dict 中获取训练集和验证集的路径&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743511297397.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nc = 1 if opt.single_cls else int(data_dict[&#39;nc&#39;])&lt;/code&gt;&lt;br&gt;
类别数量。如果启用单类别模式（opt.single_cls），则强制设为 1；否则使用 data_dict[&#39;nc&#39;]。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;names = [&#39;item&#39;] if opt.single_cls and len(data_dict[&#39;names&#39;]) != 1 else data_dict[&#39;names&#39;]&lt;/code&gt;&lt;br&gt;
类别名称列表。如果是单类别模式且配置文件中名称不唯一，则设为 [&#39;item&#39;]；否则使用 data_dict[&#39;names&#39;]。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assert len(names) == nc, &#39;%g names found for nc=%g dataset in %s&#39; % (len(names), nc, opt.data)&lt;/code&gt;检查类别数量 nc 和名称列表 names 的长度是否一致，否则报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;model&#34;&gt;Model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743511567205.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pretrained = weights.endswith(&#39;.pt&#39;)&lt;/code&gt;通过检查 weights 路径是否以 .pt 结尾，判断是否使用预训练权重&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with torch_distributed_zero_first(rank):&lt;/code&gt;确保分布式训练中，主进程先下载权重，其他进程等待。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;attempt_download(weights)&lt;/code&gt;如果本地不存在 weights 文件，则从网络下载（如从 YOLOv5 官方仓库下载）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ckpt = torch.load(weights, map_location=device)&lt;/code&gt;加载 .pt 文件到 ckpt（字典形式），并指定加载到 device（如 cuda:0 或 cpu）。ckpt 通常包含模型权重 state_dict、超参数 hyp、模型配置 yaml 等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if hyp.get(&#39;anchors&#39;):&lt;/code&gt;如果超参数 hyp 中指定了 anchors，则强制覆盖模型配置中的锚点参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; ckpt[&#39;model&#39;].yaml[&#39;anchors&#39;] = round(hyp[&#39;anchors&#39;])&lt;/code&gt;round(hyp[&#39;anchors&#39;]) 对锚点值取整，确保其为整数。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743516282637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743516489869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;model = Model(opt.cfg or ckpt[&#39;model&#39;].yaml, ch=3, nc=nc).to(device)&lt;/code&gt;&lt;br&gt;
如果 opt.cfg（模型配置文件路径）存在，则优先使用；否则使用预训练模型中的配置 ckpt[&#39;model&#39;].yaml。&lt;br&gt;
ch=3：输入图像的通道数（RGB）。&lt;br&gt;
nc=nc：类别数量（从数据集配置中获取）。&lt;br&gt;
.to(device)：将模型移动到指定设备（GPU/CPU）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743516848843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exclude = [&#39;anchor&#39;] if opt.cfg or hyp.get(&#39;anchors&#39;) else []&lt;/code&gt;如果使用自定义配置（opt.cfg）或覆盖锚点（hyp[&#39;anchors&#39;]），则排除 anchor 相关权重（防止冲突）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state_dict = ckpt[&#39;model&#39;].float().state_dict()&lt;/code&gt;将预训练权重转换为 FP32 格式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state_dict = intersect_dicts(state_dict, model.state_dict(), exclude=exclude)&lt;/code&gt;筛选预训练权重中与当前模型结构匹配的部分（忽略不匹配的层）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;model.load_state_dict(state_dict, strict=False)&lt;/code&gt;加载权重，允许部分加载&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(&#39;Transferred %g/%g items from %s&#39; % (len(state_dict), len(model.state_dict()), weights))&lt;/code&gt;记录成功加载的权重数量（例如 Transferred 300/320 items from yolov5s.pt）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;else:model = Model(opt.cfg, ch=3, nc=nc).to(device)  # create&lt;/code&gt;如果没有提供预训练权重（pretrained=False），则直接根据 opt.cfg 创建新模型，并随机初始化权重。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;freeze&#34;&gt;Freeze&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;freeze = []&lt;/code&gt;定义一个空列表 freeze，用于存储需要冻结的层名称。用户可以通过修改 freeze 列表（例如 freeze = [&#39;backbone&#39;]）来冻结模型的某些部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for k, v in model.named_parameters():&lt;/code&gt;遍历模型中所有可训练参数，k 是参数名称（如 model.0.conv.weight），v 是参数张量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v.requires_grad = True&lt;/code&gt;默认将所有参数的 requires_grad 设为 True，表示在训练时更新这些参数的权重。默认启用梯度计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if any(x in k for x in freeze): print(&#39;freezing %s&#39; % k) v.requires_grad = False&lt;/code&gt;检查当前参数名称 k 是否包含 freeze 列表中的任何子字符串（例如 k 包含 backbone）。&lt;br&gt;
如果匹配，则打印冻结日志，并将该参数的 requires_grad 设为 False（冻结权重，不参与梯度更新）&lt;br&gt;
若 freeze = [&#39;backbone&#39;]，则所有名称中包含 backbone 的层（如backbone.conv1.weight）会被冻结。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;optimizer-优化器&#34;&gt;optimizer 优化器&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743518275245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nbs = 64  # nominal batch size&lt;/code&gt;名义批次大小（Nominal Batch Size），默认为 64，作为基准值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accumulate = max(round(nbs / total_batch_size), 1)&lt;/code&gt;梯度累积步数。当实际总批次大小（total_batch_size，如多卡训练的全局批次）小于 nbs 时，通过多次前向-反向传播累积梯度，再更新权重（等效增大批次大小）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hyp[&#39;weight_decay&#39;] *= total_batch_size * accumulate / nbs&lt;/code&gt;根据实际批次大小调整权重衰减系数，保持与名义批次的一致性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pg0, pg1, pg2 = [], [], []&lt;/code&gt;&lt;br&gt;
将模型参数分为三组，用于差异化优化策略：&lt;br&gt;
pg0：BatchNorm2d 层的权重（不应用权重衰减）。&lt;br&gt;
pg1：普通卷积层的权重（应用权重衰减）。&lt;br&gt;
pg2：所有层的偏置参数（不应用权重衰减）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if opt.adam:&lt;/code&gt;&lt;br&gt;
如果使用 Adam 优化器（opt.adam=True）：&lt;br&gt;
初始化 Adam，设置学习率 lr0，并将 beta1 替换为超参数 momentum。&lt;br&gt;
默认使用 SGD 优化器：&lt;br&gt;
初始化 SGD，设置学习率 lr0、动量 momentum，并启用 Nesterov 加速。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimizer.add_param_group({&#39;params&#39;: pg1, &#39;weight_decay&#39;: hyp[&#39;weight_decay&#39;]})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimizer.add_param_group({&#39;params&#39;: pg2})&lt;/code&gt;&lt;br&gt;
将分组参数添加到优化器：&lt;br&gt;
pg1（卷积权重）附带权重衰减。&lt;br&gt;
pg2（偏置）不附带权重衰减。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lf = one_cycle(1, hyp[&#39;lrf&#39;], epochs)&lt;/code&gt;one_cycle：生成一个余弦退火学习率调度函数，初始值为 1，最终值降至 hyp[&#39;lrf&#39;]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)&lt;/code&gt;&lt;br&gt;
LambdaLR：将调度函数 lf 应用到优化器，实现学习率动态调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;resume&#34;&gt;Resume&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743741125203.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
start_epoch：初始化为 0，表示训练从第 0 个 epoch 开始。&lt;br&gt;
best_fitness：初始化为 0.0，用于记录模型的最佳性能指标&lt;br&gt;
如果 pretrained 为 True，表示需要加载预训练模型的参数。&lt;br&gt;
ckpt 是预训练模型的检查点（checkpoint）字典。&lt;br&gt;
如果检查点中包含优化器状态（ckpt[&#39;optimizer&#39;] 不为 None），则将其加载到当前优化器（optimizer）中，以恢复训练时的优化器参数（如动量、学习率等）。&lt;br&gt;
从检查点中加载之前保存的最佳性能指标（best_fitness），用于后续模型保存和早停（early stopping）等逻辑。&lt;/p&gt;
&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743741510973.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ckpt 是预训练模型的检查点字典。使用 ckpt.get(&#39;training_results&#39;) 检查检查点中是否包含键 &#39;training_results&#39;（历史训练结果，如损失、精度等指标）。如果存在（不为 None），则执行后续操作。&lt;br&gt;
results_file 是保存训练结果的文件路径（默认是 results.txt）。以写入模式（&#39;w&#39;）打开文件，并将检查点中的 training_results内容写入文件中。这样做的目的是恢复之前的训练记录，方便后续继续训练时能够跟踪完整的训练历史。&lt;/p&gt;
&lt;h1 id=&#34;epochs&#34;&gt;Epochs&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743741693792.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从检查点 ckpt 中加载之前训练到的 epoch 值（ckpt[&#39;epoch&#39;]），并 +1 作为本次训练的起始 epoch。&lt;br&gt;
如果用户通过命令行参数 --resume 显式要求恢复训练：&lt;br&gt;
使用 assert 检查 start_epoch 是否大于 0。如果为 0，说明之前已经完成了全部 epochs 的训练，无需恢复，直接报错提示。&lt;br&gt;
错误消息示例：&amp;quot;model.pt training to 200 epochs is finished, nothing to resume.&amp;quot;&lt;br&gt;
如果用户设置的 epochs（本次训练的总 epoch 数）小于 start_epoch（恢复的起始 epoch）：&lt;br&gt;
说明用户可能想继续微调（fine-tune）模型，因此将总 epoch 数调整为 原 epochs + 已训练的 epoch 数。&lt;br&gt;
例如：检查点已训练 50 个 epoch，用户设置 epochs=10，则实际总 epoch 数为 50 + 10 = 60。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;del ckpt, state_dict&lt;/code&gt;删除检查点 ckpt 和模型状态字典 state_dict，释放内存资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;image-size&#34;&gt;Image size&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743742131661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gs = int(model.stride.max())&lt;/code&gt;&lt;br&gt;
model.stride 是模型各层的下采样步长（如 [8, 16, 32]）。&lt;br&gt;
max() 取最大步长（如 32），并转换为整数 gs。&lt;br&gt;
作用：gs 表示特征图的最小网格尺寸（grid size），用于后续调整图像尺寸对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nl = model.model[-1].nl&lt;/code&gt;&lt;br&gt;
model.model[-1] 是模型的最后一层（检测头，如 Detect 层）。&lt;br&gt;
nl 是检测头的层数（YOLOv5 默认为 3，对应 3 种尺度的检测输出）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgsz, imgsz_test = [check_img_size(x, gs) for x in opt.img_size]&lt;/code&gt;&lt;br&gt;
opt.img_size 是用户设置的训练和测试图像尺寸（如 [640, 640]）。&lt;br&gt;
check_img_size(x, gs) 是一个函数，确保图像尺寸 x 是 gs 的整数倍（避免特征图尺寸出现小数）&lt;br&gt;
输出：&lt;br&gt;
imgsz：调整后的训练图像尺寸。&lt;br&gt;
imgsz_test：调整后的测试图像尺寸。&lt;br&gt;
假设 gs=32，用户设置 img_size=640：&lt;br&gt;
检查 640 % 32 == 0（满足条件，直接返回 640）。&lt;br&gt;
如果用户设置 img_size=641，则自动向下舍入到最近的合法值 640。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dp-model-数据并行data-parallelism&#34;&gt;DP model 数据并行（Data Parallelism）&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743742724927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
cuda：布尔值，表示是否启用 CUDA（即是否使用 GPU）。&lt;br&gt;
rank == -1：rank 是分布式训练的进程编号，-1 表示当前是非分布式训练（单机多 GPU）。&lt;br&gt;
torch.cuda.device_count() &amp;gt; 1：检测当前系统中可用的 GPU 数量是否大于 1。&lt;br&gt;
条件满足时：执行 DataParallel 包装，启用多 GPU 数据并行。&lt;/p&gt;
&lt;h1 id=&#34;syncbatchnorm-同步批归一化&#34;&gt;SyncBatchNorm 同步批归一化&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743743552701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
opt.sync_bn：布尔值，表示用户是否通过命令行参数 --sync-bn 显式启用了同步批归一化。&lt;br&gt;
cuda：布尔值，表示是否使用 GPU 训练。&lt;br&gt;
rank != -1：rank 是分布式训练的进程编号，-1 表示单机单 GPU 训练，非 -1 表示当前是分布式训练（如多 GPU 或多节点）&lt;/p&gt;
&lt;h1 id=&#34;ema-创建指数移动平均&#34;&gt;EMA 创建指数移动平均&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ema = ModelEMA(model) if rank in [-1, 0] else None&lt;/code&gt;&lt;br&gt;
ModelEMA(model):这是一个封装类，用于计算模型的指数移动平均（EMA）。&lt;br&gt;
EMA 是一种平滑模型参数的技术，可以减少训练过程中的波动，提升模型的泛化能力。&lt;br&gt;
它会维护一个影子模型（shadow model），在每次参数更新时，按一定衰减率（如 0.999）更新影子模型的参数。&lt;br&gt;
rank in [-1, 0]:rank 表示当前进程的编号，用于分布式训练（如 torch.distributed 或 multiprocessing）。&lt;br&gt;
rank = -1：单机单卡（非分布式训练）。&lt;br&gt;
rank = 0：分布式训练的主进程（负责日志、保存模型等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;trainloader-创建数据加载器&#34;&gt;Trainloader 创建数据加载器&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743744086944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
train_path：训练数据路径（如 data.yaml 中定义的路径）。&lt;br&gt;
imgsz：输入图像的尺寸（如 640）。&lt;br&gt;
batch_size：每个批次的样本数。&lt;br&gt;
gs：模型步长（grid size），用于确保图像尺寸能被 gs 整除。&lt;br&gt;
opt：命令行参数对象（包含超参数配置）。&lt;br&gt;
hyp：超参数字典（如学习率、数据增强参数等）。&lt;br&gt;
augment=True：启用数据增强（如翻转、缩放等）。&lt;br&gt;
cache=opt.cache_images：是否缓存图像到内存（加速后续训练）。&lt;br&gt;
rect=opt.rect：是否使用矩形训练（减少填充，提升效率）。&lt;br&gt;
rank：当前进程编号（分布式训练时使用）。&lt;br&gt;
world_size：总进程数（分布式训练时使用）。&lt;br&gt;
workers：数据加载的子进程数。&lt;br&gt;
image_weights：是否按样本权重采样（解决类别不平衡）。&lt;br&gt;
quad：是否使用四合一拼接数据增强（Mosaic 增强的变种）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mlc = np.concatenate(dataset.labels, 0)[:, 0].max()&lt;/code&gt;从数据集的标签中提取所有类别编号，并计算最大值 mlc（Max Label Class）。&lt;br&gt;
dataset.labels：数据集中所有图像的标签列表（每个标签的格式为 [class_id, x_center, y_center, width, height]）。&lt;br&gt;
np.concatenate(dataset.labels, 0)：将所有标签拼接成一个二维数组。&lt;br&gt;
[:, 0]：提取所有标签的类别编号（第 0 列）。&lt;br&gt;
.max()：计算类别编号的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;process-0&#34;&gt;process 0&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743746418878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plot_labels(labels, save_dir, loggers)&lt;/code&gt; 生成 labels.jpg 文件，显示类别频率和框的宽高比。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check_anchors(dataset, model=model, thr=hyp[&#39;anchor_t&#39;], imgsz=imgsz)&lt;/code&gt;&lt;br&gt;
根据训练数据集的标签，自动优化模型的锚框尺寸。&lt;br&gt;
hyp[&#39;anchor_t&#39;]：锚框匹配阈值（超参数，默认 4.0）。&lt;br&gt;
imgsz：输入图像尺寸。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;model-parameter&#34;&gt;model parameter&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743748552045.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hyp[&#39;cls&#39;] *= nc / 80. &lt;/code&gt;根据实际类别数 nc 调整分类损失权重 hyp[&#39;cls&#39;]（默认基于 COCO 数据集的 80 类）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hyp[&#39;obj&#39;] *= imgsz ** 2 / 640. ** 2 * 3. / nl&lt;/code&gt;根据输入图像尺寸 (imgsz) 和输出层数 (nl) 调整目标存在损失权重 hyp[&#39;obj&#39;]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;start-train&#34;&gt;start train&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743748923988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t0 = time.time()&lt;/code&gt; 记录训练开始的时间戳，用于后续计算总训练耗时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nw = max(round(hyp[&#39;warmup_epochs&#39;] * nb), 1000)&lt;/code&gt;确定学习率热身（Warmup）阶段的迭代次数。&lt;br&gt;
hyp[&#39;warmup_epochs&#39;]：热身轮次数（默认 3 轮）。&lt;br&gt;
nb：每个 epoch 的批次数量（len(dataloader)）。&lt;br&gt;
max(..., 1000)：至少热身 1000 次迭代（避免小数据集热身不足）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maps = np.zeros(nc)&lt;/code&gt;存储每个类别的 mAP（初始为 0）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;results = (0, 0, 0, 0, 0, 0, 0)&lt;/code&gt;&lt;br&gt;
初始化评估结果元组，包含：&lt;br&gt;
P：精确率（Precision）&lt;br&gt;
R：召回率（Recall）&lt;br&gt;
mAP@.5：IoU 阈值为 0.5 的 mAP&lt;br&gt;
mAP@.5-.95：IoU 阈值从 0.5 到 0.95 的平均 mAP&lt;br&gt;
val_loss：验证损失（边界框、目标存在、分类损失）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scheduler.last_epoch = start_epoch - 1&lt;/code&gt;设置学习率调度器的起始轮次,last_epoch 必须比当前轮次小 1，否则调度器会跳过第一轮调整。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler = amp.GradScaler(enabled=cuda)&lt;/code&gt; 启用混合精度训练,enabled=cuda：仅在 GPU 训练时启用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;update-image-weights-optional&#34;&gt;Update image weights (optional)&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743750030157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;mean-losses&#34;&gt;mean losses&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743750197725.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mloss = torch.zeros(4, device=device)&lt;/code&gt;初始化一个长度为 4 的张量，用于累积当前 epoch 的四种损失均值：&lt;br&gt;
mloss[0]：边界框损失（box_loss）&lt;br&gt;
mloss[1]：目标存在损失（obj_loss）&lt;br&gt;
mloss[2]：分类损失（cls_loss）&lt;br&gt;
mloss[3]：总损失（total_loss）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pbar = enumerate(dataloader)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info((&#39;\n&#39; + &#39;%10s&#39; * 8) % (&#39;Epoch&#39;, &#39;gpu_mem&#39;, &#39;box&#39;, &#39;obj&#39;, &#39;cls&#39;, ``&#39;total&#39;, &#39;targets&#39;, &#39;img_size&#39;))&lt;/code&gt;&lt;br&gt;
日志输出示例：&lt;br&gt;
Epoch   gpu_mem       box       obj      cls    total  targets  img_size&lt;br&gt;
gpu_mem：GPU 显存占用（GB）&lt;br&gt;
box/obj/cls/total：各项损失值&lt;br&gt;
targets：当前批次的目标数量&lt;br&gt;
img_size：图像尺寸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pbar = tqdm(pbar, total=nb)&lt;/code&gt;&lt;br&gt;
仅在主进程（单卡或 rank=0）显示进度条，避免多进程日志混乱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for i, (imgs, targets, paths, _) in pbar:&lt;/code&gt;&lt;br&gt;
imgs：批次的输入图像（形状为 [batch_size, 3, H, W]）&lt;br&gt;
targets：标注信息（形状为 [num_targets, 6]，每行格式为 [batch_index, class_id, x, y, w, h]）&lt;br&gt;
paths：图像文件路径（用于调试）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ni = i + nb * epoch&lt;/code&gt;累计迭代次数 ni：用于学习率热身和日志记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgs = imgs.to(device, non_blocking=True).float() / 255.0 &lt;/code&gt;&lt;br&gt;
.to(device)：将数据转移到 GPU（若 cuda=True）。&lt;br&gt;
non_blocking=True：异步传输，提升数据加载效率。&lt;br&gt;
/ 255.0：将像素值从 [0, 255] 归一化到 [0.0, 1.0]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;warm-up&#34;&gt;Warm up&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743751020247.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;accumulate = max(1, np.interp(ni, xi, [1, nbs / total_batch_size]).round())&lt;/code&gt;nbs：名义批次大小（nominal batch size，如 64）。&lt;br&gt;
total_batch_size：实际批次大小（单卡 batch_size × 卡数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;multi-scale&#34;&gt;Multi scale&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743753618364.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;forward-backward-optimize&#34;&gt;Forward Backward optimize&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743753942871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;with amp.autocast(enabled=cuda):&lt;/code&gt;启用自动混合精度（Automatic Mixed Precision, AMP）训练（如果CUDA可用），以减少显存占用并加速计算。amp.autocast：自动将部分操作转换为低精度（FP16），同时保持关键部分的精度（FP32）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pred = model(imgs)&lt;/code&gt;将输入图像 imgs 输入模型，得到预测结果 pred。&lt;br&gt;
model(imgs)：调用模型的前向传播方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loss, loss_items = compute_loss(pred, targets.to(device), model)&lt;/code&gt;计算损失函数，返回总损失 loss 和各部分损失项 loss_items。&lt;br&gt;
compute_loss：YOLOv5的损失函数，包括分类损失、边界框损失和置信度损失。&lt;br&gt;
targets.to(device)：将标注数据（目标）移动到与模型相同的设备（如GPU）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loss *= opt.world_size&lt;/code&gt;如果使用分布式训练（DDP模式），将损失乘以 world_size（GPU数量），以便后续梯度平均。&lt;br&gt;
rank：当前进程的排名（-1表示单机训练）。&lt;br&gt;
opt.world_size：参与训练的GPU总数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler.scale(loss).backward()&lt;/code&gt;使用梯度缩放（Gradient Scaling）执行反向传播。&lt;br&gt;
scaler.scale(loss)：在混合精度训练中，缩放损失值以避免梯度下溢。&lt;br&gt;
.backward()：计算梯度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if ni % accumulate == 0:&lt;/code&gt;每隔 accumulate 步（梯度累积步数）执行一次参数更新。&lt;br&gt;
ni：当前迭代次数。&lt;br&gt;
accumulate：梯度累积的步数（模拟更大的batch size）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler.step(optimizer)&lt;/code&gt;更新模型参数（优化器步进）。&lt;br&gt;
scaler.step：在混合精度训练中，先反缩放梯度，再调用 optimizer.step()。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scaler.update()&lt;/code&gt;调整梯度缩放因子（根据梯度动态调整缩放比例）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optimizer.zero_grad()&lt;/code&gt;清空优化器的梯度缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ema.update(model)&lt;/code&gt;如果启用指数移动平均（EMA），更新EMA模型的参数。&lt;br&gt;
ema.update(model)：将当前模型的参数按一定权重（动量）更新到EMA模型中，用于提升模型泛化性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;print-plot&#34;&gt;Print plot&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743754685903.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mloss = (mloss * i + loss_items) / (i + 1) &lt;/code&gt;计算并更新平均损失（mloss）。&lt;br&gt;
mloss：历史平均损失的滑动平均值。&lt;br&gt;
loss_items：当前批次的各项损失值（分类、边界框、置信度等）。&lt;br&gt;
i：当前批次索引（用于滑动平均计算）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem = &#39;%.3gG&#39; % (torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0)&lt;/code&gt;获取当前GPU显存占用（单位：GB）。&lt;br&gt;
torch.cuda.memory_reserved()：返回已分配的显存总量。&lt;br&gt;
1E9：转换为GB单位。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s = (&#39;%10s&#39; * 2 + &#39;%10.4g&#39; * 6) % (&#39;%g/%g&#39; % (epoch, epochs - 1), mem, *mloss, targets.shape[0], imgs.shape[-1])&lt;/code&gt;格式化训练日志字符串，包括：&lt;br&gt;
epoch/epochs-1：当前轮次/总轮次（如 1/300）。&lt;br&gt;
mem：显存占用。&lt;br&gt;
*mloss：展开平均损失值（分类、边界框、置信度等）。&lt;br&gt;
targets.shape[0]：当前批次的标注目标数量。&lt;br&gt;
imgs.shape[-1]：输入图像的尺寸（如 640）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pbar.set_description(s)&lt;/code&gt;更新进度条（tqdm）的显示信息，实时展示训练状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread(target=plot_images, args=(imgs, targets, paths, f), daemon=True).start()&lt;/code&gt;启动一个后台线程（Thread）调用 plot_images 函数，绘制当前批次的图像和标注框。&lt;br&gt;
imgs：输入图像张量。&lt;br&gt;
targets：标注数据（类别、边界框）。&lt;br&gt;
paths：图像文件路径（用于显示文件名）。&lt;br&gt;
daemon=True：线程随主进程退出而终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;模型评估-map&#34;&gt;模型评估 MAP&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743755712304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ema.update_attr(model, include=[&#39;yaml&#39;, &#39;nc&#39;, &#39;hyp&#39;, &#39;gr&#39;, &#39;names&#39;, &#39;stride&#39;, &#39;class_weights&#39;])&lt;/code&gt;&lt;br&gt;
如果启用了指数移动平均（EMA），则更新 EMA 模型的属性（如配置文件、类别数、超参数等），确保 EMA 模型与原始模型同步关键参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;final_epoch = epoch + 1 == epochs&lt;/code&gt;判断当前 epoch 是否是最后一个 epoch（epoch + 1 等于总 epoch 数 epochs）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if not opt.notest or final_epoch: &lt;/code&gt;如果未设置 --notest 参数（即需要测试）或当前是最终 epoch，则执行测试逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;results, maps, times = test.test&lt;/code&gt;调用 test.py 中的 test() 函数计算 mAP，传入以下参数：&lt;br&gt;
opt.data：数据集配置文件路径（如 data/coco.yaml）。&lt;br&gt;
batch_size：测试时的批次大小。&lt;br&gt;
imgsz：测试图像尺寸。&lt;br&gt;
model：使用 EMA 模型（如果启用）进行推理。&lt;br&gt;
single_cls：是否单类别检测（由 --single-cls 参数控制）。&lt;br&gt;
dataloader：测试数据加载器。&lt;br&gt;
save_dir：结果保存目录。&lt;br&gt;
plots：仅在最终 epoch 时生成评估图表（如 PR 曲线、混淆矩阵等）。&lt;br&gt;
log_imgs：如果启用 WandB 日志，记录测试图像数量（由 --log-imgs 控制）。&lt;br&gt;
输出结果：&lt;br&gt;
results：包含精度（precision）、召回率（recall）、mAP@0.5、mAP@0.5:0.95 等指标。&lt;br&gt;
maps：各类别的 mAP 值。&lt;br&gt;
times：推理耗时统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;writelogupdate-best-map&#34;&gt;Write/Log/Update best mAP&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743756299799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;with open(results_file, &#39;a&#39;) as f:&lt;/code&gt;results_file：存储评估结果的文本文件路径（如 runs/train/exp/results.txt）。&lt;br&gt;
&#39;a&#39; 模式：以追加（append）方式打开文件，保留历史记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f.write(s + &#39;%10.4g&#39; * 7 % results + &#39;\n&#39;)  # P, R, mAP@.5, mAP@.5-.95,&lt;/code&gt; &lt;code&gt;val_loss(box, obj, cls)&lt;/code&gt;&lt;br&gt;
&#39;%10.4g&#39; * 7 % results：将 results 中的 7 个数值格式化为固定宽度（10 字符）、4 位有效数字的浮点数。通常对应：&lt;br&gt;
Precision (P)&lt;br&gt;
Recall (R)&lt;br&gt;
mAP@0.5&lt;br&gt;
mAP@0.5:0.95&lt;br&gt;
验证损失（box, obj, cls）&lt;br&gt;
&#39;\n&#39;：换行符，确保每次写入的结果单独成行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if len(opt.name) and opt.bucket:&lt;/code&gt;opt.name：实验名称（非空时触发上传）。&lt;br&gt;
opt.bucket：GCS 存储桶名称（如 my-bucket）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.system(&#39;gsutil cp %s gs://%s/results/results%s.txt&#39; % (results_file, opt.bucket, opt.name))&lt;/code&gt;使用 gsutil cp 命令将本地文件 results_file 复制到 GCS 路径 gs://{bucket}/results/results{name}.txt。&lt;br&gt;
例如：若 opt.name=&#39;exp1&#39; 且 opt.bucket=&#39;my-bucket&#39;，文件会被上传到 gs://my-bucket/results/results_exp1.txt。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags =&lt;/code&gt;&lt;br&gt;
训练损失：&lt;br&gt;
train/box_loss（边界框回归损失）、&lt;br&gt;
train/obj_loss（目标置信度损失）、&lt;br&gt;
train/cls_loss（分类损失）。&lt;br&gt;
评估指标：&lt;br&gt;
metrics/precision（精度）&lt;br&gt;
metrics/recall（召回率）&lt;br&gt;
metrics/mAP_0.5（mAP@0.5）&lt;br&gt;
metrics/mAP_0.5:0.95（mAP@0.5:0.95）。&lt;br&gt;
验证损失：&lt;br&gt;
val/box_loss&lt;br&gt;
val/obj_loss&lt;br&gt;
val/cls_loss（与训练损失对应，但基于验证集计算）。&lt;br&gt;
学习率：&lt;br&gt;
x/lr0、x/lr1、x/lr2 分别对应优化器中不同参数组的学习率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for x, tag in zip(list(mloss[:-1]) + list(results) + lr, tags):&lt;/code&gt;&lt;br&gt;
mloss[:-1]：训练损失的均值（排除可能存在的额外统计项）。&lt;br&gt;
results：评估指标（如 precision、recall、mAP 等，来自 test.test() 的返回值）。&lt;br&gt;
lr：学习率列表（对应不同参数组）。&lt;br&gt;
通过 zip() 将数值 (x) 和标签 (tag) 一一配对。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tb_writer.add_scalar(tag, x, epoch)  # tensorboard&lt;/code&gt;将数值 x 记录到 TensorBoard，标签为 tag，横轴为 epoch。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fi = fitness(np.array(results).reshape(1, -1))&lt;/code&gt;&lt;br&gt;
results 是一个包含模型评估指标的列表（如精确度 P、召回率 R、mAP@0.5、mAP@0.5-0.95 等）。&lt;br&gt;
np.array(results).reshape(1, -1) 将 results 转换为一个 NumPy 数组，并调整形状为 (1, n)，其中 n 是原始 results 的长度。&lt;br&gt;
fitness() 是一个自定义函数，用于计算模型的适应度值。通常，适应度是这些指标的加权组合（如 0.1&lt;em&gt;P + 0.9&lt;/em&gt;R 或其他权重配置），用于综合评估模型性能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if fi &amp;gt; best_fitness:&lt;/code&gt;比较当前适应度 fi 和历史最佳适应度 best_fitness。&lt;br&gt;
如果当前适应度更高，说明模型性能有所提升。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;best_fitness = fi&lt;/code&gt;更新 best_fitness 为当前更高的适应度值 fi，用于后续比较和模型保存逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;save-model&#34;&gt;save model&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743758099246.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;save = (not opt.nosave) or (final_epoch and not opt.evolve)&lt;/code&gt;根据命令行参数 opt.nosave 和训练阶段（是否最后一轮 final_epoch 或是否在超参数进化模式 opt.evolve）判断是否需要保存模型。&lt;br&gt;
opt.evolve：是否处于超参数进化模式（一种自动化调参方法）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;with open(results_file, &#39;r&#39;) as f:&lt;/code&gt;读取训练结果文件&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743758433509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.save(ckpt, last)&lt;/code&gt;保存最后一次训练的模型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if best_fitness == fi:&lt;/code&gt;&lt;br&gt;
&lt;code&gt;torch.save(ckpt, best)&lt;/code&gt;条件 best_fitness == fi 表示当前模型的适应度（fi）达到了历史最佳（best_fitness）。如果当前适应度是历史最佳，额外保存为最佳模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;strip-optimizers-移除优化器&#34;&gt;Strip optimizers 移除优化器&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743759232020.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
检查当前进程：仅在主进程（rank 为 -1 或 0）执行操作。&lt;br&gt;
选择最终模型：优先使用性能最佳的模型（best.pt），若不存在则使用最后一次训练的模型（last.pt）&lt;br&gt;
移除优化器状态：对 last.pt 和 best.pt 文件调用 strip_optimizer()，以减小文件体积。&lt;br&gt;
上传模型到云存储：如果指定了 Google Cloud Storage 的存储桶（opt.bucket），将最终模型上传。&lt;/p&gt;
&lt;h1 id=&#34;plots&#34;&gt;Plots&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743759838825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;test-bestpt&#34;&gt;Test best.pt&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743759888366.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logger.info(&#39;%g epochs completed in %.3f hours.\n&#39; % (epoch - start_epoch + 1, (time.time() - t0) / 3600))&lt;/code&gt;&lt;br&gt;
记录训练完成的 epoch 数量和总耗时。&lt;br&gt;
epoch - start_epoch + 1：计算实际训练的 epoch 数量（从 start_epoch 到当前 epoch）。&lt;br&gt;
(time.time() - t0) / 3600：将训练时间（秒）转换为小时，保留 3 位小数。&lt;br&gt;
通过 logger.info 输出日志，例如：&amp;quot;10 epochs completed in 2.345 hours.&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dist.destroy_process_group()&lt;/code&gt;&lt;br&gt;
在分布式训练（多 GPU/多节点训练）结束时，清理并释放进程组资源。&lt;br&gt;
如果训练时使用了 PyTorch 的分布式训练（如 torch.distributed），需要在训练结束后调用此函数，以避免资源泄漏或进程残留。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.cuda.empty_cache()&lt;/code&gt;&lt;br&gt;
释放 PyTorch 在 CUDA 设备（GPU）上未使用的缓存内存。&lt;br&gt;
在训练或推理过程中，PyTorch 会缓存一部分 GPU 内存以加速后续操作（如张量分配、计算等）。&lt;br&gt;
调用此函数会强制释放这些缓存，但不会影响已分配给张量的显存。&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计train.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji-yolopy/"" data-c="
          &lt;h1 id=&#34;parser&#34;&gt;parser&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743327817787.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;yolov5syaml&#34;&gt;yolov5s.yaml&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743328013437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743328052860.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743328086291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nc: 80  # number of classes&lt;/li&gt;
&lt;li&gt;depth_multiple: 0.33  # model depth multiple 模型深度倍数 和number有关，要乘&lt;/li&gt;
&lt;li&gt;width_multiple: 0.50  # layer channel multiple 层级通道倍数 和args有关，要乘&lt;/li&gt;
&lt;li&gt;yolov5s.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332256199.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;yolov5m.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332309256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;yolov5l.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332326243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;yolov5x.yaml&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743332345639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
yolov5n.yaml、yolov5l.yaml、yolov5m.yaml、yolov5s.yaml、yolov5x.yaml只有这两个倍数变化，模型越复杂，倍数越大。&lt;/li&gt;
&lt;li&gt;[from, number, module, args]&lt;/li&gt;
&lt;li&gt;[-1, 1, Focus, [64, 3]&lt;br&gt;
from=-1:从上一层过来的&lt;/li&gt;
&lt;li&gt;[-1, 10], 1, Concat, [1]&lt;br&gt;
from=[-1,10]:从22层和10层过来&lt;/li&gt;
&lt;li&gt;[-1, 3, C3, [128]]&lt;br&gt;
number=3,第2层有3个C3模块&lt;/li&gt;
&lt;li&gt;module:&lt;br&gt;
conv:卷积层&lt;br&gt;
C3：&lt;br&gt;
SPP:&lt;br&gt;
nn.Upsample:&lt;br&gt;
Concat:&lt;br&gt;
Detect:&lt;/li&gt;
&lt;li&gt;args:给module传的参数&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743331344943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
0-P1/2：第一层，P1，640x640输入的RGB图像-》320x320输出&lt;br&gt;
1-P2/4：第二层，P2，640x640输入的RGB图像-》160x160输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;流程图fpn-pan&#34;&gt;流程图（FPN、PAN)&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743342494810.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;model&#34;&gt;Model&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743417145301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
cfg:配置文件&lt;br&gt;
ch：channels，RGB三通道&lt;br&gt;
nc：类别数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;self.yaml.get(&#39;ch&#39;, ch)&lt;/code&gt;   优先使用yaml配置，否则使用默认值ch，体现配置优先级。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m = self.model[-1]&lt;/code&gt;   获取模型最后一层，预期为Detect层。YOLOv5 的检测头。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if isinstance(m, Detect):&lt;/code&gt;  确认最后一层是否为Detect类的实例，确保后续操作仅对检测头执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; s = 256  # 2x min stride&lt;/code&gt; 设定基准输入尺寸 256x256（通常为最小下采样步长 stride 的 2 倍，用于计算特征图缩放比例）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m.stride&lt;/code&gt; 通过前向传播一个 1xchx256x256 的零张量，获取各检测层的输出特征图尺寸。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m.anchors /= m.stride.view(-1, 1, 1)&lt;/code&gt; 将锚框尺寸归一化到特征图尺度（除以对应层的 stride）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743419153523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialize_weights(self)&lt;/code&gt;初始化模型所有层的权重参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.info()&lt;/code&gt; 打印模型的结构摘要信息（如层数、参数数量、梯度占比等）。&lt;br&gt;
输出内容：&lt;br&gt;
各层的名称、类型、输入/输出维度。&lt;br&gt;
总参数量（可训练/不可训练）。&lt;br&gt;
浮点运算量（FLOPs）估算（如果实现）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger.info(&#39;&#39;)&lt;/code&gt; 输出一个空行到日志，用于分隔模型初始化日志与其他后续日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;前向传播&#34;&gt;前向传播&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743420773667.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743421285880.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
x:输入图像张量&lt;br&gt;
augment:是否启用数据增强（多尺度+翻转）&lt;br&gt;
profile:是否启用性能分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;forward_once:单次前向传播&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y, dt = [], []  # outputs&lt;/code&gt;&lt;br&gt;
y:存储每一层的输出结果。&lt;br&gt;
dt: 在性能分析模式下（profile=True），记录每一层的计算耗时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for m in self.model:&lt;/code&gt; 遍历模型的所有层&lt;/li&gt;
&lt;li&gt;m.f:表示当前层 m 的输入来源（默认为 -1，即来自前一层的输出）。&lt;br&gt;
如果 m.f 是整数（如 3），直接从 y[3] 获取输入（跳层连接）。&lt;br&gt;
如果 m.f 是列表（如 [2, 4, -1]），拼接多个层的输出作为输入（多分支结构）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;fuse&#34;&gt;fuse&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743422569569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
融合卷积层（Conv2d）和批归一化层（BatchNorm2d），目的是优化模型的计算效率&lt;br&gt;
遍历模型的所有模块：for m in self.model.modules() 会遍历模型中的每一层。&lt;br&gt;
检查模块类型：if type(m) is Conv and hasattr(m, &#39;bn&#39;) 判断当前模块是否是 Conv 类型（自定义的卷积层类），并且是否包含 bn（批归一化层）属性。&lt;br&gt;
融合卷积和批归一化：调用 fuse_conv_and_bn(m.conv, m.bn) 将卷积层和批归一化层的参数合并为一个新的卷积层，并更新 m.conv。&lt;br&gt;
移除批归一化层：delattr(m, &#39;bn&#39;) 删除原来的批归一化层。&lt;br&gt;
更新前向传播方法：m.forward = m.fuseforward 将前向传播方法替换为融合后的版本（&lt;br&gt;
fuseforward是专门为融合后的层设计的方法）。&lt;br&gt;
打印模型信息：self.info() 输出融合后的模型结构信息。&lt;/p&gt;
&lt;h1 id=&#34;nmsnon-maximum-suppression非极大值抑制&#34;&gt;NMS(Non-Maximum Suppression，非极大值抑制)&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743423006177.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;mode 参数：&lt;br&gt;
mode=True：表示需要添加 NMS 模块。&lt;br&gt;
mode=False：表示需要移除 NMS 模块。&lt;/li&gt;
&lt;li&gt;present 变量：&lt;br&gt;
检查模型的最后一层是否是 NMS 类型（type(self.model[-1]) is NMS）。&lt;br&gt;
如果最后一层已经是 NMS，present 为 True；否则为 False。&lt;/li&gt;
&lt;li&gt;添加 NMS 模块（if mode and not present）：&lt;br&gt;
如果 mode=True 且当前模型没有 NMS 模块（not present），则执行以下操作：&lt;br&gt;
创建一个新的 NMS() 模块实例 m。&lt;br&gt;
设置 m.f = -1（通常表示该模块的来源层，-1 可能表示“无”或“自动”）。&lt;br&gt;
设置 m.i 为当前最后一层的索引 +1（确保新模块的索引正确）。&lt;br&gt;
使用 add_module 方法将 NMS 模块添加到模型的末尾。&lt;br&gt;
调用 self.eval() 将模型切换到推理模式（因为 NMS 通常在推理时使用）。&lt;/li&gt;
&lt;li&gt;移除 NMS 模块（elif not mode and present）：&lt;br&gt;
如果 mode=False 且当前模型包含 NMS 模块（present），则执行以下操作：&lt;br&gt;
直接通过切片 self.model[:-1] 移除最后一层（即 NMS 模块）。&lt;/li&gt;
&lt;li&gt;训练时：通常不需要 NMS，可以调用 model.nms(False) 移除 NMS 模块。&lt;/li&gt;
&lt;li&gt;推理时：需要 NMS 过滤冗余检测框，可以调用 model.nms(True) 添加 NMS 模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;info打印&#34;&gt;info打印&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;def info(self, verbose=False, img_size=640):  model_info(self, verbose, img_size)&lt;/code&gt;&lt;br&gt;
self: 表示该方法属于某个类（通常是YOLOv5的模型类）。&lt;br&gt;
verbose=False: 一个布尔参数，控制是否打印详细信息。默认为 False，即只打印基本信息。&lt;br&gt;
img_size=640: 输入图像的尺寸，默认为 640（YOLOv5的默认输入分辨率）。&lt;br&gt;
调用 model_info(self, verbose, img_size) 函数，将当前模型实例、verbose 标志和 img_size 传递给它。&lt;br&gt;
model_info 函数的作用是分析模型的结构和参数，并打印相关信息，例如：&lt;br&gt;
模型的层数、参数数量、计算量（FLOPs）。&lt;br&gt;
各层的详细信息（如果 verbose=True）。&lt;br&gt;
输入尺寸对模型的影响。&lt;/li&gt;
&lt;/ul&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计yolo.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ji-yu-yolov5deepsortpyqt-de-dan-mu-biao-gen-zong-qi-she-ji/"" data-c="
          &lt;h1 id=&#34;opt-parserparse_args&#34;&gt;opt = parser.parse_args()&lt;/h1&gt;
&lt;p&gt;---解析命令行参数的代码&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743255463863.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
---运行结果：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743255507270.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
---解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parser = argparse.ArgumentParser():parser是通过argparse.ArgumentParser()创建的一个命令行参数解析器对象。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.parse_args()：ArgumentParser()解析命令行传入的参数，将命令行输入的参数转换为一个namespace对象。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opt = parser.parse_args():将解析后的参数存储在变量opt中，可以通过print(opt.weights)等访问。如果没有传递函数，parser.add_argument(&#39;--demo&#39;, action=&#39;store_true&#39;, help=&#39;&#39;),运行print(opt.demo)结果为False。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parser.add_argument(&#39;--img-size&#39;, type=int, default=640, help=&#39;inference size (pixels)&#39;)命令行参数为img-size，但是运行会被转化为img_size，访问时要用print(opt.img_size)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;torchno_grad&#34;&gt;torch.no_grad()&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743257318494.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;with torch.no_grad():使用pytorch的no_grad上下文管理器，禁用梯度计算，减少内存占用。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;webcam&#34;&gt;webcam&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;webcam = source.isnumeric() or source.endswith(&#39;.txt&#39;) or source.lower().startswith((&#39;rtsp://&#39;, &#39;rtmp://&#39;, &#39;http://&#39;))&lt;/code&gt;&lt;br&gt;
------通过逻辑判断确定输入源 source 是否为以下类型之一：&lt;br&gt;
------摄像头设备：source.isnumeric() 为 True 表示摄像头索引（如 0 表示默认摄像头）。&lt;br&gt;
------视频文件列表：source.endswith(&#39;.txt&#39;) 为 True 表示输入是一个文本文件，内含多个视频/图像路径（每行一个路径）。&lt;br&gt;
------网络视频流：source.lower().startswith(...) 检查是否以流媒体协议（如 rtsp://、rtmp://、http://）开头。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.isnumeric判断source是否由数字构成，返回布尔值True或者False。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;save_dir&#34;&gt;save_dir&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;save_dir = Path(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok)):生成一个自动递增的、唯一的保存目录路径。&lt;/code&gt;&lt;br&gt;
------Path(opt.project) / opt.name：将命令行参数 opt.project（主项目目录，如 runs/detect）和 opt.name（自定义实验名称，如 exp）拼接成路径（如 runs/detect/exp）。&lt;br&gt;
------increment_path，处理路径冲突。如果 runs/detect/exp 已存在，则自动重命名为 runs/detect/exp2、runs/detect/exp3 等（避免覆盖）。exist_ok=opt.exist_ok：若 opt.exist_ok 为 True，则允许目录已存在（不递增）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(save_dir / &#39;labels&#39; if save_txt else save_dir).mkdir(parents=True, exist_ok=True)&lt;/code&gt;&lt;br&gt;
------如果 save_txt 为 True：创建 save_dir/labels 子目录（用于保存检测结果的文本文件，如 YOLO 格式的 .txt 标注文件）。如果 save_txt 为 False：直接创建 save_dir 目录（仅保存图像/视频结果）。parents=True：自动创建父目录（如 runs/detect/exp 不存在时会一并创建）。&lt;br&gt;
exist_ok=True：目录已存在时不报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;device&#34;&gt;device&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;device = select_device(opt.device):根据用户输入的 opt.device 参数选择运行设备（CPU 或 GPU）。‘cpu&#39;：强制使用 CPU。  &#39;0&#39; 或 &#39;cuda:0&#39;：使用第一块 GPU。  &#39;&#39;（空字符串）：自动选择可用设备（优先 GPU）。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;half = device.type != &#39;cpu&#39;:half=True：仅在 GPU（CUDA）上启用 FP16，可加速推理并减少显存占用。half=False：在 CPU 上强制使用 FP32（单精度），因为 CPU 对 FP16 支持不佳。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;model&#34;&gt;model&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;model = attempt_load(weights, map_location=device)  # load FP16 model 加载模型权重文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imgsz = check_img_size(imgsz, s=model.stride.max()) #检查用户指定img_size是否满足模型要求，默认stride=32,imgsz为32的倍数，640或者672&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if half: model.half()  # to FP16 #根据device选择GPU可知half=True,加载FP16.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;classify&#34;&gt;classify&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;classify = False if classify: modelc = load_classifier(name=&#39;resnet101&#39;, n=2)  # initialize modelc.load_state_dict(torch.load(&#39;weights/resnet101.pt&#39;, map_location=device)[&#39;model&#39;]).to(device).eval()&lt;/code&gt;&lt;br&gt;
---设置一个布尔标志 classify，默认为 False，表示不启用分类功能。&lt;br&gt;
------若需启用分类（如同时执行检测和分类任务），需手动改为 True 或通过命令行参数控制。&lt;br&gt;
---检查是否启用分类功能。若为 True，则执行以下操作：&lt;br&gt;
------加载预训练的分类模型（如 ResNet101）。&lt;br&gt;
------将分类模型与检测模型结合使用（YOLOv5 默认仅做检测，分类是可选扩展功能）。&lt;br&gt;
---这段代码为 YOLOv5 提供了扩展能力，可在目标检测后对检测到的物体进行二次分类（例如检测车辆后进一步分类为“卡车”或“轿车”）。默认不启用，因为 YOLOv5 主要聚焦于检测任务，分类需额外数据和模型支持。&lt;br&gt;
---分类模型与检测模型的区别：&lt;br&gt;
------检测模型（YOLOv5）：输出边界框和类别（如“狗”）。&lt;br&gt;
------分类模型（ResNet）：对裁剪后的区域进行细粒度分类（如“哈士奇” vs “金毛”）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;是否为实时流&#34;&gt;是否为实时流&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743301191381.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
---vid_path：用于存储当前处理的 视频文件路径（如 data/video.mp4），初始化为 None 表示尚未加载任何视频。&lt;br&gt;
---vid_writer：用于存储 视频写入器对象（如 OpenCV 的 VideoWriter），初始化为 None 表示尚未创建写入器。&lt;br&gt;
---当输入源是视频文件或摄像头时，代码会动态更新这两个变量：&lt;br&gt;
------vid_path 记录当前视频路径（用于逻辑判断或调试信息）。&lt;br&gt;
------vid_writer 初始化视频写入器，用于将检测结果保存为新的视频文件。&lt;br&gt;
---if webcam: 判断输入源是否为实时流&lt;br&gt;
---view_img = True 若输入是实时流，强制开启实时显示（view_img 设为 True），便于用户观察摄像头或视频流的检测结果。&lt;br&gt;
---cudnn.benchmark = True 启用 CuDNN 的自动优化模式，加速固定尺寸图像的推理。&lt;br&gt;
适用于实时流场景（图像尺寸通常不变），通过自动选择最优卷积算法提升 GPU 计算效率。&lt;br&gt;
---dataset = LoadStreams(source, img_size=imgsz) 使用 LoadStreams 类加载实时流数据：&lt;br&gt;
------source：摄像头索引（如 0）或流地址（如 rtsp://example.com）。&lt;br&gt;
------img_size：图像缩放尺寸（如 640）。&lt;br&gt;
------LoadStreams 会以多线程方式持续读取帧，并返回迭代器（每项包含帧数组、原始帧、路径等）&lt;br&gt;
---dataset = LoadImages(source, img_size=imgsz)使用 LoadImages 类加载静态文件数据：&lt;br&gt;
------source：文件路径（如 data/image.jpg）或包含多个路径的文本文件。&lt;br&gt;
------img_size：图像缩放尺寸。&lt;br&gt;
------LoadImages 返回迭代器，逐个处理文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据加载器差异：&lt;/li&gt;
&lt;li&gt;LoadStreams：专为实时流设计，支持多线程读取，适合高帧率处理。&lt;/li&gt;
&lt;li&gt;LoadImages：针对文件处理，单线程顺序读取，适合批量处理图像/视频。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;name-colors&#34;&gt;name、colors&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;names = model.module.names if hasattr(model, &#39;module&#39;) else model.names&lt;/code&gt;&lt;br&gt;
names根据weights权重文件变。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colors = [[random.randint(0, 255) for _ in range(3)] for _ in names]&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743302176449.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
colors随机分配，从0到255&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;warmup&#34;&gt;warmup&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; t0 = time.time()&lt;/code&gt;&lt;br&gt;
记录当前时间戳 t0，通常用于后续计算总耗时（如预处理+推理+后处理的总时间）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = torch.zeros((1, 3, imgsz, imgsz), device=device)  # init img&lt;/code&gt;&lt;br&gt;
创建一个全零的张量作为虚拟输入图像。&lt;br&gt;
形状 (1, 3, imgsz, imgsz)：&lt;br&gt;
1：批大小（batch size为1）。&lt;br&gt;
3：通道数（RGB图像）。&lt;br&gt;
imgsz：图像的高度和宽度（必须是模型支持的输入尺寸，如640x640）。&lt;br&gt;
device=device：将张量放置在指定设备（如 cuda:0 或 cpu）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; _ = model(img.half() if half else img) if device.type != &#39;cpu&#39; else None  # run once&lt;/code&gt;&lt;br&gt;
执行一次虚拟推理（预热模型）。&lt;br&gt;
img.half() if half else img：&lt;br&gt;
如果 half=True（启用半精度FP16推理），将输入转换为 torch.float16；否则保持 torch.float32。&lt;br&gt;
if device.type != &#39;cpu&#39;：&lt;br&gt;
仅在GPU设备上执行预热（CPU无需预热，因为无CUDA初始化开销）。&lt;br&gt;
_ = ...：&lt;br&gt;
忽略输出结果（因为仅是预热，无需处理输出）。&lt;/li&gt;
&lt;li&gt;作用：&lt;br&gt;
1、避免首次推理延迟：GPU首次执行某些操作时（如CUDA内核加载）会有额外开销。预热后，后续推理速度更稳定。&lt;br&gt;
2、半精度（FP16）适配：&lt;br&gt;
如果启用 half 模式，确保模型和输入数据精度一致。&lt;br&gt;
3、设备兼容性：&lt;br&gt;
跳过CPU的预热（因其无显著初始化延迟）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dataset&#34;&gt;dataset&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743312246958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for path, img, im0s, vid_cap in dataset:&lt;/code&gt;&lt;br&gt;
从 dataset 中逐项读取数据，每次迭代返回：&lt;br&gt;
path：图像/视频文件的路径。&lt;br&gt;
img：预处理后的图像（NumPy数组，通常为缩放后的尺寸，如640x640）。&lt;br&gt;
im0s：原始图像（未缩放，用于后续可视化）。&lt;br&gt;
vid_cap：视频捕获对象（若输入是视频）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = torch.from_numpy(img).to(device)&lt;/code&gt;&lt;br&gt;
将NumPy数组 img 转为PyTorch张量Tensor，并移动到指定设备（如GPU或CPU）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315972669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315981240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315993501.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img = img.half() if half else img.float()  # uint8 to fp16/32&lt;/code&gt;&lt;br&gt;
根据 half 标志选择精度：&lt;br&gt;
half=True：转为半精度（torch.float16，适合GPU加速）。&lt;br&gt;
half=False：转为单精度（torch.float32，默认）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img /= 255.0  # 0 - 255 to 0.0 - 1.0&lt;/code&gt;&lt;br&gt;
将像素值从 [0, 255] 范围归一化到 [0.0, 1.0]，符合模型输入要求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;        if img.ndimension() == 3: img = img.unsqueeze(0)&lt;/code&gt;&lt;br&gt;
若输入张量是3维（[C, H, W]），则添加批次维度变为4维（[1, C, H, W]），因为模型预期输入为批处理形式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;时间戳&#34;&gt;时间戳&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t0 = time.time()&lt;/code&gt;&lt;br&gt;
Python 标准库 time 中的一个函数，返回当前时间的时间戳（以秒为单位，从 Unix 纪元（1970年1月1日）开始计算的浮点数）。t0 记录了代码执行到这一行时的时刻，后续可以通过 t1 = time.time() 计算时间差（t1 - t0），从而统计某段代码的运行时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t1 = time_synchronized()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t2 = time_synchronized()&lt;/code&gt;&lt;br&gt;
time.time() 是纯 CPU 时间，不处理 GPU 同步，因此在涉及 GPU 计算（如深度学习模型推理）时可能不够准确。time_synchronized()（自定义函数）通常会先同步 GPU 操作，适合需要精确测量 GPU 加速任务的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;pred&#34;&gt;pred&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pred = model(img, augment=opt.augment)[0]&lt;/code&gt;&lt;br&gt;
model：训练好的目标检测模型（如 YOLOv5）。&lt;br&gt;
img：输入的图像数据（通常是经过预处理的张量）。&lt;br&gt;
augment=opt.augment：是否启用测试时数据增强（Test-Time Augmentation, TTA），由配置参数 opt.augment 控制（例如翻转、缩放等增强操作）。模型可能返回多个输出（如检测结果、特征图等），这里通过 [0] 取第一个输出，即检测结果的预测张量（包含边界框、置信度、类别等信息）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;非极大值抑制nms&#34;&gt;非极大值抑制NMS&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pred = non_max_suppression(pred, opt.conf_thres, opt.iou_thres, classes=opt.classes, agnostic=opt.agnostic_nms)&lt;/code&gt;&lt;br&gt;
non_max_suppression：非极大值抑制（NMS），用于去除冗余的检测框。&lt;br&gt;
pred：模型输出的预测结果。&lt;br&gt;
opt.conf_thres：置信度阈值，低于此值的预测会被过滤。&lt;br&gt;
opt.iou_thres：交并比（IoU）阈值，用于判断框之间的重叠程度。&lt;br&gt;
classes=opt.classes：指定要保留的目标类别。&lt;br&gt;
agnostic=opt.agnostic_nms：是否进行类别无关的NMS（即跨类别抑制）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;应用分类器apply-classifier&#34;&gt;应用分类器Apply Classifier&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pred = apply_classifier(pred, modelc, img, im0s)&lt;/code&gt;&lt;br&gt;
apply_classifier：应用分类器，对检测结果进行进一步的类别细化或调整。&lt;br&gt;
pred：经过非极大值抑制（NMS）处理后的预测结果。&lt;br&gt;
modelc：分类器模型，用于对检测到的目标进行二次分类。&lt;br&gt;
img：输入图像的预处理形式（通常为归一化后的张量）。&lt;br&gt;
im0s：原始图像（未预处理的格式），可能用于可视化或辅助分类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;过程分类&#34;&gt;过程分类&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315025215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for i, det in enumerate(pred): &lt;/code&gt;遍历 pred（预测结果），i 是索引，det 是当前检测到的目标信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt; if webcam:&lt;/code&gt;判断输入是否为摄像头（webcam 模式），如果是，则处理多帧图像（batch_size &amp;gt;= 1）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p, s, im0, frame = ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;摄像头模式：&lt;br&gt;
path[i]：当前帧的路径。&lt;br&gt;
&#39;%g: &#39; % i：格式化字符串，标记当前帧序号。&lt;br&gt;
im0s[i].copy()：复制当前帧图像（避免修改原始数据）。&lt;br&gt;
dataset.count：帧计数器。&lt;/li&gt;
&lt;li&gt;非摄像头模式：&lt;br&gt;
path：单张图像或视频文件的路径。&lt;br&gt;
&#39;&#39;：空字符串（无帧标记）。&lt;br&gt;
im0s：原始图像数据。&lt;br&gt;
getattr(dataset, &#39;frame&#39;, 0)：获取 dataset 的 frame 属性（默认为 0）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;p-pathp&#34;&gt;p = Path(p)&lt;/h1&gt;
&lt;p&gt;使用 Python 的 pathlib.Path 将字符串路径 p 转换为 Path 对象，以便更方便地处理文件路径操作（如拼接、解析等）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1743315802639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;save_path = str(save_dir / p.name)  # img.jpg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;txt_path = str(save_dir / &#39;labels&#39; / p.stem) + (&#39;&#39; if dataset.mode == &#39;image&#39; else f&#39;_{frame}&#39;)  # img.txt&lt;/code&gt;&lt;br&gt;
save_path 是保存检测结果图片的路径（如 img.jpg）。&lt;br&gt;
txt_path 是保存检测标签文本的路径（如 img.txt），如果是图像模式（dataset.mode == &#39;image&#39;），文件名直接使用 p.stem；否则（如视频模式），会在文件名后追加帧号 _{frame}。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s += &#39;%gx%g &#39; % img.shape[2:]  # print string&lt;/code&gt;&lt;br&gt;
将图像的宽度和高度（img.shape[2:]）格式化为字符串（如 &amp;quot;640x480&amp;quot;），并追加到字符串 s 中。&lt;br&gt;
%g 是 Python 的格式化占位符，自动选择较短的浮点数或整数表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # normalization gain whwh&lt;/code&gt;&lt;br&gt;
将原始图像 im0 的形状（(H, W, C) 或 (H, W)）转换为 PyTorch 张量，并重新排列为 [W, H, W, H]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;缩放尺寸&#34;&gt;缩放尺寸&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if len(det):              # Rescale boxes from img_size to im0 size   det[:, :4] = scale_coords(img.shape[2:], det[:, :4], im0.shape).round()&lt;/code&gt;&lt;br&gt;
如果检测结果 det 非空（len(det) &amp;gt; 0），则执行以下操作：调用 scale_coords 函数，将边界框坐标从模型输入尺寸（img.shape[2:]，即 [height, width]）缩放到原始图像尺寸（im0.shape）&lt;br&gt;
.round() 对缩放后的坐标进行四舍五入取整，确保边界框坐标为整数像素值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;print&#34;&gt;print&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743316642245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
遍历检测结果 det 中的每个唯一类别索引 c。&lt;br&gt;
统计属于当前类别 c 的检测框数量 n。&lt;br&gt;
将类别名称（从 names 列表中获取）和对应的数量格式化为字符串（如 &amp;quot;3 cars, &amp;quot;），并追加到变量 s 中。&lt;br&gt;
最终 s 会包含类似 &amp;quot;3 cars, 2 persons, &amp;quot; 的统计信息。&lt;/p&gt;
&lt;h1 id=&#34;write-results&#34;&gt;write results&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1743317759145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
遍历检测结果：逆序处理检测结果 det，解包每个检测框的坐标 xyxy、置信度 conf 和类别 cls。&lt;br&gt;
坐标转换：将 xyxy（左上右下坐标）转换为 xywh（中心点坐标+宽高）并归一化（除以 gn）。&lt;br&gt;
格式组装：根据配置 opt.save_conf 决定是否在输出行中包含置信度 conf。&lt;br&gt;
写入文件：以追加模式打开文件，将数据格式化为空格分隔的字符串（如 &amp;quot;0 0.5 0.5 0.2 0.2 0.9&amp;quot;）并写入。&lt;br&gt;
条件判断：检查是否需要保存图像（save_img）或实时显示图像（view_img）。&lt;br&gt;
生成标签：组合类别名称（从 names 列表获取）和置信度（格式化为两位小数），例如 &amp;quot;car 0.95&amp;quot;。&lt;br&gt;
绘制检测框：调用 plot_one_box 函数，在原始图像 im0 上绘制矩形框：&lt;br&gt;
使用 xyxy 坐标指定框的位置。&lt;br&gt;
使用 colors[int(cls)] 根据类别索引选择颜色。&lt;br&gt;
设置框的线条粗细为 3 像素。&lt;/p&gt;
">基于Yolov5+Deepsort+Pyqt的单目标跟踪器设计detect.py：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/layout/"" data-c="
          &lt;h1 id=&#34;高速信号布线&#34;&gt;高速信号布线&lt;/h1&gt;
&lt;p&gt;1、走线长度，尽量短。&lt;br&gt;
2、避免打孔换层。&lt;br&gt;
3、高速信号的回流地要完整。&lt;br&gt;
4、要包地处理，减少干扰或被干扰。&lt;br&gt;
5、高速走线不能有锐角和直角，尽量弧度。&lt;br&gt;
6、阻抗匹配：&lt;br&gt;
------阻抗匹配就是指在信号传输中的源端、传输线、负载端之间的阻抗相等。阻抗匹配目的是为了防止信号反射，保证信号的完整性。如果阻抗不匹配，信号就会在源端和阻抗不匹配点之间来回反射，可能导致信号衰减、失真。&lt;br&gt;
7、阻抗匹配方法：&lt;br&gt;
------有串联电阻匹配或并联电阻匹配，可以放在源端或负载端，根据实际信号要求来选择电阻大小，一般是用于低频信号；&lt;br&gt;
------有阻抗匹配网络设计，如Π网络、LC网络等，一般是用于高速信号，比如WIFI模组的RF走线上的匹配网络（WIFI模组和天线之间）。&lt;br&gt;
8、EMC\EMI设计：&lt;br&gt;
A、关键的高速信号和时钟信号要进行包地，要有完整的回流路径；&lt;br&gt;
B、时钟信号上串的RC要放在源端，要包地良好及提供完整的回流路径；&lt;br&gt;
C、预留在接口座子上的走线小电容，要靠近端子放置。这个小电容方便调试，不同电容值，其谐振频率不一样，可滤除不同频率，解决辐射问题。也可以用小电容来解决ESD问题（ESD采用的电容容值，也是利用电容的谐振频率来计算的）。&lt;br&gt;
D、有飞线的接口座子，尽量放在板边，避免飞线跨过高速信号或时钟信号。&lt;br&gt;
E、DCDC要使得提供电流的两个回流路径尽量短。&lt;br&gt;
F、对于高速信号的传输线的阻抗要有明确的要求，比如HDMI走线100欧姆、USB走线90欧姆、RF走线50欧姆、MIPI走线100欧姆等。小系统DDR部分走线的单端阻抗50欧姆或差分阻抗100欧姆，但要参考原厂的Demo要求，有的并不是50欧姆或100欧姆。&lt;br&gt;
G、如有屏蔽罩的话，屏蔽罩与PCB板上的地铜皮接触要尽量多，且多打地过孔。&lt;/p&gt;
">Layout</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dian-li-dian-zi-ji-zhu/"" data-c="
          &lt;p&gt;1、电力二极管：&lt;br&gt;
静态特性：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740066190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态特性：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740108888.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主要类型：普通二极管、快恢复二极管、肖特基二极管&lt;br&gt;
2、压敏电阻&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740142505.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、共模电感&lt;br&gt;
也叫共模扼流圈，共模电感是一个以铁氧体为磁芯的共模干扰抑制器件，它由两个尺寸相同，匝数相同的线圈对称地绕制在同一个铁氧体环形磁芯上，形成一个四端器件，要对于共模信号呈现出大电感具有抑制作用，而对于差模信号呈现出很小的漏电感几乎不起作用。原理是流过共模电流时磁环中的磁通相互叠加，从而具有相当大的电感量，对共模电流起到抑制作用，而当两线圈流过差模电流时，磁环中的磁通相互抵消，几乎没有电感量，所以差模电流可以无衰减地通过。因此共模电感在平衡线路中能有效地抑制共模干扰信号，而对线路正常传输的差模信号无影响。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740185140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740192026.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4、滤波电路&lt;br&gt;
电容滤波&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740234802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图2(b)为电容滤波电路。由于电容 C1 对直流电相当于开路，这样整流电路输出的直流电压不能通过C1 到地，只有加到负载 RL 图为 RL 上。对于整流电路输出的交流成分，因 C1 容量较大，容抗较小，交流成分通过 C1 流到地端，而不能加到负载 RL。这样，通过电容 C1 的滤波， 从单向脉动性直流电中取出了所需要的直流电压 +U。滤波电容 C1 的容量越大，对交流成分的容抗越小，使残留在负载 RL 上的交流成分越小，滤波效果就越好。&lt;br&gt;
电感滤波&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740268142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于整流电路输出的交流成分，因 L1 电感量较大，感抗较大，对交流成分产生很大的阻碍作用，阻止了交流电通过 C1 流到加到负载 RL。这样，通过电感 L1 的滤波，从单向脉动性直流电中取出了所需要的直流电压 +U。滤波电感 L1 的电感量越大，对交流成分的感抗越大，使残留在负载 RL 上的交流成分越小，滤波效果就越好，但直流电阻也会增大。&lt;br&gt;
pi型RC滤波&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740300171.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
(1)这一电路的滤波原理是：从整流电路输出的电压首先经过 C1 的滤波，将大部分的交流成分滤除，然后再加到由 R1 和 C2 构成的滤波电路中。C2 的容抗与 R1 构成一个分压电路，因 C2 的容抗很小，所以对交流成分的分压衰减量很大，达到滤波目的。对于直流电而言，由于 C2 具有隔直作用，所以 R1 和 C2 分压电路对直流不存在分压衰减的作用，这样直流电压通过 R1 输出。&lt;br&gt;
(2)在 R1 大小不变时，加大 C2 的容量可以提高滤波效果，在 C2 容量大小不变时，加大 R1 的阻值可以提高滤波效果。但是，滤波电阻 R1 的阻值不能太大，因为流过负载的直流电流要流过 R1，在 R1 上会产生直流压降，使直流输出电压 Uo2 减小。R1 的阻值越大，或流过负载的电流越大时，在 R1 上的压降越大，使直流输出电压越低。&lt;br&gt;
(3)C1 是第一节滤波电容，加大容量可以提高滤波效果。但是 C1 太大后，在开机时对 C1 的充电时间很长，这一充电电流是流过整流二极管的，当充电电流太大、时间太长时，会损坏整流二极管。所以采用这种 π 型 RC 滤波电路可以使 C1 容量较小，通过合理设计 R1 和 C2 的值来进一步提高滤波效果。&lt;br&gt;
(4)这一滤波电路中共有 3 个直流电压输出端，分别输出 Uo1、Uo2 和 Uo3 三组直流电压。其中，Uo1 只经过电容 C1 滤波;Uo2 则经过了 C1、 R1 和 C2 电路的滤波，所以滤波效果更好，Uo2 中的交流成分更小;Uo3 则经过了 2 节滤波电路的滤波，滤波效果最好，所以 Uo3 中的交流成分最少。&lt;br&gt;
(5)3 个直流输出电压的大小是不同的。Uo1 电压最高，一般这一电压直接加到功率放大器电路，或加到需要直流工作电压最高、工作电流最大的电路中;Uo2 电压稍低，这是因为电阻 R1 对直流电压存在电压降;Uo3 电压最低，这一电压一般供给前级电路作为直流工作电压，因为前级电路的直流工作电压比较低，且要求直流工作电压中的交流成分少。&lt;br&gt;
pi型LC滤波电路&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742740337737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在图 5 的电路中，整流电路输出的单向脉动性直流电压先经电容 C1 滤波，去掉大部分交流成分，然后再加到 L1 和 C2 滤波电路中。&lt;br&gt;
对于交流成分而言，L1 对它的感抗很大，这样在 L1 上的交流电压降大，加到负载上的交流成分小。&lt;br&gt;
对直流电而言，由于 L1 不呈现感抗，相当于通路，同时滤波电感采用的线径较粗，直流电阻很小，这样对直流电压基本上没有电压降，所以直流输出电压比较高，这是采用电感滤波器的主要优点。&lt;/p&gt;
">电力电子技术</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/fan-ji-kai-guan-dian-yuan/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739261573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739266954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739272011.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739277085.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
保险丝：电流过大时烧坏，保护后级电路。&lt;br&gt;
压敏电阻：过压保护，电压过高时短路，烧坏保险丝，保护后级电路。&lt;br&gt;
NTC：负温度系数的热敏电阻，瞬间电流过大时，防止浪涌电流。&lt;br&gt;
共模电感：也叫共模扼流圈，共模电感是一个以铁氧体为磁芯的共模干扰抑制器件，它由两个尺寸相同，匝数相同的线圈对称地绕制在同一个铁氧体环形磁芯上，形成一个四端器件，要对于共模信号呈现出大电感具有抑制作用，而对于差模信号呈现出很小的漏电感几乎不起作用。原理是流过共模电流时磁环中的磁通相互叠加，从而具有相当大的电感量，对共模电流起到抑制作用，而当两线圈流过差模电流时，磁环中的磁通相互抵消，几乎没有电感量，所以差模电流可以无衰减地通过。因此共模电感在平衡线路中能有效地抑制共模干扰信号，而对线路正常传输的差模信号无影响。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739300591.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回路面积要尽可能小&lt;br&gt;
从理论上（即假设电容为纯电容）说，电容越大，阻抗越小，通过的频率也越高。 但实际上超过1μF 的电容大多为电解电容，有很大的电感成份，所以频率高后反而阻抗会增大。 有时会看到有一个电容量较大电解电容并联了一个小电容，这时大电容通低频，小电容通高频。 电容的作用就是通高阻低，通高频阻低频。 电容越小低频越容易通过，电容越大高频越容易通过&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739330738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
两个回路面积要小&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739353848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回路面积要小&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739378366.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
负载电阻：空载运行设备容易坏。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739404865.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4脚和6脚走线不能挨在一起，反馈信号属于敏感信号，驱动信号属于干扰信号。隔地。&lt;br&gt;
R26和R22靠近MOS管，不能把310V高电压带到U1.&lt;br&gt;
C18：给C18充电，SENSE检测电流。&lt;br&gt;
R22:当MOS管关断的时候,拉低栅极,避免误触发.&lt;br&gt;
R27:图中的 R27 是一个 1Ω、功率为 2W 的电阻，它主要起到电流采样的作用。在 MOS 开关电路工作时，负载电流会流经 R27，根据欧姆定律，R27 两端会产生与电流成正比的电压降。这个电压信号可以被 OCP 电路（过功率保护电路）检测到，当电流过大，即 R27 两端电压达到一定阈值时，OCP 电路会触发保护动作，关断 MOS 管，从而防止电路因过流而损坏 。&lt;br&gt;
OCP 电路即过流保护（Over - Current Protection）电路.&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739445525.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
D4、R15加速开关管关断。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739470736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Y电容：热地、冷地。&lt;br&gt;
Y电容和光耦靠近变压器（一上一下）&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739496647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当MOS管关断的时候，变压器1脚接到D3，流过电阻R5继续回到变压器。&lt;br&gt;
R5\D3\C3靠近变压器布局。&lt;br&gt;
R7\R3\R9R布局靠近310V高压。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739519526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单点接地：MOS管的HGND、Y电容的HGND、主芯片的地，分别接到整流桥后面大电容的地。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739546507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
● 电压采样：电阻 R25 和 R32 组成分压电路，对输出电压进行采样，将采样后的电压送入 TL431 的参考端。当输出电压变化时，采样电压也随之改变。&lt;br&gt;
● 基准比较与放大：TL431 是一个精密的可调基准源，内部会将采样电压与 2.5V 的基准电压进行比较。若采样电压偏离设定值，TL431 会调整其输出电流，从而改变通过光耦 PC1B 中发光二极管的电流。&lt;br&gt;
● 光耦隔离与反馈：光耦 PC1B 起到电气隔离作用，其内部发光二极管的发光强度随通过电流变化，进而控制光耦中光敏晶体管的导通程度。通过光耦的反馈，将输出电压的变化信息传递到前级控制电路，实现对输出电压的调节，保持输出电压稳定。&lt;br&gt;
● 其他元件作用：电容 C20 与电阻 R31 组成 RC 网络，可对信号进行滤波和相位补偿，防止电路产生振荡；电阻 R21 用于限制通过光耦发光二极管的电流；R24 在光耦部分起到一定的限流和保护作用 。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739612978.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739619891.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
高压低压电气隔离4.6mm&lt;br&gt;
爬电距离6.4mm&lt;br&gt;
火线和零线、普通线之间2mm&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739644447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
开槽增大爬电距离&amp;gt;0.8mm&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739668657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回路面积尽可能小&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739693693.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
导流槽，不能直接铺上去&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739811036.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739817502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739822669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739827577.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739834711.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739841218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
红胶工艺：竖着摆。&lt;br&gt;
https://blog.csdn.net/qq_33559992/article/details/121118817&lt;/p&gt;
">反激开关电源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/kai-guan-dian-yuan/"" data-c="
          &lt;p&gt;1、全桥逆变电路：&lt;br&gt;
https://blog.csdn.net/qq_42078934/article/details/127140491&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738707629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2、半桥电路：&lt;br&gt;
https://blog.csdn.net/qq_42078934/article/details/127073851&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738762019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、PUSH-PULL推挽电路&lt;br&gt;
https://blog.csdn.net/chenyongxyzg/article/details/135678046&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738804465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4、FlyBack单管反激&lt;br&gt;
https://blog.csdn.net/qq_42945764/article/details/105026626&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738844436.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5、Buck/Boost电路&lt;br&gt;
https://blog.csdn.net/qq_58845450/article/details/134695390&lt;br&gt;
6、Boost升压电路&lt;br&gt;
https://blog.csdn.net/m0_66099690/article/details/128687901&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738938807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
7、Buck降压电路&lt;br&gt;
https://blog.csdn.net/m0_66099690/article/details/128687901&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738992396.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739000442.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
8、电源防雷模块（11种）（压敏电阻、气体放电管）&lt;br&gt;
（1）、单相并联式防雷器：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742739079471.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
正常工作的时候，压敏电阻两端之间的阻抗是非常大的，可以近似地看成是开路的（实际上存在着非常微小的漏电流，一般10-20uA）。一旦雷击能量来了，会有瞬间高压加载压敏电阻上，这个时候压敏电阻就会被击穿，呈现出非常低的阻抗。这个内阻在雷电这个能量源的内阻Re面前，相对来说非常小，那么根据电阻分压的原理压敏电阻上的电压就会非常小。压敏电阻和后级负载是并联关系，因为压敏电阻相对负载电阻来说也非常小，所以大量能量都是从压敏电阻流过，被压敏电阻吸收了。通过这样的方式，就实现了对负载的保护。&lt;/p&gt;
">开关电源：</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/kuai-su-que-ding-2-ceng-dao-8-ceng-ban-de-die-ceng-she-ji/"" data-c="
          &lt;p&gt;元件面下面（第二层）为地平面，提供器件屏蔽层以及为顶层布线提供参考平面；敏感信号层应该与一个内电层相邻（内部电源/地层），利用内电层的大铜膜来为信号层提供屏蔽。电路中的高速信号传输层应该是信号中间层，并且夹在两个内电层之间。这样两个内电层的铜膜可以为高速信号传输提供电磁屏蔽，同时也能有效地将高速信号的辐射限制在两个内电层之间，不对外造成干扰。&lt;br&gt;
所有信号层尽可能与地平面相邻。&lt;br&gt;
尽量避免两信号层直接相邻；相邻的信号层之间容易引入串扰，从而导致电路功能失效。在两信号层之间加入地平面可以有效地避免串扰。&lt;br&gt;
主电源尽可能与其对应地相邻；&lt;br&gt;
对于母板的层排布，现有母板很难控制平行长距离布线，对于板级工作频率在50MHZ以上的（50MHZ以下的情况可参照，适当放宽），建议排布原则：&lt;br&gt;
● 元件面、焊接面为完整的地平面（屏蔽）；&lt;br&gt;
●无相邻平行布线层；&lt;br&gt;
●所有信号层尽可能与地平面相邻；&lt;br&gt;
●关键信号与地层相邻，不跨分割区。&lt;br&gt;
多个接地的内电层可以有效地降低接地阻抗。例如，A信号层和B信号层采用各自单独的地平面，可以有效地降低共模干扰。&lt;br&gt;
对于两层板来说，由于板层数量少，已经不存在叠层的问题。控制EMI辐射主要从布线和布局来考虑；单层板和双层板的电磁兼容问题越来越突出。造成这种现象的主要原因就是因是信号回路面积过大，不仅产生了较强的电磁辐射，而且使电路对外界干扰敏感。要改善线路的电磁兼容性，最简单的方法是减小关键信号的回路面积。关键信号：从电磁兼容的角度考虑，关键信号主要指产生较强辐射的信号和对外界敏感的信号。能够产生较强辐射的信号一般是周期性信号，如时钟或地址的低位信号。对干扰敏感的信号是指那些电平较低的模拟信号。单、双层板通常使用在低于10KHz的低频模拟设计中:1）在同一层的电源走线以辐射状走线，并最小化线的长度总和；2）走电源、地线时，相互靠近；在关键信号线边上布一条地线，这条地线应尽量靠近信号线。这样就形成了较小的回路面积，减小差模辐射对外界干扰的敏感度。当信号线的旁边加一条地线后，就形成了一个面积最小的回路，信号电流肯定会取道这个回路，而不是其它地线路径。3）如果是双层线路板，可以在线路板的另一面，紧靠近信号线的下面，沿着信号线布一条地线，一线尽量宽些。这样形成的回路面积等于线路板的厚度乘以信号线的长度。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738404172.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
SIG －GND(PWR－) PWR (GND－) SIG；2. GND－SIG(PWR)－SIG(PWR)－GND；对于以上两种叠层设计，潜在的问题是对于传统的1.6mm（62mil ）板厚。层间距将会变得很大，不仅不利于控制阻抗，层间耦合及屏蔽；特别是电源地层之间间距很大，降低了板电容，不利于滤除噪声。对于第一种方案，通常应用于板上芯片较多的情况。这种方案可得到较好的SI 性能，对于EMI性能来说并不是很好，主要要通过走线及其他细节来控制。主要注意：地层放在信号最密集的信号层的相连层，有利于吸收和抑制辐射；增大板面积，体现20H规则。对于第二种方案，通常应用于板上芯片密度足够低和芯片周围有足够面积( 放置所要求的电源覆铜层) 的场合。此种方案PCB的外层均为地层，中间两层均为信号 / 电源层。信号层上的电源用宽线走线，这可使电源电流的路径阻抗低，且信号微带路径的阻抗也低，也可通过外层地屏蔽内层信号辐射。从EMI控制的角度看， 这是现有的最佳4 层PCB结构。主要注意：中间两层信号、电源混合层间距要拉开，走线方向垂直，避免出现串扰；适当控制板面积，体现20H规则；如果要控制走线阻抗，上述方案要非常小心地将走线布置在电源和接地铺铜岛的下边。另外，电源或地层上的铺铜之间应尽可能地互连在一起，以确保DC和低频的连接性。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738439044.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于芯片密度较大、时钟频率较高的设计应考虑6 层板的设计，推荐叠层方式：1.SIG－GND－SIG－PWR－GND－SIG；对于这种方案，这种叠层方案可得到较好的信号完整性，信号层与接地层相邻，电源层和接地层配对，每个走线层的阻抗都可较好控制，且两个地层都是能良好的吸收磁力线。并且在电源、地层完整的情况下能为每个信号层都提供较好的回流路径。&lt;br&gt;
2.GND－SIG－GND－PWR－SIG －GND；对于这种方案，该种方案只适用于器件密度不是很高的情况，这种叠层具有上面叠层的所有优点，并且这样顶层和底层的地平面比较完整，能作为一个较好的屏蔽层来使用。需要注意的是电源层要靠近非主元件面的那一层，因为底层的平面会更完整。因此， EMI性能要比第一种方案好。小结：对于六层板的方案, 电源层与地层之间的间距应尽量减小，以获得好的电源、地耦合。但62mil 的板厚, 层间距虽然得到减小, 还是不容易把主电源与地层之间的间距控制得很小。对比第一种方案与第二种方案，第二种方案成本要大大增加。因此，我们叠层时通常选择第一种方案。设计时，遵循20H规则和镜像层规则设计。&lt;br&gt;
案例：&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738531485.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738536538.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">快速确定2层到8层板的叠层设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/dian-yuan-fen-ge/"" data-c="
          &lt;p&gt;a) 小电源优先在信号层铺铜，其次通过满足载流的走线连接；&lt;br&gt;
b) 12V、5V 电源如果是开关电源的输入电源，优先在信号层处理掉（表层、内层信号层），如果一定要在平面层分割，不要用作重要信号线的参考平面；这样可以有效减小此类“高”压对信号的影响；&lt;br&gt;
c) 如果分割出的电源平面用作信号的参考平面，电源平面优先作为用电模块的信号参考平面；如果有多个电源，优先参考电压低的电源；例如DDR3，使用的是1.5V 电源，则1.5V 电源平面可以用作DDR3 模块的信号参考平面，但尽量不要参考3.3V 电源或者其他电源；（通常DDR3 数据参考地平面，地址控制信号参考电源平面）&lt;br&gt;
d) 电源平面和地平面紧相邻，如果电源平面相邻的是信号层，尽量在信号层多补一些GND 铜，并打GND 过孔；&lt;br&gt;
e) 分割线宽度要合理；分割线宽度和两个电源的电压差有关，一般推荐：模数之间分割宽度：25mil；数字之间分割宽度15mil，局部可以更小一些；分割线宽度也可以根据板上空间情况灵活调整，原则上越大越好；&lt;br&gt;
f) 机壳地分割隔离宽度优先2mm，局部根据情况调整，一般要求不小于1mm；其他信号远离机壳地，包括信号线、过孔、铺铜等；&lt;br&gt;
l）确认电源、地能承载足够的电流，过孔数量是否满足承载要求。&lt;br&gt;
（估算方法：外层铜厚1oz时1A/mm线宽，内层0.5A/mm线宽）&lt;br&gt;
2）为降低平面的边缘辐射效应，在电源层与地层间要尽量满足20H原则。&lt;br&gt;
（条件允许的话，电源层的缩进得越多越好）。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737904115.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737963448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737986392.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738021528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738029138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738070600.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738078148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738126994.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738167536.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738173345.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742738179190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">电源分割</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/ge-xing-ye-de-pcb-she-ji-gui-fan/"" data-c="
          &lt;p&gt;1、铝基板PCB设计：&lt;br&gt;
铝基板往往应用於功率器件，功率密度大，所以铜箔比较厚。如果使用到3oz以上的铜箔，厚铜箔的 蚀刻加工需要工程设计线宽补偿，否则，蚀刻後线宽就会超差。 铝基板的铝基面在PCB加工过程中必须事先用保护膜给予保护，否则，一些化学药品会浸蚀铝基面， 导致外观受损。且保护膜极易被碰伤，造成缺口，这就要求整个PCB加工过程必须插架。 玻纤板锣板使用的铣刀硬度比较小，而铝基板使用的铣刀硬度大。加工过程中生产玻纤板铣刀转速快， 而生产铝基板至少慢了三分之二。 电脑铣边玻纤板只是使用机器本身的散热系统散热就可以了，但是加工铝基板就必须另外的针对锣头 加酒精散热。&lt;br&gt;
2、嵌入式PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
3、工控类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
4、消费类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
5、汽电类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
6、高频类PCB设计：&lt;br&gt;
射频走线建议：&lt;br&gt;
尽可能使用四层板，模块和天线之间的射频 PCB 走线，需要进行50Ω阻抗控制，且长度尽量短。射频线周围要用接地铜箔包裹，接地铜箔距离射频线的间距要求为 2 倍射频线线宽以上，接地铜箔要多打接地过孔，保证接地阻抗尽量小。为减小RF 焊盘较大导致寄生电容较大而引起的天线性能降低的可能性，模块射频焊盘下第一层和第二层都建议挖空。双层板无法控制阻抗，所以在双层板走线时，尽量把射频线走短（弧线），然后线宽在30&lt;sub&gt;40mil，走线到周围地铜箔距离在1&lt;/sub&gt;1.5 倍线宽之间。建议采用周边的地铜箔作为参考平面，根据走线到地铜箔的间距以及走线线宽来计算阻抗（也可以要求板厂做50 欧姆阻抗匹配，因为阻抗也跟材质有关——介电常数）。一般推荐采用π型滤波，即串联一个电感，在电感两端并联1 个到地电容，在不需要进行匹配时，可以不焊电容，将电感用0 欧姆电阻替代。如果经过较长走线，则中间需要增加匹配网络，如下图所示。&lt;br&gt;
&lt;img src=&#34;https://mygithubma.github.io/post-images/1742737755182.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
7、通信类PCB设计：&lt;br&gt;
理清电路原理的信号走向&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;br&gt;
8、军工类PCB设计：&lt;br&gt;
理清电路原理的电源走向&lt;br&gt;
模块化布局设计&lt;br&gt;
布局遵循先接口、大芯片、小器件的顺序&lt;br&gt;
模块化布线设计&lt;br&gt;
布线遵循先短线后长线的顺序&lt;br&gt;
整板走线要优化处理，线尽量等间距，过孔要对齐等距&lt;br&gt;
晶振模块输入输出线要加粗及包地处理&lt;br&gt;
差分线要控制阻抗及包地处理&lt;/p&gt;
">各行业的PCB设计规范</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/conda-ming-ling-xing/"" data-c="
          &lt;p&gt;conda --version 查看conda的版本&lt;br&gt;
conda config --show  查看conda的环境配置&lt;br&gt;
#设置清华镜像&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/&lt;br&gt;
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/&lt;br&gt;
#设置bioconda&lt;br&gt;
conda config --add channels bioconda&lt;br&gt;
conda config --add channels conda-forge&lt;br&gt;
#设置搜索时显示通道地址&lt;br&gt;
conda config --set show_channel_urls yes&lt;br&gt;
conda env list 查看conda的环境&lt;br&gt;
conda activate env 激活环境&lt;br&gt;
conda deactivate  退出环境&lt;br&gt;
conda remove --name env_name --all 删除指定环境&lt;br&gt;
conda remove --name env_name package_name删除环境中的指定包&lt;br&gt;
conda create -n env_name python=3.9 创建环境&lt;br&gt;
conda info 查看当前环境&lt;/p&gt;
">conda命令行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/xteminal-ming-ling-xing/"" data-c="
          &lt;p&gt;ssh 192.168.31.143 连接树莓派&lt;br&gt;
su - root 进入root&lt;br&gt;
vncserver-virtual 启动vncserver&lt;br&gt;
改变虚拟界面分辨率&lt;br&gt;
sudo raspi-config&lt;br&gt;
vncserver-virtual -geometry 1920x1080&lt;br&gt;
vncserver-virtual -kill :1结束虚拟界面&lt;br&gt;
scp mzc@192.168.31.143:/E:... /home/&lt;/p&gt;
">Xteminal命令行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://mygithubma.github.io/yolo-chuang-jian-huan-jing-ming-ling-xing/"" data-c="
          &lt;p&gt;1、conda create -n XXX(环境名）python=X.X(该环境中希望安装的python版本。  --yolo -python3.9&lt;br&gt;
2、conda activate yolo --进入创建的虚拟环境&lt;br&gt;
3、conda list --查看环境配置&lt;br&gt;
4、conda install cudnn==8.1.0&lt;br&gt;
5、cmd命令：&lt;br&gt;
cd /    回到根目录&lt;br&gt;
cd ../  回到上一级目录&lt;br&gt;
进入某一目录：直接D:或者E:&lt;br&gt;
6、pip install -r requirements.txt&lt;br&gt;
7、conda info --envs  查看创建的虚拟环境路径&lt;br&gt;
8、报错：&lt;br&gt;
ckagesNotFoundError: The following packages are not available from current channels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;torchvision==0.10.0+cu111&lt;/li&gt;
&lt;li&gt;torch==1.9.0+cu111&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Current channels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2&lt;/li&gt;
&lt;li&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge&lt;/li&gt;
&lt;li&gt;defaults&lt;/li&gt;
&lt;li&gt;https://repo.anaconda.com/pkgs/main&lt;/li&gt;
&lt;li&gt;https://repo.anaconda.com/pkgs/r&lt;/li&gt;
&lt;li&gt;https://repo.anaconda.com/pkgs/msys2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To search for alternate channels that may provide the conda package you&#39;re&lt;br&gt;
looking for, navigate to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://anaconda.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and use the search bar at the top of the page.&lt;br&gt;
解决：在该链接https://anaconda.org下搜索&lt;br&gt;
9、pillow和pytorch、numpy版本问题，安装卸载使用pip，不用conda，解决。&lt;br&gt;
10、安装pyqt：&lt;br&gt;
pip install PyQt5&lt;br&gt;
pip install pyqt5-tools -i https://pypi.tuna.tsinghua.edu.cn/simple&lt;br&gt;
11、conda create -n XXX --clone yolo5   复制已有环境&lt;br&gt;
12、conda env list  查看创建的环境&lt;br&gt;
13、conda config --show channels 查看源&lt;br&gt;
14、conda config --remove channels https:// 删除源&lt;br&gt;
15、conda clean --all 清除缓存&lt;br&gt;
16、conda config --add channels ... 添加源&lt;br&gt;
17、nvcc --version 查看CUDA版本&lt;br&gt;
18、watch -n 1 nvidia-smi 查看GPU使用情况&lt;br&gt;
19、dwebp input.webp -o output.png 将webp文件转换为png文件&lt;br&gt;
20、conda env remove -n myenv 删除环境&lt;/p&gt;
">Yolo创建环境命令行：</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>